//VERSION TRUNK-20130117


/*global pvc:true */
var pvc = def.globalSpace('pvc', {
    // 0 - off
    // 1 - errors 
    // 2 - errors, warnings
    // 3 - errors, warnings, info
    // 4 - verbose
    // 5 - trash
    // ...
    debug: 0
});

// Begin private scope
(function(){

    // Check URL debug and debugLevel
    (function(){
        /*global window:true*/
        if((typeof window.location) !== 'undefined'){
            var url = window.location.href;
            if(url && (/\bdebug=true\b/).test(url)){
                var m = /\bdebugLevel=(\d+)/.exec(url);
                pvc.debug = m ? (+m[1]) : 3;
            }
        }
    }());
    
    // goldenRatio proportion
    // ~61.8% ~ 38.2%
    //pvc.goldenRatio = (1 + Math.sqrt(5)) / 2;
    
    pvc.invisibleFill = 'rgba(127,127,127,0.00001)';
    
    pvc.logSeparator = "------------------------------------------";
    
    var arraySlice = pvc.arraySlice = Array.prototype.slice;
    
    pvc.setDebug = function(level){
        level = +level;
        pvc.debug = isNaN(level) ? 0 : level;
        
        syncTipsyLog();
        
        return pvc.debug;
    };
    
    /**
     *  Utility function for logging messages to the console
     */
    pvc.log = function(m){
        if (pvc.debug && typeof console !== "undefined"){
            /*global console:true*/
            console.log("[pvChart]: " + 
              (typeof m === 'string' ? m : pvc.stringify(m)));
        }
    };
    
    pvc.logError = function(e){
        if(e && typeof e === 'object' && e.message){
            e = e.message;
        }
        
        /*global console:true*/
        if (typeof console != "undefined"){
            console.log("[pvChart ERROR]: " + e);
        } else {
            throw new Error("[pvChart ERROR]: " + e);
        }
    };
    
    // Redirect protovis error handler
    pv.error = pvc.logError;
    
    function syncTipsyLog(){
        var tip = pv.Behavior.tipsy;
        if(tip && tip.setDebug){
            tip.setDebug(pvc.debug);
            tip.log = pvc.log;
        }
    }
    
    syncTipsyLog();
    
    /**
     * Gets or sets the default CCC compatibility mode. 
     * <p>
     * Use <tt>Infinity</tt> for the <i>latest</i> version.
     * Use <tt>1</tt> for CCC version 1.
     * </p>
     * 
     * @param {number} [compatVersion] The new compatibility version.    
     */
    pvc.defaultCompatVersion = function(compatVersion){
        var defaults = pvc.BaseChart.prototype.defaults;
        if(compatVersion != null){
            return defaults.compatVersion = compatVersion;
        } 
        
        return defaults.compatVersion;
    };
    
    pvc.cloneMatrix = function(m){
        return m.map(function(d){
            return d.slice();
        });
    };
    
    pvc.stringify = function(t, keyArgs){
        var maxLevel = def.get(keyArgs, 'maxLevel') || 5;
        
        var out = [];
        pvc.stringifyRecursive(out, t, maxLevel, keyArgs);
        return out.join('');
    };
    
    pvc.stringifyRecursive = function(out, t, remLevels, keyArgs){
        if(remLevels > 0){
            remLevels--;
            switch(typeof t){
                case 'undefined': return out.push('undefined');
                case 'object':
                    if(!t){ 
                        out.push('null');
                        return true;
                    }
                    
                    if(def.fun.is(t.stringify)){
                        return t.stringify(out, remLevels, keyArgs);
                    }
                    
                    if(t instanceof Array){
                        out.push('[');
                        t.forEach(function(item, index){
                            if(index){ out.push(', '); }
                            if(!pvc.stringifyRecursive(out, item, remLevels, keyArgs)){
                                out.pop();
                            }
                        });
                        out.push(']');
                    } else if(t.constructor === Object){
                        out.push('{');
                        var first = true;
                        var ownOnly  = def.get(keyArgs, 'ownOnly', true);
                        for(var p in t){
                            if(!ownOnly || def.hasOwnProp.call(t, p)){
                                if(!first){ out.push(', '); }
                                out.push(p + ': ');
                                if(!pvc.stringifyRecursive(out, t[p], remLevels, keyArgs)){
                                    out.pop();
                                    if(!first){ out.pop(); }
                                } else if(first){
                                    first = false;
                                }
                            }
                        }
                        out.push('}');
                    } else {
                        out.push(JSON.stringify("'new ...'"));
                    }
                    return true;
                
                case 'number':
                case 'boolean': 
                    out.push(''+t);
                    return true;
                    
                case 'string': 
                    out.push(JSON.stringify(t));
                    return true;
                    
                case 'function':
                    if(def.get(keyArgs, 'funs', false)){
                        out.push(JSON.stringify(t.toString().substr(0, 13) + '...'));
                        return true;
                    }
                    
                    return false;
            }
            
            out.push("'new ???'");
            return true;
        }
    };
    
    pvc.orientation = {
        vertical:   'vertical',
        horizontal: 'horizontal'
    };
    
    /** 
     * To tag pv properties set by extension points
     * @type string 
     * @see pvc.BaseChart#extend
     */
    pvc.extensionTag = 'extension';
    
    /**
     * Extends a type created with {@link def.type}
     * with the properties in {@link exts}, 
     * possibly constrained to the properties of specified names.
     * <p>
     * The properties whose values are not functions
     * are converted to constant functions that return the original value.
     * </p>
     * @param {function} type
     *      The type to extend.
     * @param {object} [exts] 
     *      The extension object whose properties will extend the type.
     * @param {string[]} [names]
     *      The allowed property names. 
     */
    pvc.extendType = function(type, exts, names){
        if(exts){
            var exts2;
            var addExtension = function(ext, name){
                if(ext !== undefined){
                    if(!exts2){
                        exts2 = {};
                    }
                    exts2[name] = def.fun.to(ext);
                }
            };
            
            if(names){
                names.forEach(function(name){
                    addExtension(exts[name], name);
                });
            } else {
                def.each(addExtension);
            }
            
            if(exts2){
               type.add(exts2);
            }
        }
    };
    
    pv.Mark.prototype.hasDelegateValue = function(name, tag) {
        var p = this.$propertiesMap[name];
        if(p){
            return (!tag || p.tag === tag);
        }
        
        // This mimics the way #bind works
        if(this.proto){
            return this.proto.hasDelegateValue(name, tag);
        }
        
        return false;
    };
    
    /**
     * The default color scheme used by charts.
     * <p>
     * Charts use the color scheme specified in the chart options 
     * {@link pvc.BaseChart#options.colors}
     * and 
     * {@link pvc.BaseChart#options.color2AxisColorss}, 
     * for the main and second axis series, respectively, 
     * or, when any is unspecified, 
     * the default color scheme.
     * </p>
     * <p>
     * When null, the color scheme {@link pv.Colors.category10} is implied. 
     * To obtain the default color scheme call {@link pvc.createColorScheme}
     * with no arguments. 
     * </p>
     * <p>
     * To be generically useful, 
     * a color scheme should contain at least 10 colors.
     * </p>
     * <p>
     * A color scheme is a function that creates a {@link pv.Scale} color scale function
     * each time it is called. 
     * It sets as its domain the specified arguments and as range 
     * the pre-spcecified colors of the color scheme.
     * </p>
     * 
     * @readonly
     * @type function
     */
    pvc.defaultColorScheme = null;
    
    pvc.brighterColorTransform = function(color){
        return (color.rgb ? color : pv.color(color)).brighter(0.6);
    };
    
    /**
     * Sets the colors of the default color scheme used by charts 
     * to a specified color array.
     * <p>
     * If null is specified, the default color scheme is reset to its original value.
     * </p>
     * 
     * @param {string|pv.Color|string[]|pv.Color[]|pv.Scale|function} [colors=null] Something convertible to a color scheme by {@link pvc.colorScheme}.
     * @return {null|pv.Scale} A color scale function or null.
     */
    pvc.setDefaultColorScheme = function(colors){
        return pvc.defaultColorScheme = pvc.colorScheme(colors);
    };
    
    pvc.defaultColor = pv.Colors.category10()('?');
    
    /**
     * Creates a color scheme if the specified argument is not one already.
     * 
     * @param {string|pv.Color|string[]|pv.Color[]|pv.Scale|function} [colors=null] A value convertible to a color scheme: 
     * a color string, 
     * a color object, 
     * an array of color strings or objects, 
     * a color scale function, 
     * or null.
     * 
     * @returns {null|function} A color scheme function or null.
     */
    pvc.colorScheme = function(colors){
        if(colors == null){
            return null;
        }
        
        if(typeof colors === 'function') {
            if(!colors.hasOwnProperty('range')){
                // Assume already a color scheme (a color scale factory)
                return colors;
            }
            
            // A protovis color scale
            // Obtain its range colors array and discard the scale function.
            colors = colors.range();
        } else {
            colors = def.array.as(colors);
        }
        
        if(!colors.length){
            return null;
        }
        
        return function() {
            var scale = pv.colors(colors); // creates a color scale with a defined range
            scale.domain.apply(scale, arguments); // defines the domain of the color scale
            return scale;
        };
    },
    
    /**
     * Creates a color scheme based on the specified colors.
     * When no colors are specified, the default color scheme is returned.
     * 
     * @see pvc.defaultColorScheme 
     * @param {string|pv.Color|string[]|pv.Color[]|pv.Scale|function} [colors=null] Something convertible to a color scheme by {@link pvc.colorScheme}.
     * @type function
     */
    pvc.createColorScheme = function(colors){
        return pvc.colorScheme(colors) ||
               pvc.defaultColorScheme  ||
               pv.Colors.category10;
    };
    
    // Convert to Grayscale using YCbCr luminance conv.
    pvc.toGrayScale = function(color, alpha, maxGrayLevel, minGrayLevel){
        color = pv.color(color);
        
        var avg = 0.299 * color.r + 0.587 * color.g + 0.114 * color.b;
        // Don't let the color get near white, or it becomes unperceptible in most monitors
        if(maxGrayLevel === undefined) {
            maxGrayLevel = 200;
        } else if(maxGrayLevel == null){
            maxGrayLevel = 255; // no effect
        }
        
        if(minGrayLevel === undefined){
            minGrayLevel = 30;
        } else if(minGrayLevel == null){
            minGrayLevel = 0; // no effect
        }
        
        var delta = (maxGrayLevel - minGrayLevel);
        if(delta <= 0){
            avg = maxGrayLevel;
        } else {
            // Compress
            avg = minGrayLevel + (avg / 255) * delta;
        }
        
        if(alpha == null){
            alpha = color.opacity;
        } else if(alpha < 0){
            alpha = (-alpha) * color.opacity;
        }
        
        avg = Math.round(avg);
        
        return pv.rgb(avg, avg, avg, alpha);
    };
    
    // TODO: change the name of this
    pvc.removeTipsyLegends = function(){
        try {
            $('.tipsy').remove();
        } catch(e) {
            // Do nothing
        }
    };
    
    pvc.createDateComparer = function(parser, key){
        if(!key){
            key = pv.identity;
        }
        
        return function(a, b){
            return parser.parse(key(a)) - parser.parse(key(b));
        };
    };
    
    pv.Format.createParser = function(pvFormat) {
        
        function parse(value) {
            return pvFormat.parse(value);
        }
        
        return parse;
    };
    
    pv.Format.createFormatter = function(pvFormat) {
        
        function format(value) {
            return value != null ? pvFormat.format(value) : "";
        }
        
        return format;
    };
    
    pvc.buildTitleFromName = function(name){
        // TODO: i18n
        return def.firstUpperCase(name).replace(/([a-z\d])([A-Z])/, "$1 $2");
    };
    
    pvc.buildIndexedId = function(prefix, index){
        if(index > 0) {
            return prefix + "" + (index + 1); // base2, ortho3,..., legend2
        }
        
        return prefix; // base, ortho, legend
    };
    
    /**
     * Splits an indexed id into its prefix and index.
     * 
     * @param {string} indexedId The indexed id.
     * 
     * @type Array
     */
    pvc.splitIndexedId = function(indexedId){
        var match = /^(.*?)(\d*)$/.exec(indexedId);
        var index = null;
        
        if(match[2]) {
            index = Number(match[2]);
            if(index <= 1) {
                index = 1;
            } else {
                index--;
            }
        }
        
        return [match[1], index];
    };
    
    function unwrapExtensionOne(id, prefix){
        if(id){
            if(def.object.is(id)){
                return id.abs;
            }
            
            return prefix ? (prefix + def.firstUpperCase(id)) : id;
        }
        
        return prefix;
    }
    
    var oneNullArray = [null];
    
    pvc.makeExtensionAbsId = function(id, prefix){
        if(!id){
            return prefix;
        }
        
        return def
           .query(prefix || oneNullArray)
           .selectMany(function(oneprefix){
               return def
                   .query(id)
                   .select(function(oneid){
                       return unwrapExtensionOne(oneid, oneprefix);
                   });
           })
           .where(def.truthy)
           .array()
           ;
    };
    
    pvc.parseDistinctIndexArray = function(value, max){
        value = def.array.as(value);
        if(value == null){
            return null;
        }
        
        if(max == null){
            max = Infinity;
        }
        
        var a = def
            .query(value)
            .select(function(index){ return +index; }) // to number
            .where(function(index){ return !isNaN(index) && index >= 0 && index <= max; })
            .distinct()
            .array();
        
        return a.length ? a : null;
    };
    
    pvc.parseLegendClickMode = function(clickMode){
        if(!clickMode){
            clickMode = 'none';
        }
        
        switch(clickMode){
            case 'toggleSelected':
            case 'toggleVisible':
            case 'none':
                break;
                
            default:
                if(pvc.debug >= 2){
                    pvc.log("[Warning] Invalid 'legendClickMode' option value: '" + clickMode + "'. Assuming 'none'.");
                }
            
                clickMode = 'none';
                break;
        }
        
        return clickMode;
    };
    
    pvc.parseShape = function(shape){
        if(shape){
            switch(shape){
                case 'square':
                case 'circle':
                case 'diamond':
                case 'triangle':
                case 'cross':
                case 'bar':
                    break;
                default:
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'shape' option value: '" + shape + "'.");
                    }
                
                    shape = null;
                    break;
            }
        }
        
        return shape;
    };
    
    pvc.parseContinuousColorScaleType = function(scaleType){
        if(scaleType){
            switch(scaleType){
                case 'linear':
                case 'normal':
                case 'discrete':
                    break;
                
                default:
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'ScaleType' option value: '" + scaleType + "'.");
                    }
                
                scaleType = null;
                    break;
            }
        }
        
        return scaleType;  
    };
    
    pvc.parseDomainScope = function(scope, orientation){
        if(scope){
            switch(scope){
                case 'cell':
                case 'global':
                    break;
                
                case 'section': // row (for y) or col (for x), depending on the associated orientation
                    if(!orientation){
                        throw def.error.argumentRequired('orientation');
                    }
                    
                    scope = orientation === 'y' ? 'row' : 'column';
                    break;
                    
                case 'column':
                case 'row':
                    if(orientation && orientation !== (scope === 'row' ? 'y' : 'x')){
                        scope = 'section';
                        
                        if(pvc.debug >= 2){
                            pvc.log("[Warning] Invalid 'DomainScope' option value: '" + scope + "' for the orientation: '" + orientation + "'.");
                        }
                    }
                    break;
                
                default:
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'DomainScope' option value: '" + scope + "'.");
                    }
                
                    scope = null;
                    break;
            }
        }
        
        return scope;
    };
    
    pvc.parseDomainRoundingMode = function(mode){
        if(mode){
            switch(mode){
                case 'none':
                case 'nice':
                case 'tick':
                    break;
                    
                default:
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'DomainRoundMode' value: '" + mode + "'.");
                    }
                
                    mode = null;
                    break;
            }
        }
        
        return mode;
    };
    
    pvc.parseOverlappedLabelsMode = function(mode){
        if(mode){
            switch(mode){
                case 'leave':
                case 'hide':
                    break;
                
                default:
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'OverlappedLabelsMode' option value: '" + mode + "'.");
                    }
                
                    mode = null;
                    break;
            }
        }
        
        return mode;
    };
    
    pvc.castNumber = function(value) {
        if(value != null) {
            value = +value; // to number
            if(isNaN(value)) {
                value = null;
            }
        }
        
        return value;
    };
    
    pvc.parseWaterDirection = function(value) {
        if(value){
            switch(value){
                case 'up':
                case 'down':
                    return value;
            }
            
            if(pvc.debug >= 2){
                pvc.log("[Warning] Invalid 'WaterDirection' value: '" + value + "'.");
            }
        }
    };
    
    pvc.parseTrendType = function(value) {
        if(value){
            if(value === 'none'){
                return value;
            }
            
            if(pvc.trends.has(value)){
                return value;
            }
            
            if(pvc.debug >= 2){
                pvc.log("[Warning] Invalid 'TrendType' value: '" + value + "'.");
            }
        }
    };
    
    pvc.parseNullInterpolationMode = function(value) {
        if(value){
            switch(value){
                case 'none':
                case 'linear':
                case 'zero':
                    return value;
            }
            
            if(pvc.debug >= 2){
                pvc.log("[Warning] Invalid 'NullInterpolationMode' value: '" + value + "'.");
            }
        }
    };
    
    pvc.parseAlign = function(side, align){
        var align2, isInvalid;
        if(side === 'left' || side === 'right'){
            align2 = align && pvc.BasePanel.verticalAlign[align];
            if(!align2){
                align2 = 'middle';
                isInvalid = !!align;
            }
        } else {
            align2 = align && pvc.BasePanel.horizontalAlign[align];
            if(!align2){
                align2 = 'center';
                isInvalid = !!align;
            }
        }
        
        if(isInvalid && pvc.debug >= 2){
            pvc.log(def.format("Invalid alignment value '{0}'. Assuming '{1}'.", [align, align2]));
        }
        
        return align2;
    };
    
    // suitable for protovis.anchor(..) of all but the Wedge mark... 
    pvc.parseAnchor = function(anchor){
        if(anchor){
            switch(anchor){
                case 'top':
                case 'left':
                case 'center':
                case 'bottom':
                case 'right':
                    return anchor;
            }
            
            if(pvc.debug >= 2){
                pvc.log(def.format("Invalid anchor value '{0}'.", [anchor]));
            }
        }
    };
    
    pvc.parseAnchorWedge = function(anchor){
        if(anchor){
            switch(anchor){
                case 'outer':
                case 'inner':
                case 'center':
                case 'start':
                case 'end':
                    return anchor;
            }
            
            if(pvc.debug >= 2){
                pvc.log(def.format("Invalid wedge anchor value '{0}'.", [anchor]));
            }
        }
    };
    
    pvc.unionExtents = function(result, range){
        if(!result) {
            if(!range){
                return null;
            }

            result = {min: range.min, max: range.max};
        } else if(range){
            if(range.min < result.min){
                result.min = range.min;
            }

            if(range.max > result.max){
                result.max = range.max;
            }
        }

        return result;
    };
    
    /**
     * Creates a margins/sides object.
     * @constructor
     * @param {string|number|object} sides May be a css-like shorthand margin string.
     * 
     * <ol>
     *   <li> "1" - {all: '1'}</li>
     *   <li> "1 2" - {top: '1', left: '2', right: '2', bottom: '1'}</li>
     *   <li> "1 2 3" - {top: '1', left: '2', right: '2', bottom: '3'}</li>
     *   <li> "1 2 3 4" - {top: '1', right: '2', bottom: '3', left: '4'}</li>
     * </ol>
     */
    pvc.Sides = function(sides){
        if(sides != null){
            this.setSides(sides);
        }
    };
    
    pvc.Sides.hnames = 'left right'.split(' ');
    pvc.Sides.vnames = 'top bottom'.split(' ');
    pvc.Sides.names = 'left right top bottom'.split(' ');
    pvc.Sides.namesSet = pv.dict(pvc.Sides.names, def.retTrue);
    
    pvc.parsePosition = function(side, defaultSide){
        if(side && !def.hasOwn(pvc.Sides.namesSet, side)){
            if(!defaultSide){
                defaultSide = 'left';
            }
            
            if(pvc.debug >= 2){
                pvc.log(def.format("Invalid position value '{0}. Assuming '{1}'.", [side, defaultSide]));
            }
            
            side = defaultSide;
        }
        
        return side;
    };
    
    pvc.Sides.as = function(v){
        if(v != null && !(v instanceof pvc.Sides)){
            v = new pvc.Sides().setSides(v);
        }
        
        return v;
    };
    
    pvc.Sides.prototype.stringify = function(out, remLevels, keyArgs){
        return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
    };
    
    pvc.Sides.prototype.setSides = function(sides){
        if(typeof sides === 'string'){
            var comps = sides.split(/\s+/).map(function(comp){
                return pvc.PercentValue.parse(comp);
            });
            
            switch(comps.length){
                case 1:
                    this.set('all', comps[0]);
                    return this;
                    
                case 2:
                    this.set('top',    comps[0]);
                    this.set('left',   comps[1]);
                    this.set('right',  comps[1]);
                    this.set('bottom', comps[0]);
                    return this;
                    
                case 3:
                    this.set('top',    comps[0]);
                    this.set('left',   comps[1]);
                    this.set('right',  comps[1]);
                    this.set('bottom', comps[2]);
                    return this;
                    
                case 4:
                    this.set('top',    comps[0]);
                    this.set('right',  comps[1]);
                    this.set('bottom', comps[2]);
                    this.set('left',   comps[3]);
                    return this;
                    
                case 0:
                    return this;
            }
        } else if(typeof sides === 'number') {
            this.set('all', sides);
            return this;
        } else if (typeof sides === 'object') {
            if(sides instanceof pvc.PercentValue){
                this.set('all', sides);
            } else {
                this.set('all', sides.all);
                for(var p in sides){
                    if(p !== 'all' && pvc.Sides.namesSet.hasOwnProperty(p)){
                        this.set(p, sides[p]);
                    }
                }
            }
            
            return this;
        }
        
        if(pvc.debug) {
            pvc.log("Invalid 'sides' value: " + pvc.stringify(sides));
        }
        
        return this;
    };
    
    pvc.Sides.prototype.set = function(prop, value){
        value = pvc.PercentValue.parse(value);
        if(value != null){
            if(prop === 'all'){
                // expand
                pvc.Sides.names.forEach(function(p){
                    this[p] = value;
                }, this);
                
            } else if(def.hasOwn(pvc.Sides.namesSet, prop)){
                this[prop] = value;
            }
        }
    };
    
    pvc.Sides.prototype.resolve = function(width, height){
        if(typeof width === 'object'){
            height = width.height;
            width  = width.width;
        }
        
        var sides = {};
        
        pvc.Sides.names.forEach(function(side){
            var value  = 0;
            var sideValue = this[side];
            if(sideValue != null){
                if(typeof(sideValue) === 'number'){
                    value = sideValue;
                } else {
                    value = sideValue.resolve((side === 'left' || side === 'right') ? width : height);
                }
            }
            
            sides[side] = value;
        }, this);
        
        return pvc.Sides.updateSize(sides);
    };
    
    pvc.Sides.updateSize = function(sides){
        sides.width  = (sides.left   || 0) + (sides.right || 0);
        sides.height = (sides.bottom || 0) + (sides.top   || 0);
        
        return sides;
    };
    
    pvc.Sides.resolvedMax = function(a, b){
        var sides = {};
        
        pvc.Sides.names.forEach(function(side){
            sides[side] = Math.max(a[side] || 0, b[side] || 0);
        });
        
        return sides;
    };
    
    pvc.Sides.inflate = function(sides, by){
        var sidesOut = {};
        
        pvc.Sides.names.forEach(function(side){
            sidesOut[side] = (sides[side] || 0) + by;
        });
        
        return pvc.Sides.updateSize(sidesOut);
    };
    
    // -------------
    
    pvc.PercentValue = function(pct){
        this.percent = pct;
    };
    
    pvc.PercentValue.prototype.resolve = function(total){
        return this.percent * total;
    };
    
    pvc.PercentValue.parse = function(value){
        if(value != null && value !== ''){
            switch(typeof value){
                case 'number': return value;
                case 'string':
                    var match = value.match(/^(.+?)\s*(%)?$/);
                    if(match){
                        var n = +match[1];
                        if(!isNaN(n)){
                            if(match[2]){
                                if(n >= 0){
                                    return new pvc.PercentValue(n / 100);
                                }
                            } else {
                                return n;
                            }
                        }
                    }
                    break;
                    
                case 'object':
                    if(value instanceof pvc.PercentValue){
                        return value;
                    }
                    break;
            }
            
            if(pvc.debug){
                pvc.log(def.format("Invalid margins component '{0}'", [''+value]));
            }
        }
    };
    
    pvc.PercentValue.resolve = function(value, total){
        return (value instanceof pvc.PercentValue) ? value.resolve(total) : value;
    };
    
    /* Z-Order */
    
    // Backup original methods
    var markRenderCore = pv.Mark.prototype.renderCore,
        markZOrder = pv.Mark.prototype.zOrder;
    
    pv.Mark.prototype.zOrder = function(zOrder) {
        var borderPanel = this.borderPanel;
        if(borderPanel && borderPanel !== this){
            return markZOrder.call(borderPanel, zOrder);
        }
        
        return markZOrder.call(this, zOrder);
    };
    
    /* Render id */
    pv.Mark.prototype.renderCore = function(){
        /* Assign a new render id to the root mark */
        var root = this.root;
        
        root._renderId = (root._renderId || 0) + 1;
        
        if(pvc.debug >= 25){
            pvc.log("BEGIN RENDER " + root._renderId);
        }
        
        /* Render */
        markRenderCore.apply(this, arguments);
        
        if(pvc.debug >= 25){
            pvc.log("END RENDER " + root._renderId);
        }
    };
    
    pv.Mark.prototype.renderId = function(){
        return this.root._renderId;
    };
    
    /* PROPERTIES */
    pv.Mark.prototype.wrapper = function(wrapper){
        this._wrapper = wrapper;
        
        return this;
    };
    
    pv.Mark.prototype.wrap = function(f, m){
        if(f && def.fun.is(f) && this._wrapper && !f._cccWrapped){
            f = this._wrapper(f, m);
            
            f._cccWrapped = true;
        }
        
        return f;
    };
    
    pv.Mark.prototype.lock = function(prop, value){
        if(value !== undefined){
            this[prop](value);
        }
    
        (this._locked || (this._locked = {}))[prop] = true;
        
        return this;
    };
    
    pv.Mark.prototype.isIntercepted = function(prop){
        return this._intercepted && this._intercepted[prop];
    };
    
    pv.Mark.prototype.isLocked = function(prop){
        return this._locked && this._locked[prop];
    };
    
    /* ANCHORS */
    /**
     * name = left | right | top | bottom
     */
    pv.Mark.prototype.addMargin = function(name, margin) {
        if(margin !== 0){
            var staticValue = def.nullyTo(this.propertyValue(name), 0),
                fMeasure    = pv.functor(staticValue);
            
            this[name](function(){
                return margin + fMeasure.apply(this, arraySlice.call(arguments));
            });
        }
        
        return this;
    };
    
    /**
     * margins = {
     *      all:
     *      left:
     *      right:
     *      top:
     *      bottom:
     * }
     */
    pv.Mark.prototype.addMargins = function(margins) {
        var all = def.get(margins, 'all', 0);
        
        this.addMargin('left',   def.get(margins, 'left',   all));
        this.addMargin('right',  def.get(margins, 'right',  all));
        this.addMargin('top',    def.get(margins, 'top',    all));
        this.addMargin('bottom', def.get(margins, 'bottom', all));
        
        return this;
    };
    
    /* SCENE */
    pv.Mark.prototype.eachInstanceWithData = function(fun, ctx){
        this.eachInstance(function(scenes, index, t){
            var instance = scenes[index];
            if(instance.datum || instance.group){
                fun.call(ctx, scenes, index, t);
            }
        });
    };
    
    /* BOUNDS */
    pv.Transform.prototype.transformHPosition = function(left){
        return this.x + (this.k * left);
    };
    
    pv.Transform.prototype.transformVPosition = function(top){
        return this.y + (this.k * top);
    };
    
    // width / height
    pv.Transform.prototype.transformLength = function(length){
        return this.k * length;
    };
    
    // --------------------
    
    var Size = def.type('pvc.Size')
    .init(function(width, height){
        if(arguments.length === 1){
            if(width != null){
                this.setSize(width);
            }
        } else {
            if(width != null){
                this.width  = width;
            }
            
            if(height != null){
                this.height = height;
            }
        }
    })
    .add({
        stringify: function(out, remLevels, keyArgs){
            return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
        },
        
        setSize: function(size, keyArgs){
            if(typeof size === 'string'){
                var comps = size.split(/\s+/).map(function(comp){
                    return pvc.PercentValue.parse(comp);
                });
                
                switch(comps.length){
                    case 1: 
                        this.set(def.get(keyArgs, 'singleProp', 'all'), comps[0]);
                        return this;
                        
                    case 2:
                        this.set('width',  comps[0]);
                        this.set('height', comps[1]);
                        return this;
                        
                    case 0:
                        return this;
                }
            } else if(typeof size === 'number') {
                this.set(def.get(keyArgs, 'singleProp', 'all'), size);
                return this;
            } else if (typeof size === 'object') {
                if(size instanceof pvc.PercentValue){
                    this.set(def.get(keyArgs, 'singleProp', 'all'), size);
                } else {
                    
                    this.set('all', size.all);
                    for(var p in size){
                        if(p !== 'all'){
                            this.set(p, size[p]);
                        }
                    }
                }
                return this;
            }
            
            if(pvc.debug) {
                pvc.log("Invalid 'size' value: " + pvc.stringify(size));
            }
            
            return this;
        },
        
        set: function(prop, value){
            if(value != null && (prop === 'all' || def.hasOwn(pvc.Size.namesSet, prop))){
                value = pvc.PercentValue.parse(value);
                if(value != null){
                    if(prop === 'all'){
                        // expand
                        pvc.Size.names.forEach(function(p){
                            this[p] = value;
                        }, this);
                        
                    } else {
                        this[prop] = value;
                    }
                }
            }
            
            return this;
        },
        
        clone: function(){
            return new Size(this.width, this.height);
        },
        
        intersect: function(size){
            return new Size(
                   Math.min(this.width,  size.width), 
                   Math.min(this.height, size.height));
        },
        
        resolve: function(refSize){
            var size = {};
            
            pvc.Size.names.forEach(function(length){
                var lengthValue = this[length];
                if(lengthValue != null){
                    if(typeof(lengthValue) === 'number'){
                        size[length] = lengthValue;
                    } else if(refSize){
                        var refLength = refSize[length];
                        if(refLength != null){
                            size[length] = lengthValue.resolve(refLength);
                        }
                    }
                }
            }, this);
            
            return size;
        }
    });
    
    pvc.Size.names = ['width', 'height'];
    pvc.Size.namesSet = pv.dict(pvc.Size.names, def.retTrue);
    
    pvc.Size.toOrtho = function(value, anchor){
        if(value != null){
            // Single size (a number or a string with only one number)
            // should be interpreted as meaning the orthogonal length.
            var a_ol;
            if(anchor){
                a_ol = pvc.BasePanel.orthogonalLength[anchor];
            }
            
            value = pvc.Size.to(value, {singleProp: a_ol});
            
            if(anchor){
                delete value[pvc.BasePanel.oppositeLength[a_ol]];
            }
        }
        
        return value;
    };
    
    pvc.Size.to = function(v, keyArgs){
        if(v != null && !(v instanceof Size)){
            v = new Size().setSize(v, keyArgs);
        }
        
        return v;
    };
    
    // --------------------
    
    var Offset = def.type('pvc.Offset')
    .init(function(x, y){
        if(arguments.length === 1){
            if(x != null){
                this.setOffset(x);
            }
        } else {
            if(x != null){
                this.x = x;
            }
            
            if(y != null){
                this.y = y;
            }
        }
    })
    .add({
        stringify: function(out, remLevels, keyArgs){
            return pvc.stringifyRecursive(out, def.copyOwn(this), remLevels, keyArgs);
        },
        
        setOffset: function(offset, keyArgs){
            if(typeof offset === 'string'){
                var comps = offset.split(/\s+/).map(function(comp){
                    return pvc.PercentValue.parse(comp);
                });
                
                switch(comps.length){
                    case 1: 
                        this.set(def.get(keyArgs, 'singleProp', 'all'), comps[0]);
                        return this;
                        
                    case 2:
                        this.set('x', comps[0]);
                        this.set('y', comps[1]);
                        return this;
                        
                    case 0:
                        return this;
                }
            } else if(typeof offset === 'number') {
                this.set(def.get(keyArgs, 'singleProp', 'all'), offset);
                return this;
            } else if (typeof offset === 'object') {
                this.set('all', offset.all);
                for(var p in offset){
                    if(p !== 'all'){
                        this.set(p, offset[p]);
                    }
                }
                return this;
            }
            
            if(pvc.debug) {
                pvc.log("Invalid 'offset' value: " + pvc.stringify(offset));
            }
            return this;
        },
        
        set: function(prop, value){
            if(value != null && def.hasOwn(pvc.Offset.namesSet, prop)){
                value = pvc.PercentValue.parse(value);
                if(value != null){
                    if(prop === 'all'){
                        // expand
                        pvc.Offset.names.forEach(function(p){
                            this[p] = value;
                        }, this);
                        
                    } else {
                        this[prop] = value;
                    }
                }
            }
        },
        
        resolve: function(refSize){
            var offset = {};
            
            pvc.Size.names.forEach(function(length){
                var offsetProp  = pvc.Offset.namesSizeToOffset[length];
                var offsetValue = this[offsetProp];
                if(offsetValue != null){
                    if(typeof(offsetValue) === 'number'){
                        offset[offsetProp] = offsetValue;
                    } else if(refSize){
                        var refLength = refSize[length];
                        if(refLength != null){
                            offset[offsetProp] = offsetValue.resolve(refLength);
                        }
                    }
                }
            }, this);
            
            return offset;
        }
    });
    
    pvc.Offset.names = ['x', 'y'];
    pvc.Offset.namesSet = pv.dict(pvc.Offset.names, def.retTrue);
    pvc.Offset.namesSizeToOffset = {width: 'x', height: 'y'};
    pvc.Offset.namesSidesToOffset = {left: 'x', right: 'x', top: 'y', bottom: 'y'};
    
    pvc.Offset.as = function(v){
        if(v != null && !(v instanceof Offset)){
            v = new Offset().setOffset(v);
        }
        
        return v;
    };
    
}()); // End private scope

/**
 * Implements support for svg detection
 */
(function($){
    /*global document:true */
    $.support.svg = $.support.svg || 
        document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
}(/*global jQuery:true */jQuery));

pvc.text = {
    getFitInfo: function(w, h, text, font, diagMargin){
        if(text === '') {
            return {h: true, v: true, d: true};
        }
        
        var len = pv.Text.measure(text, font).width;
        return {
            h: len <= w,
            v: len <= h,
            d: len <= Math.sqrt(w*w + h*h) - diagMargin
        };
    },

    trimToWidthB: function(len, text, font, trimTerminator, before){
        len -= pv.Text.measure(trimTerminator, font).width;
        
        return pvc.text.trimToWidth(len, text, font, trimTerminator, before);
    },
    
    trimToWidth: function(len, text, font, trimTerminator, before){
        if(text === '') {
            return text;
        }
  
        var textLen = pv.Text.measure(text, font).width;
        if(textLen <= len){
            return text;
        }
    
        if(textLen > len * 1.5){ //cutoff for using other algorithm
            return pvc.text.trimToWidthBin(len, text, font, trimTerminator, before);
        }
    
        while(textLen > len){
            text = before ? text.slice(1) : text.slice(0, text.length -1);
            textLen = pv.Text.measure(text, font).width;
        }
    
        return before ? (trimTerminator + text) : (text + trimTerminator);
    },
    
    trimToWidthBin: function(len, text, font, trimTerminator, before){

        var ilen = text.length,
            high = ilen - 2,
            low = 0,
            mid,
            textLen;

        while(low <= high && high > 0){

            mid = Math.ceil((low + high)/2);
            
            var textMid = before ? text.slice(ilen - mid) : text.slice(0, mid);
            textLen = pv.Text.measure(textMid, font).width;
            if(textLen > len){
                high = mid - 1;
            } else if(pv.Text.measure(before ? text.slice(ilen - mid - 1) : text.slice(0, mid + 1), font).width < len){
                low = mid + 1;
            } else {
                return before ? (trimTerminator + textMid) : (textMid + trimTerminator);
            }
    }
    
        return before ? (trimTerminator + text.slice(ilen - high)) : (text.slice(0, high) + trimTerminator);
    },
    
    justify: function(text, lineWidth, font){
        var lines = [];
        
        if(lineWidth < pv.Text.measure('a', font).width){
            // Not even one letter fits...
            return lines;
        } 
        
        var words = (text || '').split(/\s+/);
        
        var line = "";
        while(words.length){
            var word = words.shift();
            if(word){
                var nextLine = line ? (line + " " + word) : word;
                if(pv.Text.measure(nextLine, font).width > lineWidth){
                    // The word by itself may overflow the line width
                    
                    // Start new line
                    if(line){
                        lines.push(line);
                    }
                    
                    line = word;
                } else {
                    line = nextLine; 
                }
            }
        }
        
        if(line){
            lines.push(line);
        }
        
        return lines;
    },
    
    /* Returns a label's BBox relative to its anchor point */
    getLabelBBox: function(textWidth, textHeight, align, baseline, angle, margin){
            
        var polygon = pv.Label.getPolygon(textWidth, textHeight, align, baseline, angle, margin);
        
        var bbox             = polygon.bbox();
        bbox.source          = polygon;
        bbox.sourceAngle     = angle;
        bbox.sourceAlign     = align;
        bbox.sourceTextWidth = textWidth;
        
        return bbox;
    }
};

// Colors utility
def.scope(function(){
    
    pvc.color = {
        scale:  colorScale,
        scales: colorScales
    };
    
    // --------------------------
    // exported
    
    /**
     * Creates color scales of a specified type for datums grouped by a category.
     * 
     * @name pvc.color.scales
     * @function
     * @param {object} keyArgs Keyword arguments.
     * See {@link pvc.color.scale} for available arguments.
     * 
     * @param {def.Query} keyArgs.data
     * A {@link pvc.data.Data} that is the result of grouping datums along what are here called "category" dimensions.
     * <p>
     * One (possibly equal) color scale is returned per leaf data, indexed by the leaf's absolute key (see {@link pvc.data.Data#absKey}).  
     * </p>
     * @param {boolean} [keyArgs.normPerBaseCategory=false] Indicates that a different color scale should be computed per distinct data category.
     * 
     * @type function 
     */
    function colorScales(keyArgs){
        /*jshint expr:true */
        keyArgs || def.fail.argumentRequired('keyArgs');
        
        var type = keyArgs.type || def.fail.argumentRequired('keyArgs.type');
        
        switch (type) {
            case 'linear':   return new pvc.color.LinearScalesBuild(keyArgs).buildMap();
            case 'discrete': return new pvc.color.DiscreteScalesBuild(keyArgs).buildMap();
            case 'normal':   return new pvc.color.NormalScalesBuild(keyArgs).buildMap(); // TODO
        }
        
        throw def.error.argumentInvalid('scaleType', "Unexistent scale type '{0}'.", [type]);
    }
    
    /**
     * Creates a color scale of a specified type.
     * 
     * @name pvc.color.scale
     * @function
     * @param {object} keyArgs Keyword arguments.
     * See {@link pvc.color.scales} for available arguments.
     * 
     * @param {def.Query} keyArgs.data A {@link pvc.data.Data} instance that 
     * may be used to obtain the domain of the color scale.
     * 
     * @param {string} keyArgs.type The type of color scale.
     * <p>
     * Valid values are 'linear', 'discrete' and 'normal' (normal probability distribution).
     * </p>
     * @param {string|pv.color} [keyArgs.colorMin] The minimum color.
     * @param {string|pv.color} [keyArgs.colorMax] The maximum color.
     * @param {string|pv.color} [keyArgs.colorNull] The color shown for null values.
     * @param {(string|pv.color)[]} [keyArgs.colors] Array of colors.
     * <p>
     * This argument is ignored if both minimum and maximum colors are specified.
     * Otherwise, if only one of minimum or maximum is specified, it is prepended or appended to
     * the color range array, respectively.
     * </p>
     * <p>
     * When unspecified, the color range is assumed to be 'red', 'yellow' and 'green'. 
     * </p>
     * @param {string} keyArgs.colorDimension The name of the data dimension that is the <b>domain</b> of the color scale.
     * @param {object[]} [keyArgs.colorDomain] An array of domain values to match colors in the color range.
     * 
     * @type function 
     */
    function colorScale(keyArgs){
        /*jshint expr:true */
        keyArgs || def.fail.argumentRequired('keyArgs');
        
        var type = keyArgs.type || def.fail.argumentRequired('keyArgs.type');
        
        switch (type) {
            case 'linear':   return new pvc.color.LinearScalesBuild(keyArgs).build();
            case 'discrete': return new pvc.color.DiscreteScalesBuild(keyArgs).build();
            case 'normal':   return new pvc.color.NormalScalesBuild(keyArgs).build();
        }
        
        throw def.error.argumentInvalid('scaleType', "Unexistent scale type '{0}'.", [type]);
    }
    
    // --------------------------
    // private
    
    /**
     * @class Represents one creation/build of a set of scale functions.
     * @abstract
     */
    def
    .type('pvc.color.ScalesBuild')
    .init(function(keyArgs){
        this.keyArgs        = keyArgs;
        this.data           = keyArgs.data || def.fail.argumentRequired('keyArgs.data');
        this.domainDimName  = keyArgs.colorDimension || def.fail.argumentRequired('keyArgs.colorDimension');
        this.domainDim      = this.data.dimensions(this.domainDimName);
       
        var dimType = this.domainDim.type;
        if(!dimType.isComparable) {
            this.domainComparer = null;
            pvc.log("Color value dimension should be comparable. Generated color scale may be invalid.");
        } else {
            this.domainComparer = function(a, b){ return dimType.compare(a, b); };
        }
       
        this.nullRangeValue = keyArgs.colorNull ? pv.color(keyArgs.colorNull) : pv.Color.transparent;
       
        this.domainRangeCountDif = 0;
    })
    .add(/** @lends pvc.color.ScalesBuild# */{
       /**
        * Builds one scale function.
        * 
        * @type pv.Scale
        */
        build: function(){
            this.range = this._getRange();
            this.desiredDomainCount = this.range.length + this.domainRangeCountDif;
           
            var domain = this._getDomain();
            return this._createScale(domain);
        },
       
        /**
         * Builds a map from category keys to scale functions.
         * 
         * @type object
         */
        buildMap: function(){
            this.range = this._getRange();
            this.desiredDomainCount = this.range.length + this.domainRangeCountDif;
            
            var createCategoryScale;
            
            /* Compute a scale-function per data category? */
            if(this.keyArgs.normPerBaseCategory){
                /* Ignore args' domain and calculate from data of each category */
                createCategoryScale = function(leafData){
                    // Create a domain from leafData
                    var domain = this._ensureDomain(null, false, leafData);
                    return this._createScale(domain);
                };
            } else {
                var domain = this._getDomain(),
                    scale  = this._createScale(domain);
               
                createCategoryScale = def.fun.constant(scale);
            }
           
            return this._createCategoryScalesMap(createCategoryScale); 
        },
       
        _createScale: def.method({isAbstract: true}),
       
        _createCategoryScalesMap: function(createCategoryScale){
            return this.data.children()
                .object({
                    name:    function(leafData){ return leafData.absKey; },
                    value:   createCategoryScale,
                    context: this
                });
        },
       
        _getRange: function(){
            var keyArgs = this.keyArgs,
                range = keyArgs.colors || ['red', 'yellow','green'];
       
            if(keyArgs.colorMin != null && keyArgs.colorMax != null){
               
                range = [keyArgs.colorMin, keyArgs.colorMax];
               
            } else if (keyArgs.colorMin != null){
               
                range.unshift(keyArgs.colorMin);
               
            } else if (keyArgs.colorMax != null){
               
                range.push(keyArgs.colorMax);
            }
       
            return range.map(function(c) { return pv.color(c); });
        },
       
        _getDataExtent: function(data){
           
            var extent = data.dimensions(this.domainDimName).extent({visible: true});
            if(!extent) { // No atoms...
                return null;
            }
           
            var min = extent.min.value,
                max = extent.max.value;
            
            if(max == min){
                if(max >= 1){
                    min = max - 1;
                } else {
                    max = min + 1;
                }
            }
           
            return {min: min, max: max};
        },
       
        _getDomain: function() {
            var domain = this.keyArgs.colorDomain;
            if(domain != null){
                if(this.domainComparer) {
                    domain.sort(this.domainComparer);
                }
               
                if(domain.length > this.desiredDomainCount){ 
                    // More domain points than needed for supplied range
                    domain = domain.slice(0, this.desiredDomainCount);
                }
            } else {
                // This ends up being padded...in ensureDomain
                domain = [];
            }
           
            return this._ensureDomain(domain, true, this.data);
        },
       
        _ensureDomain: function(domain, doDomainPadding, data) {
            var extent;
           
            if(domain && doDomainPadding){
                /* 
                 * If domain does not have as many values as there are colors (taking domainRangeCountDif into account),
                 * it is *completed* with the extent calculated from data.
                 * (NOTE: getArgsDomain already truncates the domain to number of colors)
                 */
                var domainPointsMissing = this.desiredDomainCount - domain.length;
                if(domainPointsMissing > 0){ 
                    extent = this._getDataExtent(data);
                    if(extent){
                        // Assume domain is sorted
                        switch(domainPointsMissing){  // + 1 in discrete ?????
                            case 1:
                                if(this.domainComparer) {
                                    def.array.insert(domain, extent.max, this.domainComparer);
                                } else {
                                    domain.push(extent.max);
                                }
                                break;

                            case 2:
                                if(this.domainComparer) {
                                    def.array.insert(domain, extent.min, this.domainComparer);
                                    def.array.insert(domain, extent.max, this.domainComparer);
                                } else {
                                    domain.unshift(extent.min);
                                    domain.push(extent.max);
                                }
                                break;

                            default:
                                /* Ignore args domain altogether */
                                if(pvc.debug >= 2){
                                        pvc.log("Ignoring option 'colorDomain' due to unsupported length." +
                                                def.format(" Should have '{0}', but instead has '{1}'.", [this.desiredDomainCount, domain.length]));
                                }
                                domain = null;
                        }
                    }
               }
           }
           
           if(!domain) {
               /*jshint expr:true */
               extent || (extent = this._getDataExtent(data));
               if(extent){
                   var min = extent.min,
                       max = extent.max;
                   var step = (max - min) / (this.desiredDomainCount - 1);
                   domain = pv.range(min, max + step, step);
               }
           }
           
           return domain;
       }
   });
        
    
    def
    .type('pvc.color.LinearScalesBuild', pvc.color.ScalesBuild)
    .add(/** @lends pvc.color.LinearScalesBuild# */{
        
        _createScale: function(domain){
            var scale = pv.Scale.linear();

            if(domain){
                scale.domain.apply(scale, domain);
            }
            
            scale.range.apply(scale, this.range);
            
            return scale;
        }
    });
    
    def
    .type('pvc.color.DiscreteScalesBuild', pvc.color.ScalesBuild)
    .init(function(keyArgs){
        this.base(keyArgs);
        
        this.domainRangeCountDif = 1;
    })
    .add(/** @lends pvc.color.DiscreteScalesBuild# */{
        
        /*
         * Dmin   DMax    C
         * --------------------
         * -      <=d0    c0
         * >d0    <=d1    c1
         * >d1    <=d2    c2
         * ..
         * >dN-3  <=dN-2  cN-2
         * 
         * >dN-2  -       cN-1
         */
        //d0--cR0--d1--cR1--d2
        _createScale: function(domain){
            var Dl = domain.length - 1,
                range = this.range,
                nullRangeValue = this.nullRangeValue,
                Rl = range.length - 1;
            
            function scale(val){
                if(val == null) {
                    return nullRangeValue;
                }
                
                for(var i = 0 ; i < Dl ; i++){  // i <= D - 2  => domain[D-1]
                    if(val <= domain[i + 1]){
                        return range[i];
                    }
                }
                
                // > domain[Dl]
                return range[Rl];
            }
            
            // TODO: Not a real scale; 
            // some methods won't work on the result of by, by1 and transform.
            // Give it a bit of protovis looks
            def.copy(scale, pv.Scale.common);
            
            return scale;
        }
    });
    
    /* TODO */ 
      
    /***********
     * compute an array of fill-functions. Each column out of "colAbsValues" 
     * gets it's own scale function assigned to compute the color
     * for a value. Currently supported scales are:
     *    -  linear (from min to max
     *    -  normal distributed from   -numSD*sd to  numSD*sd 
     *         (where sd is the standard deviation)
     ********/
    /*
     getNormalColorScale: function (data, colAbsValues, origData){
    var fillColorScaleByColKey;
    var options = this.chart.options;
    if (options.normPerBaseCategory) {
      // compute the mean and standard-deviation for each column
      var myself = this;
      
      var mean = pv.dict(colAbsValues, function(f){
        return pv.mean(data, function(d){
          return myself.getValue(d[f]);
        })
      });
      
      var sd = pv.dict(colAbsValues, function(f){
        return pv.deviation(data, function(d){
          myself.getValue(d[f]);
        })
      });
      
      //  compute a scale-function for each column (each key)
      fillColorScaleByColKey = pv.dict(colAbsValues, function(f){
        return pv.Scale.linear()
          .domain(-options.numSD * sd[f] + mean[f],
                  options.numSD * sd[f] + mean[f])
          .range(options.colorMin, options.colorMax);
      });
      
    } else {   // normalize over the whole array
      
      var mean = 0.0, sd = 0.0, count = 0;
      for (var i=0; i<origData.length; i++)
        for(var j=0; j<origData[i].length; j++)
          if (origData[i][j] != null){
            mean += origData[i][j];
            count++;
          }
      mean /= count;
      for (var i=0; i<origData.length; i++){
        for(var j=0; j<origData[i].length; j++){
          if (origData[i][j] != null){
            var variance = origData[i][j] - mean;
            sd += variance*variance;
          }
        }
      }
      
      sd /= count;
      sd = Math.sqrt(sd);
      
      var scale = pv.Scale.linear()
        .domain(-options.numSD * sd + mean,
                options.numSD * sd + mean)
        .range(options.colorMin, options.colorMax);
      
      fillColorScaleByColKey = pv.dict(colAbsValues, function(f){
        return scale;
      });
    }

    return fillColorScaleByColKey;  // run an array of values to compute the colors per column
}      
     */
    
    /* 
     *          r0   ]   r1 ]    r2   ]           rD-2  ] (rD-1)
     * ... --+-------+------+---------+-- ... -+--------+------->
     *       d0      d1     d2        d3       dD-2    dD-1   (linear)
     * 
     * 
     * Mode 1 - Domain divider points
     * 
     * User specifies:
     * # D domain divider points
     * # R = D+1 range points
     * 
     * ////////////////////////////
     * D=0, R=1
     *
     *   r0
     *   ...
     *
     *
     * ////////////////////////////
     * D=1, R=2
     *
     *   r0  ]  r1
     * ... --+-- ...
     *       d0
     *
     *
     * ////////////////////////////
     * D=2, R=3
     *
     *   r0  ]  r1  ]  r2
     * ... --+------+-- ...
     *       d0     d1
     *
     *
     * ////////////////////////////
     * D=3, R=4
     * 
     *   r0  ]  r1  ]  r2  ]  r3
     * ... --+------+------+-- ...
     *       d0     d1     d2
     * 
     * ...
     * 
     * Mode 2 - Domain dividers determination from data extent
     * 
     * //////////////////////////// (inf. = sup.)
     * Special case
     * Only one color is used (the first one, for example)
     * 
     *   r0
     *   
     * //////////////////////////// (inf. < sup.)
     * C=1  => constant color
     * 
     *       r0
     *   +--------+
     *   I        S
     * 
     * ////////////////////////////
     * C=2  =>  N=1 (1 divider point)
     * 
     * B = (S-I)/2
     * 
     *       C0   ]   C1
     *   +--------+--------+
     *   I        d0        S
     *       B         B
     * 
     * ////////////////////////////
     * C=3  =>  N=2 (2 divider points)
     * 
     * B = (S-I)/3
     * 
     *      C0    ]   C1   ]   C2
     *   +--------+--------+--------+
     *   I        d0       d1       S
     *       B        B        B
     *
     * ...
     * 
     */
});def.space('pvc.trends', function(trends){
    var _trends = {};
    
    def.set(trends, 
        'define', function(type, trendSpec){
            /*jshint expr:true*/
            
            type      || def.fail.argumentRequired('type');
            trendSpec || def.fail.argumentRequired('trendSpec');
            def.object.is(trendSpec) || def.fail.argumentInvalid('trendSpec', "Must be a trend specification object.");
            
            if(pvc.debug >= 2 && def.hasOwn(_trends, type)){
                pvc.log(def.format("[WARNING] A trend type with the name '{0}' is already defined.", [type]));
            }
            
            var label = trendSpec.label || def.fail.argumentRequired('trendSpec.label');
            var model = trendSpec.model || def.fail.argumentRequired('trendSpec.model');
            def.fun.is(model) || def.fail.argumentInvalid('trendSpec.mode', "Must be a function.");
            
            var trendInfo = {
               dataPartAtom: {v: 'trend', f: label},
               type:  type,
               label: label,
               model: model
            };
            
            _trends[type] = trendInfo;
        },
        
        'get', function(type){
            /*jshint expr:true*/
            type || def.fail.argumentRequired('type');
            return def.getOwn(_trends, type) ||
                def.fail.operationInvalid("Undefined trend type '{0}'.", [type]);
        },
        
        'has', function(type){
            return def.hasOwn(_trends, type);
        },
        
        'types', function(){
            return def.ownKeys(_trends);
        });
    
    
    trends.define('linear', {
        label: 'Linear trend',
        model: function(options){
            var rows = def.get(options, 'rows'); 
            var funX = def.get(options, 'x');
            var funY = def.get(options, 'y');
            
            var i = 0;
            var N = 0;
            var sumX  = 0;
            var sumY  = 0;
            var sumXY = 0;
            var sumXX = 0;
            var parseNum = function(value){
                return value != null ? (+value) : NaN;  // to Number works for dates as well
            };
            
            while(rows.next()){
                var row = rows.item;
                
                // Ignore null && NaN values
                
                var x = funX ? parseNum(funX(row)) : i; // use the index itself for discrete stuff
                if(!isNaN(x)){
                    var y = parseNum(funY(row));
                    if(!isNaN(y)){
                        N++;
                        
                        sumX  += x;
                        sumY  += y;
                        sumXY += x * y;
                        sumXX += x * x;
                    }
                }
                
                i++; // Discrete nulls must still increment the index
            }
            
            // y = alpha + beta * x
            var alpha, beta;
            if(N >= 2){
                var avgX  = sumX  / N;
                var avgY  = sumY  / N;
                var avgXY = sumXY / N;
                var avgXX = sumXX / N;
            
                // When N === 1 => den = 0
                var den = (avgXX - avgX * avgX);
                if(den === 0){
                    beta = 0;
                } else {
                    beta = (avgXY - (avgX * avgY)) / den;
                }
                
                alpha = avgY - beta * avgX;
                
                return {
                    alpha: alpha,
                    beta:  beta,
                    
                    reset: def.noop,
                    
                    // y = alpha + beta * x
                    sample: function(x/*, y, i*/){
                        return alpha + beta * (+x);
                    }
                };
            }
        }
    });
    
    // Source: http://en.wikipedia.org/wiki/Moving_average
    trends.define('moving-average', {
        label: 'Moving average',
        model: function(options){
            var W = Math.max(+(def.get(options, 'periods') || 3), 2);
              
            var sum = 0; // Current sum of values in avgValues
            var avgValues = []; // Values in the average window
            
            return {
                reset: function(){
                    sum = 0;
                    avgValues.length = 0;
                },
                
                sample: function(x, y, i){
                    // Only y is relevant for this trend type
                    var L = W;
                    if(y != null){
                        avgValues.unshift(y);
                        sum += y;
                        
                        L = avgValues.length;
                        if(L > W){
                            sum -= avgValues.pop();
                            L = W;
                        }
                    }
                    
                    return sum / L;
                }
            };
        }
    });
    
    // Source: http://en.wikipedia.org/wiki/Moving_average
    trends.define('weighted-moving-average', {
        label: 'Weighted Moving average',
        model: function(options){
            var W = Math.max(+(def.get(options, 'periods') || 3), 2);
            
            // Current sum of values in the window
            var sum = 0; // Current sum of values in avgValues
            
            // Current numerator
            var numer = 0;
            
            var avgValues = []; // Values in the average window
            var L = 0;
            
            // Constant Denominator (from L = W onward it is constant)
            // W +  (W - 1) + ... + 2 + 1
            // = W * (W + 1) / 2;
            var denom = 0;
            
            return {
                reset: function(){
                    sum = numer = denom = L = 0;
                    avgValues.length = 0;
                },
                
                sample: function(x, y/*, i*/){
                    // Only y is relevant for this trend type
                    if(y != null){
                        
                        if(L < W){
                            // Still filling the avgValues array
                            
                            avgValues.push(y);
                            L++;
                            denom += L;
                            numer += L * y;
                            sum   += y;
                        } else {
                            // denom is now equal to: W * (W + 1) / 2; 
                            numer += (L * y) - sum;
                            sum   += y - avgValues[0]; // newest - oldest
                            
                            // Shift avgValues left
                            for(var j = 1 ; j < W ; j++){
                                avgValues[j - 1] = avgValues[j];
                            }
                            avgValues[W - 1] = y;
                        }
                    }
                    
                    return numer / denom;
                }
            };
        }
    });
});
// Options management utility
def.scope(function(){
    /**
     * Creates an options manager given an options specification object,
     * and, optionally, a corresponding context object.
     * 
     * @name pvc.options
     * @class An options manager.
     * @example
     * <pre>
     * var foo = {};
     * 
     * foo.options = pvc.options({
     *         Name: {
     *             alias: 'legendName',
     *             cast:  String,
     *             value: 'John Doe',
     *             resolve: function(context){
     *                 this.setDefault();
     *             }
     *         }
     *     }, foo);
     *     
     * foo.options.specify({
     *    'legendName': "Fritz"
     * });
     * 
     * foo.options('Name2'); // -> "Fritz"
     * </pre>
     * 
     * @constructor
     * @param {object} specs An object whose properties, owned or inherited,
     * have the name of an option to define, and whose values are option
     * specification objects, each having the following <i>optional</i> properties:
     * <ul>
     * <li>resolve - 
     * a method that allows to apply custom value resolution logic for an option.
     * 
     * It is called 
     * on the {@link pvc.options.Info} instance with the 
     * previously specified context object as argument. 
     * </li>
     * <li>cast  - a cast function, called to normalize the value of an option</li>
     * <li>value - the default value of the property, considered already cast</li>
     * </li>
     * </ul>
     * 
     * @param {object} [context=null] Optional context object on which to call
     * the 'resolve' function specified in {@link specs}.
     * 
     * @type function
     */
    function options(specs, context){
        /*jshint expr:true */
        specs || def.fail.argumentRequired('specs');
        
        var _infos = {};
        
        def.each(specs, function(spec, name){
            var info = new OptionInfo(name, option, context, spec);
            _infos[info.name] = info;
        });
        
        /** @private */
        function resolve(name){
            var info = def.getOwn(_infos, name) || 
                       def.fail.operationInvalid("Undefined option '{0}'", [name]);
            
            return info.resolve();
        }
        
        /**
         * Obtains the value of an option given its name.
         * <p>
         * If a value for the option hasn't been provided
         * a default value is returned, 
         * from the option specification.
         * </p>
         * @name pvc.options#option
         * @function
         * @param {string} name The name of the option.
         * @param {booleam} [noDefault=false] Prevents returning a default value.
         * If a value for the option hasn't been provided, undefined is returned.
         * 
         *  @type any
         */
        function option(name, noDefault){
            var info = resolve(name);
            return noDefault && !info.isSpecified ? undefined : info.value;
        }
        
        /**
         * Indicates if a value for a given option has been specified.
         * @name pvc.options#isSpecified
         * @function
         * @param {string} name The name of the option.
         * @type boolean
         */
        function isSpecified(name){
            return resolve(name).isSpecified;
        }
        
        /**
         * Obtains the value of an option given its name,
         * but only if it has been specified (not defaulted).
         * <p>
         * This is a convenience method for calling {@link #option}
         * with the <tt>noDefault</tt> argument with the value <tt>true</tt>.
         * </p>
         * 
         * @name pvc.options#specified
         * @function
         * @param {string} name The name of the option.
         * 
         * @type any
         */
        function specified(name){
            return option(name, /*noDefault*/ true);
        }
        
        /**
         * Indicates if an option with the given name is defined.
         * @name pvc.options#isDefined
         * @function
         * @param {string} name The name of the option.
         * @type boolean
         */
        function isDefined(name){
            return def.hasOwn(_infos, name);
        }
        
        /**
         * Specifies options' values given an object
         * with properties as option names
         * and values as option values.
         * <p>
         * Only properties whose name is the name of a defined option 
         * are taken into account.
         * </p>
         * <p>
         * Every property, own or inherited, is considered, 
         * as long as its value is not <c>undefined</c>.
         * </p>
         * @name pvc.options#specify
         * @function
         * @param {object} [opts] An object with option values
         * @returns {function} The options manager. 
         */
        function specify(opts){
            return set(opts, false);
        }
        
        /**
         * Sets options' default values.
         * @name pvc.options#defaults
         * @function
         * @param {object} [opts] An object with option default values
         * @returns {function} The options manager.
         * @see #specify
         */
        function defaults(opts){
            return set(opts, true);
        }
        
        /**
         * Obtains the default value of an option, given its name.
         * <p>
         * If a property has no default value, <c>undefined</c> is returned.
         * </p>
         * @name pvc.options#defaultValue
         * @function
         * @param {string} name The name of the option.
         */
        function getDefaultValue(name){
            return resolve(name)._defaultValue;
        }
        
        /** @private */
        function set(opts, isDefault){
            for(var name in opts){
                var info = def.getOwn(_infos, name);
                if(info){
                    var value = opts[name];
                    if(value !== undefined){
                        info.set(value, isDefault);
                    }
                }
            }
            
            return option;
        }
        
        // ------------
        
        option.option = option;
        option.specified   = specified; 
        option.isSpecified = isSpecified;
        option.isDefined   = isDefined;
        
        option.defaultValue = getDefaultValue;
        
        option.specify  = specify;
        option.defaults = defaults;
        
        return option;
    }
    
    // ------------
     
    // Creates a resolve method, 
    // that combines a list of resolvers. 
    // The resolve stops when the first resolver returns the value <c>true</c>,
    // returning <c>true</c> as well.
    function resolvers(list){
        return function(optionInfo){
            for(var i = 0, L = list.length ; i < L ; i++){
                var m = list[i];
                
                if(def.string.is(m)){
                    m = this[m];
                } 
                
                if(m.call(this, optionInfo) === true){
                    return true;
                }
            }
        };
    }
    
    function constantResolver(value, op){
        return function(optionInfo){
            optionInfo.specify(value);
            return true;
        };
    }
    
    function specifyResolver(fun, op){
        return function(optionInfo){
            var value = fun.call(this, optionInfo);
            if(value !== undefined){
                optionInfo.specify(value);
                return true;
            }
        };
    }
    
    function defaultResolver(fun){
        return function(optionInfo){
            var value = fun.call(this, optionInfo);
            if(value !== undefined){
                optionInfo.defaultValue(value);
                return true;
            }
        };
    }
    
    options.resolvers    = resolvers;
    options.constant     = constantResolver;
    options.specify      = specifyResolver;
    options.defaultValue = defaultResolver;
    
    // ------------
    
    pvc.options = options;
    
    // ------------
    
    /**
     * @name pvc.options.Info
     * @class An option in an options manager. 
     */
    var OptionInfo = def.type()
    .init(function(name, option, context, spec){
        this.name = name;
        
        this._context = context;
        this.option = option;
        
        this._cast = def.get(spec, 'cast');
        
        // Assumed already cast
        // May be undefined
        var value = def.get(spec, 'value');
        if(value !== undefined){
            this._defaultValue = this.value = value;
        }
        
        this.resolveCore = def.get(spec, 'resolve');
        if(!this.resolveCore){
            this.isResolved = true;
        }
        
        var getDefault = def.get(spec, 'getDefault');
        if(getDefault){
            this._getDefault = getDefault;
        }
        
        var data = def.get(spec, 'data');
        if(data != null){
            this.data = data;
        }
        
        // --------
        // Can be used by resolvers...
        this.alias = def.array.to(def.get(spec, 'alias'));
    })
    .add( /** @lends pvc.options.Info#  */{
        isSpecified: false,
        isResolved: false,
        value: undefined,
        
        /** @private */
        _defaultValue: undefined,
        
        /**
         * Resolves an option if it is not yet resolved.
         * @type pvc.options.Info
         */
        resolve: function(){
            if(!this.isResolved){
                // In case of re-entry, the initial default value is obtained.
                this.isResolved = true;
                
                var resolve = this._getFunProp('resolveCore');
                
                // Must call set, specify or defaultValue
                // Or the current default value becomes the value.
                resolve.call(this._context, this);
                
                if(this.value == null){
                    var getDefault = this._getFunProp('_getDefault');
                    if(getDefault){
                        var value = this.cast(getDefault.call(this._context, this));
                        if(value != null){
                            delete this.isSpecified;
                            this.value = this._defaultValue = value;
                        }
                    }
                }
            }
            
            return this;
        },
        
        /**
         * Specifies the value of the option.
         * 
         * @param {any} value the option value.
         * @type pvc.options.Info
         */
        specify: function(value){
            return this.set(value, false);
        },
        
        /**
         * Gets, and optionally sets, the default value.
         * @param {any} [value=undefined] the option default value.
         * @type any
         */
        defaultValue: function(defaultValue){
            if(defaultValue !== undefined){
                this.set(defaultValue, true);
            }
            
            return this._defaultValue;
        },
        
        cast: function(value){
            if(value != null){
                var cast = this._getFunProp('_cast');
                if(cast){
                    value = cast.call(this._context, value, this);
                }
            }
            return value;
        },
        
        dynDefault: function(){
            var dynDefault = this._getFunProp('_dynDefault');
            if(dynDefault){
                return this.cast(dynDefault.call(this._context, this));
            }
        },
        
        /**
         * Sets the option's value or default value.
         * 
         * @param {any} [value=undefined] the option value or default value.
         * @param {boolean} [isDefault=false] indicates if the operation sets the default value.
         * 
         * @type pvc.options.Info
         */
        set: function(value, isDefault){
            if(value != null){
                value = this.cast(value);
            }
            
            if(value == null){
                value = this.dynDefault();
                if(value != null){
                    isDefault = true;
                }
            }
            
            if(!isDefault){
                this.isSpecified = true;
                this.isResolved  = true;
                this.value = value;
            } else {
                this._defaultValue = value;
                
                // Don't touch an already specified value
                if(!this.isSpecified){
                    this.value = value;
                }
            }
            
            return this;
        },

        _getFunProp: function(name){
            var fun = this[name];
            if(fun){
                var context = this._context;
                if(context && def.string.is(fun)){
                    fun = context[fun];
                }
            }
            return fun;
        }
    });
});/**
 * Namespace with data related classes.
 * @name pvc.data
 * @namespace
 */

/**
 * @name NoDataException
 * @class An error thrown when a chart has no data.
 */
def.global.NoDataException = function(){};


pvc.data = {
    visibleKeyArgs: {visible: true}
};

/**
 * Disposes a list of child objects.
 * 
 * @name pvc.data._disposeChildList
 * 
 * @param {Array} list The list with children to dispose.
 * @param {string} [parentProp] The child's parent property to reset.
 * 
 * @static
 * @private
 */
function data_disposeChildList(list, parentProp) {
    if(list){
        list.forEach(function(child){
            if(parentProp) {
                child[parentProp] = null; // HACK: to avoid child removing itself from its parent (this)
            }
            
            child.dispose(); 
        });
        
        list.length = 0;
    }
}

/**
 * Adds a child object.
 * 
 * @name pvc.data._addColChild
 * 
 * @param {object} parent The parent.
 * @param {string} childrenProp A parent's children array property.
 * @param {object} child The child to add.
 * @param {string} parentProp The child's parent property to set.
 * @param {number} [index=null] The index at which to insert the child.
 * 
 * @static
 * @private
 */
function data_addColChild(parent, childrenProp, child, parentProp, index) {
    // <Debug>
    /*jshint expr:true */
    (child && !child[parentProp]) || def.assert("Must not have a '" + parentProp + "'.");
    // </Debug>
    
    child[parentProp] = parent;
    
    var col = (parent[childrenProp] || (parent[childrenProp] = []));
    if(index == null || index >= col.length){
        col.push(child);
    } else {
        col.splice(index, 0, child);
    }
}

/**
 * Removes a child object.
 * 
 * @name pvc.data._removeColChild
 * 
 * @param {object} parent The parent.
 * @param {string} childrenProp A parent's children array property.
 * @param {object} child The child to remove.
 * @param {string} parentProp The child's parent property to reset.
 * 
 * @static
 * @private
 */
function data_removeColChild(parent, childrenProp, child, parentProp) {
    // <Debug>
    /*jshint expr:true */
    (child && (!child[parentProp] || child[parentProp] === parent)) || def.assert("Not a child");
    // </Debug>
    
    var children = parent[childrenProp];
    if(children) {
        var index = children.indexOf(child);
        if(index >= 0){
            def.array.removeAt(children, index);
        }
    }
    
    child[parentProp] = null;
}
/**
 * Initializes a dimension type
 * 
 * @name pvc.data.DimensionType
 * 
 * @class A dimension type describes a dimension of a complex type.
 * <p>
 * Most of the held information is of 
 * intrinsic characteristics of the dimensions values.
 * Yet, it also holds information 
 * related to a specific data translation usage.
 * </p>
 *
 * @property {pvc.data.ComplexType} complexType
 * The complex type that this dimension type belongs to.
 * 
 * @property {string} name
 * The name of this dimension type.
 * The name of a dimension type is unique on its complex type.
 * 
 * @property {string} label
 * The label of this dimension type.
 * The label <i>should</i> be unique on its complex type.
 * 
 * @property {string} group The group that the dimension type belongs to.
 * <p>
 * The group name is taken to be the name of the dimension
 * without any suffix numbers. 
 * So, if the name of a dimension type is 'series2',
 * then its default group is 'series'.
 * </p>
 *
 * @property {number} groupLevel The index within the group that the dimension type belongs to.
 *
 * @property {Function} valueType
 * The type of the value of atoms belonging to dimensions of this type.
 * It is a function that casts values to the represented type.
 * 
 * The values null and undefined are never converted by this function.
 * 
 * The function must be idempotent.
 *
 * @property {string} valueTypeName A description of the value type.
 * 
 * @property {boolean} isDiscrete
 * Indicates if the values of this dimension are 
 * to be considered discrete,
 * as opposed to continuous,
 * even if the value type is continuous.
 *
 * @property {boolean} isDiscreteValueType
 * Indicates if the value type of the values of this dimension are discrete,
 * as opposed to continuous.
 *
 * @property {boolean} isComparable
 * Indicates if the values of this dimension can be compared.
 * 
 * @property {boolean} isHidden Indicates if the dimension is
 * hidden from the user, in places like a tooltip, for example, or in the legend.
 * 
 * @property {def.Map} playedVisualRoles
 * A map of {@link pvc.visual.Role} indexed by visual role name, of the visual roles currently being played by this dimension type.
 * 
 * @constructor
 *
 * @param {pvc.data.ComplexType} complexType The complex type that this dimension belongs to.
 * @param {string} name The name of the dimension type.
 *
 * @param {object} [keyArgs] Keyword arguments.
 * @param {string} [keyArgs.label] The label of this dimension type.
 * Defaults to the name of the dimension type.
 * @param {function} [keyArgs.valueType=null] The type of the values of this dimension type.
 * <p>
 * The supported value types are: <i>null</i> (which really means <i>any</i>), {@link Boolean}, {@link Number}, {@link String}, {@link Date} and {@link Object}.
 * </p>
 * @param {boolean} [keyArgs.isHidden=false] Indicates if the dimension should
 * be hidden from the user, in places like a tooltip, for example, or in the legend.
 * @param {boolean} [keyArgs.isDiscrete]
 * Indicates if the dimension
 * is considered discrete.
 * The default value depends on the value of {@link valueType};
 * it is true unless the {@link valueType} is Number or Date.
 * 
 * @param {function} [keyArgs.converter] A function used in the translation phase
 * to convert raw values into values of the dimension's value type.
 * Its signature is:
 * <pre>
 * function(rawValue : any) : valueType
 * </pre>
 * 
 * @param {string} [keyArgs.rawFormat] A protovis format mask adequate to the specified value type.
 * When specified and a converter is not specified, it is used to create a converter
 * for the Date and Number value types.
 * 
 * @param {function} [keyArgs.key] A function used in the translation phase
 * to obtain the string key of each value.
 * Its signature is:
 * <pre>
 * function(value : valueType) : string
 * </pre>
 * <p>
 * Nully values have a fixed key of '', 
 * so to the function never receives a "nully" value argument.
 * A consequence is that no other values can have an empty key.
 * </p>
 * <p>
 * The default key is obtained by calling the value's {@link Object#toString} method.
 * </p>
 * 
 * @param {function} [keyArgs.formatter] A function used in the translation phase
 * to format the values of this dimension type.
 * Its signature is:
 * <pre>
 * function(value : valueType, rawValue : any) : string
 * </pre>
 * <p>
 * Only a "nully" value <i>should</i> have an empty label.
 * </p>
 * <p>
 * The label is not necessarily unique.
 * </p>
 * <p>
 * The default format is the empty string for null values, 
 * or the result of calling the <i>value</i>'s {@link Object#toString} method.
 * </p>
 * 
 * @param {string} [keyArgs.format] A protovis format mask adequate to the specified value type.
 * When specified and a formatter is not specified, it is used to create a formatter
 * for the Date and Number value types.
 *
 * @param {function} [keyArgs.comparer]
 * Specifies a comparator function for the values of this dimension type.
 * Its signature is:
 * <pre>
 * function(valueA : valueType, valueB : valueType) : number
 * </pre>
 * 
 * The default value depends on the value of {@link valueType};
 * it is {@link def.compare} when the {@link valueType} is Date,
 * and null otherwise.
 */

/**
 * Cache of reverse order context-free value comparer function.
 * 
 * @name pvc.data.DimensionType#_reverseComparer
 * @field
 * @type function
 * @private
 */

/**
 * Cache of reverse order context-free atom comparer function.
 * 
 * @name pvc.data.DimensionType#_reverseAtomComparer
 * @field
 * @type function
 * @private
 */

/**
 * Cache of normal order context-free value comparer function.
 * 
 * @name pvc.data.DimensionType#_directComparer
 * @field
 * @type function
 * @private
 */

/**
 * Cache of normal order context-free atom comparer function.
 * 
 * @name pvc.data.DimensionType#_directAtomComparer
 * @field
 * @type function
 * @private
 */
def.type('pvc.data.DimensionType')
.init(
function(complexType, name, keyArgs){
    this.complexType = complexType;
    this.name  = name;
    this.label = def.get(keyArgs, 'label') || pvc.buildTitleFromName(name);

    var groupAndLevel = pvc.splitIndexedId(name);
    this.group = groupAndLevel[0];
    this.groupLevel = def.nullyTo(groupAndLevel[1], 0);

    if(this.label.indexOf('{') >= 0){
        this.label = def.format(this.label, [this.groupLevel+1]);
    }

    this.playedVisualRoles = new def.Map();
    this.isHidden = !!def.get(keyArgs, 'isHidden');
    
    var valueType = def.get(keyArgs, 'valueType') || null;
    var valueTypeName = pvc.data.DimensionType.valueTypeName(valueType);
    var cast = def.getOwn(pvc.data.DimensionType.cast, valueTypeName, null);
    
    this.valueType = valueType;
    this.valueTypeName = valueTypeName;
    this.cast = cast;
    
    this.isDiscreteValueType = (this.valueType !== Number && this.valueType !== Date);
    this.isDiscrete = def.get(keyArgs, 'isDiscrete');
    if(this.isDiscrete == null){
        this.isDiscrete = this.isDiscreteValueType;
    } else {
        // Normalize the value
        this.isDiscrete = !!this.isDiscrete;
        if(!this.isDiscrete && this.isDiscreteValueType) {
            throw def.error.argumentInvalid('isDiscrete', "The only supported continuous value types are Number and Date.");
        }
    }
    
    /** 
     * @private
     * @internal
     * @see pvc.data.Dimension#convert
     */
    this._converter = def.get(keyArgs, 'converter') || null;
    if(!this._converter) {
        var rawFormat = def.get(keyArgs, 'rawFormat');
        if(rawFormat) {
            /*jshint onecase:true */
            switch(this.valueType) {
//                case Number:
//                    // TODO: receive extra format configuration arguments
//                    // this._converter = pv.Format.createParser(pv.Format.number().fractionDigits(0, 2));
//                    break;
                    
                case Date:
                    this._converter = pv.Format.createParser(pv.Format.date(rawFormat));
                    break;
            }
        }
    }
    
    /** 
     * @private
     * @internal
     * @see pvc.data.Dimension#key
     */
    this._key = def.get(keyArgs, 'key') || null;
    
    /** @private */
    this._comparer = def.get(keyArgs, 'comparer');
    if(this._comparer === undefined){ // It is possible to prevent the default specifying null
        switch(this.valueType){
            case Number:
            case Date:
                this._comparer = def.compare;
                break;
                
            default:
                 this._comparer = null;
        }
    }

    this.isComparable = this._comparer != null;
    
    /** 
     * @private
     * @internal
     * @see pvc.data.Dimension#format
     */
    this._formatter = def.get(keyArgs, 'formatter') || null;
    if(!this._formatter) {
        switch(this.valueType) {
            case Number:
                // TODO: receive extra format configuration arguments
                this._formatter = pv.Format.createFormatter(pv.Format.number().fractionDigits(0, 2));
                break;
                
            case Date:
                var format = def.get(keyArgs, 'format'); 
                if(!format){
                    // Try to create one from raw format
                    // slightly modifying it to look like 
                    // protovis' continuous date scale dynamic formats
                    format = def.get(keyArgs, 'rawFormat');
                    if(format){
                        format = format.replace(/-/g, "/");
                    }
                }
                
                if(!format){
                    format = "%Y/%m/%d";
                }
                
                this._formatter = pv.Format.createFormatter(pv.Format.date(format));
                break;
        }
    }
})
.add(/** @lends pvc.data.DimensionType# */{
    
    isCalculated: false,
    
    /**
     * Compares two values of the dimension's {@link #valueType}, in ascending order.
     * <p>
     * To compare two values in descending order multiply the result by -1.
     * </p>
     * <p>
     * Values can be nully.
     * </p>
     * @param {any} a A value of the dimension's {@link #valueType}.
     * @param {any} b A value of the dimension's {@link #valueType}.
     *  
     * @returns {Number}
     * A negative number if {@link a} is before {@link b},
     * a positive number if {@link a} is after {@link b},
     * and 0 if they are considered to have the same order.
     */
    compare: function(a, b){
        if(a == null) {
            if(b == null) {
                return 0;
            }
            return -1;
        } else if(b == null) {
            return 1;
        }
        
        return this._comparer.call(null, a, b);
    },
    
    /**
     * Gets a context-free comparer function 
     * for values of the dimension's {@link #valueType}
     * and for a specified order.
     * 
     * <p>When the dimension type is not comparable, <tt>null</tt> is returned.</p>
     * 
     * @param {boolean} [reverse=false] Indicates if the comparison order should be reversed.
     * 
     * @type function
     */
    comparer: function(reverse){
        if(!this.isComparable) {
            return null;
        }
        
        var me = this;
        if(reverse){
            return this._reverseComparer || 
                   (this._reverseComparer = function(a, b){ return me.compare(b, a); }); 
        }
        
        return this._directComparer || (this._directComparer = function(a, b){ return me.compare(a, b); }); 
    },
    
    /**
     * Gets a context-free atom comparer function, 
     * for a specified order.
     * 
     * @param {boolean} [reverse=false] Indicates if the comparison order should be reversed.
     * 
     * @type function
     */
    atomComparer: function(reverse){
        if(reverse){
            return this._reverseAtomComparer || 
                   (this._reverseAtomComparer = this._createReverseAtomComparer()); 
        }
        
        return this._directAtomComparer ||
                (this._directAtomComparer = this._createDirectAtomComparer());
    },
    
    // Coercion to discrete upon the role binding (irreversible...)
    _toDiscrete: function(){
        this.isDiscrete = true;
    },
    
    _toCalculated: function(){
        this.isCalculated = true;
    },
    
    _createReverseAtomComparer: function(){
        if(!this.isComparable){
            /*global atom_idComparerReverse:true */
            return atom_idComparerReverse;
        }
        
        var me = this;
        
        function reverseAtomComparer(a, b){
            if(a === b) { return 0; } // Same atom
            return me.compare(b.value, a.value); 
        }
        
        return reverseAtomComparer;
    },
    
    _createDirectAtomComparer: function(){
        if(!this.isComparable){
            /*global atom_idComparer:true */
            return atom_idComparer;
        }
        
        var me = this;
        
        function directAtomComparer(a, b){
            if(a === b) { return 0; } // Same atom
            return me.compare(a.value, b.value);
        }
        
        return directAtomComparer;
    },
    
    /**
     * Gets the dimension type's context-free formatter function, if one is defined, or <tt>null</tt> otherwise.
     * @type function
     */
    formatter: function(){
        return this._formatter;
    },
    
    /**
     * Gets the dimension type's context-free converter function, if one is defined, or <tt>null</tt> otherwise.
     * @type function
     */
    converter: function(){
        return this._converter;
    },
    
    /**
     * Obtains a value indicating if this dimension type plays any visual role 
     * such that {@link pvc.visual.Role#isPercent} is <tt>true</tt>.
     * @type boolean
     */
    playingPercentVisualRole: function(){
        return def.query(this.playedVisualRoles.values())
                  .any(function(visualRole){ 
                      return visualRole.isPercent; 
                  }); 
    }
});

pvc.data.DimensionType.cast = {
    'Date': function(value) {
        return value instanceof Date ? value : new Date(value);
    },

    'Number': function(value) {
        value = Number(value);
        return isNaN(value) ? null : value;
    },

    'String':  String,
    'Boolean': Boolean,
    'Object':  Object,
    'Any':     null
};

/**
 * Obtains the default group name for a given dimension name.
 * 
 * @param {string} dimName The dimension name.
 * 
 *  @type string
 */
pvc.data.DimensionType.dimensionGroupName = function(dimName){
    return dimName.replace(/^(.*?)(\d*)$/, "$1");
};

// TODO: Docs
pvc.data.DimensionType.valueTypeName = function(valueType){
    if(valueType == null){
        return "Any";
    }
    
    switch(valueType){
        case Boolean: return 'Boolean';
        case Number:  return 'Number';
        case String:  return 'String';
        case Object:  return 'Object';
        case Date:    return 'Date';
        default: throw def.error.argumentInvalid('valueType', "Invalid valueType function: '{0}'.", [valueType]);
    }
};

/**
 * Extends a dimension type specification with defaults based on
 * group name and specified options.
 *  
 * @param {object} [keyArgs] Keyword arguments.
 * @param {function} [keyArgs.isCategoryTimeSeries=false] Indicates if category dimensions are to be considered time series.
 * @param {string} [keyArgs.timeSeriesFormat] The parsing format to use to parse a Date dimension when the converter and rawFormat options are not specified.
 * @param {function} [keyArgs.valueNumberFormatter] The formatter to use to parse a numeric dimension of the 'value' dimension group, when the formatter and format options are not specified.
 * @param {object} [keyArgs.dimensionGroups] A map of dimension group names to dimension type specifications to be used as prototypes of corresponding dimensions.
 * 
 *  @returns {object} The extended dimension type specification.
 */
pvc.data.DimensionType.extendSpec = function(dimName, dimSpec, keyArgs){
    
    var dimGroup = pvc.data.DimensionType.dimensionGroupName(dimName),
        userDimGroupsSpec = def.get(keyArgs, 'dimensionGroups');
    
    if(userDimGroupsSpec) {
        var groupDimSpec = userDimGroupsSpec[dimGroup];
        if(groupDimSpec) {
            dimSpec = def.create(groupDimSpec, dimSpec /* Can be null */); 
        }
    }
    
    if(!dimSpec) { 
        dimSpec = {};
    }
    
    switch(dimGroup) {
        case 'category':
            var isCategoryTimeSeries = def.get(keyArgs, 'isCategoryTimeSeries', false);
            if(isCategoryTimeSeries) {
                if(dimSpec.valueType === undefined) {
                    dimSpec.valueType = Date; 
                }
            }
            break;
        
        case 'value':
            if(dimSpec.valueType === undefined) {
                dimSpec.valueType = Number;
            }

            if(dimSpec.valueType === Number) {
                if(dimSpec.formatter === undefined && 
                   !dimSpec.format){
                    dimSpec.formatter = def.get(keyArgs, 'valueNumberFormatter');
                }
            }
            break;
    }
    
    if(dimSpec.converter === undefined && 
       dimSpec.valueType === Date && 
       !dimSpec.rawFormat) {
        dimSpec.rawFormat = def.get(keyArgs, 'timeSeriesFormat');
    }
    
    return dimSpec;
};

/**
 * Adds a visual role to the dimension type.
 * 
 * @name pvc.data.DimensionType#_addVisualRole
 * @function
 * @param {pvc.visual.Role} visualRole The visual role.
 * @type undefined
 * @private
 * @internal
 */
function dimType_addVisualRole(visualRole) {
    this.playedVisualRoles.set(visualRole.name, visualRole);
    /*global compType_dimensionRolesChanged:true */
    compType_dimensionRolesChanged.call(this.type, this);
}

/**
 * Removes a visual role from the dimension type.
 * 
 * @name pvc.data.DimensionType#_removeVisualRole
 * @function
 * @param {pvc.visual.Role} visualRole The visual role.
 * @type undefined
 * @private
 * @internal
 */
function dimType_removeVisualRole(visualRole) {
    this.playedVisualRoles.rem(visualRole.name);
    compType_dimensionRolesChanged.call(this.type, this);
}/**
 * Initializes a complex type instance.
 * 
 * @name pvc.data.ComplexType
 * 
 * @class A complex type is, essentially, a named set of dimension types.
 *
 * @constructor
 * 
 * @param {object} [dimTypeSpecs]
 * A map of dimension names to dimension type constructor's keyword arguments.
 *
 * @see pvc.data.DimensionType
 */
def.type('pvc.data.ComplexType')
.init(
function(dimTypeSpecs){
    /**
     * A map of the dimension types by name.
     * 
     * @type object
     * @private
     */
    this._dims = {};
    
    /**
     * A list of the dimension types.
     * 
     * @type pvc.data.DimensionType[]
     * @private
     */
    this._dimsList = [];
    
    /**
     * A list of the dimension type names.
     * 
     * @type string[]
     * @private
     */
    this._dimsNames = [];
    
    /**
     * A list of the calculations
     * ordered by calculation order.
     * 
     * @type function[]
     * @private
     */
    this._calculations = [];
    
    /**
     * A set of the names of 
     * dimension types being calculated.
     * 
     * @type map(string boolean)
     * @private
     */
    this._calculatedDimNames = {};
    
    /**
     * An object with the dimension indexes by dimension name.
     * 
     * @type object
     * @private
     */
    this._dimsIndexByName = null;
    
    /**
     * An index of the dimension types by group name.
     * 
     * @type object
     * @private
     */
    this._dimsByGroup = {};
    
    /**
     * An index of the dimension type names by group name.
     * 
     * @type object
     * @private
     */
    this._dimsNamesByGroup = {};
    
    if(dimTypeSpecs) {
        for(var name in dimTypeSpecs){
            this.addDimension(name, dimTypeSpecs[name]);
        }
    }
})
.add(/** @lends pvc.data.ComplexType# */{
    describe: function(){

        var out = ["COMPLEX TYPE INFORMATION", pvc.logSeparator];
        
        this._dimsList.forEach(function(type){
            var features = [];
            
            features.push(type.valueTypeName);
            if(type.isComparable) { features.push("comparable"); }
            if(!type.isDiscrete)  { features.push("continuous"); }
            if(type.isHidden)     { features.push("hidden"); }

            out.push("  " + type.name + " (" + features.join(', ') + ")");
        });
        
        out.push(pvc.logSeparator);

        return out.join("\n");
    },
    
    /**
     * Obtains a dimension type given its name.
     * 
     * <p>
     * If no name is specified,
     * a map with all dimension types indexed by name is returned.
     * Do <b>NOT</b> modify this map.
     * </p>
     * 
     * @param {string} [name] The dimension type name.
     * 
     * @param {object} [keyArgs] Keyword arguments
     * @param {boolean} [keyArgs.assertExists=true] Indicates that an error is signaled 
     * if a dimension type with the specified name does not exist.
     * 
     * @type pvc.data.DimensionType | pvc.data.DimensionType[] | null
     */
    dimensions: function(name, keyArgs){
        if(name == null) {
            return this._dims;
        }
        
        var dimType = def.getOwn(this._dims, name, null);
        if(!dimType && def.get(keyArgs, 'assertExists', true)) {
            throw def.error.argumentInvalid('name', "Undefined dimension '{0}'", [name]); 
        }
        
        return dimType;
    },
    
    /**
     * Obtains an array with all the dimension types.
     * 
     * <p>
     * Do <b>NOT</b> modify the returned array. 
     * </p>
     * @type pvc.data.DimensionType[]
     */
    dimensionsList: function(){
        return this._dimsList;
    },
    
    /**
     * Obtains an array with all the calculated dimension types,
     * in order of evaluation.
     * 
     * <p>
     * Do <b>NOT</b> modify the returned array. 
     * </p>
     * @type pvc.data.DimensionType[]
     */
    calculatedDimensionsList: function(){
        return this._calcDimsList;
    },
    
    /**
     * Obtains an array with all the dimension type names.
     * 
     * <p>
     * Do <b>NOT</b> modify the returned array. 
     * </p>
     * @type string[]
     */
    dimensionsNames: function(){
        return this._dimsNames;
    },
    
    /**
     * Obtains an array of the dimension types of a given group.
     * 
     * <p>
     * Do <b>NOT</b> modify the returned array. 
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.assertExists=true] Indicates if an error is signaled when the specified group name is undefined.
     * 
     * @type pvc.data.DimensionType[]
     */
    groupDimensions: function(group, keyArgs){
        var dims = def.getOwn(this._dimsByGroup, group);
        if(!dims && def.get(keyArgs, 'assertExists', true)) {
            throw def.error.operationInvalid("There is no dimension type group with name '{0}'.", [group]);
        }
        
        return dims;
    },
    
    /**
     * Obtains an array of the dimension type names of a given group.
     * 
     * <p>
     * Do <b>NOT</b> modify the returned array. 
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.assertExists=true] Indicates if an error is signaled when the specified group name is undefined.
     *  
     * @type string[]
     */
    groupDimensionsNames: function(group, keyArgs){
        var dimNames = def.getOwn(this._dimsNamesByGroup, group);
        if(!dimNames && def.get(keyArgs, 'assertExists', true)) {
            throw def.error.operationInvalid("There is no dimension type group with name '{0}'.", [group]);
        }
        
        return dimNames;
    },
    
    /**
     * Creates and adds to the complex type a new dimension type, 
     * given its name and specification.
     * 
     * @param {string} name The name of the dimension type.
     * @param {object} [dimTypeSpec] The dimension type specification.
     * Essentially its a <i>keyArgs</i> object.
     * See {@link pvc.data.DimensionType}'s <i>keyArgs</i> constructor
     * to know about available arguments.
     *  
     * @type {pvc.data.DimensionType}
     */
    addDimension: function(name, dimTypeSpec){
        // <Debug>
        /*jshint expr:true */
        name || def.fail.argumentRequired('name');
        !def.hasOwn(this._dims, name) || def.fail.operationInvalid("A dimension type with name '{0}' is already defined.", [name]);
        // </Debug>
        
        var dimension = new pvc.data.DimensionType(this, name, dimTypeSpec);
        this._dims[name] = dimension;
        
        this._dimsIndexByName = null; // reset
        
        var group = dimension.group;
        var groupLevel;
        if(group) {
            var groupDims = def.getOwn(this._dimsByGroup, group),
                groupDimsNames;
            
            if(!groupDims) {
                groupDims = this._dimsByGroup[group] = [];
                groupDimsNames = this._dimsNamesByGroup[group] = [];
            } else {
                groupDimsNames = this._dimsNamesByGroup[group];
            }
            
            // TODO: this sorting is lexicographic...
            // TODO this should be unified with dimension.groupLevel...
            groupLevel = def.array.insert(groupDimsNames, name, def.compare);
            groupLevel = ~groupLevel;
            def.array.insertAt(groupDims, groupLevel, dimension);
        }
        
        var index;
        var L = this._dimsList.length;
        if(!group) {
            index = L;
        } else {
            groupLevel = dimension.groupLevel;
            
            // Find the index of the last dimension of the same group
            // or the one that has a higher level that this one
            for(var i = 0 ; i < L ; i++){
                var dim = this._dimsList[i];
                if(dim.group === group){
                    if(dim.groupLevel > groupLevel){
                        // Before the current one
                        index = i;
                        break;
                    }
                    
                    // After the current one
                    index = i + 1;
                }
            } 
               
            if(index == null){
                index = L;
            }
        }
        
        def.array.insertAt(this._dimsList,  index, dimension);
        def.array.insertAt(this._dimsNames, index, name);
        
        // calculated
        if(dimension._calculate){
            index = def.array.binarySearch(
                        this._calcDimsList, 
                        dimension._calculationOrder, 
                        def.compare,
                        function(dimType){ return dimType._calculationOrder; });
            if(index >= 0){
                // Add after
                index++;
            } else {
                // Add at the two's complement of index
                index = ~index;
            }
            
            def.array.insertAt(this._calcDimsList, index, dimension);
        }
        
        this._isPctRoleDimTypeMap = null;
        
        return dimension;
    },
    
    addCalculation: function(calcSpec, dimsOptions){
        /*jshint expr:true */
        calcSpec || def.fail.argumentRequired('calcSpec');
        
        var calculation = calcSpec.calculation ||
                          def.fail.argumentRequired('calculations[i].calculation');
        
        var dimNames = calcSpec.names;
        if(typeof dimNames === 'string'){
            dimNames = dimNames.split(/\s*\,\s*/);
        } else {
            dimNames = def.array.as(dimNames);
        }
        
        if(dimNames && dimNames.length){
            var calcDimNames = this._calculatedDimNames;
            
            dimNames.forEach(function(name){
                if(name){
                    name = name.replace(/^\s*(.+?)\s*$/, "$1"); // trim
                    
                    !def.hasOwn(calcDimNames, name) || 
                      def.fail.argumentInvalid('calculations[i].names', "Dimension name '{0}' is already being calculated.", [name]);
                    
                    // Dimension need to be created?
                    var dimType = this._dims[name];
                    if(!dimType){
                        var dimSpec = pvc.data.DimensionType.extendSpec(name, null, dimsOptions);
                        this.addDimension(name, dimSpec);
                    }
                    
                    calcDimNames[name] = true;
                    
                    dimType._toCalculated();
                }
            }, this);
        }
        
        this._calculations.push(calculation);
    },
    
    isCalculated: function(dimName){
        return def.hasOwn(this._calculatedDimNames, dimName);
    },
    
    _calculate: function(complex){
        var calcs = this._calculations;
        if(calcs.length){
            var valuesByName = {}; 
            
            calcs.forEach(function(calc){
                calc(complex, valuesByName);
            });
            
            return valuesByName;
        }
    },
    
    /**
     * Obtains a map of the dimension types, indexed by their name,
     * that are playing a role such that {@link pvc.visual.Role#isPercent} is <tt>true</tt>.
     * 
     * @type def.Map
     */
    getPlayingPercentVisualRoleDimensionMap: function(){
        var map = this._isPctRoleDimTypeMap;
        if(!map) {
            map = this._isPctRoleDimTypeMap = new def.Map(
                def.query(def.own(this._dims))
                    .where(function(dimType){ return dimType.playingPercentVisualRole(); })
                    .object({
                        name: function(dimType) { return dimType.name; } 
                    }));
        }
        
        return map;
    },
    
    /**
     * Sorts a specified dimension array in place, 
     * according to the definition order.
     * 
     * @param {any[]} dims Array of dimension names.
     * @param {function} [nameKey] Allows extracting the dimension name from
     * each of the elements of the specified array.
     * 
     * @type any[]
     */
    sortDimensionNames: function(dims, nameKey){
        var dimsIndexByName = this._dimsIndexByName;
        if(!dimsIndexByName){
            dimsIndexByName = 
                def
                .query(this._dimsList)
                .object({
                    name:  function(dim){ return dim.name; },
                    value: function(dim, index){ return index; }
                });
            this._dimsIndexByName = dimsIndexByName;
        }
        
        dims.sort(function(da, db){
            return def.compare(
                    dimsIndexByName[nameKey ? nameKey(da) : da],
                    dimsIndexByName[nameKey ? nameKey(db) : db]);
                    
        });
        
        return dims;
    }
});

/**
 * Called by a dimension type to indicate that its assigned roles have changed.
 * 
 * @name pvc.data.ComplexType#_dimensionRolesChanged
 * @function
 * @param {pvc.data.DimensionType} dimType The affected dimension type.
 * @type undefined
 * @private
 * @internal
 */
function compType_dimensionRolesChanged(dimType) {
    this._isPctRoleDimTypeMap = null;
}/**
 * Initializes a complex type project.
 * 
 * @name pvc.data.ComplexType
 * 
 * @class A complex type project is a work in progress set of dimension specifications.
 */
def.type('pvc.data.ComplexTypeProject')
.init(
function(dimGroupSpecs){
    this._dims = {};
    this._dimList = [];
    this._dimGroupsDims = {};
    this._dimGroupSpecs = dimGroupSpecs || {};
    
    this._calcList = [];
})
.add(/** @lends pvc.data.ComplexTypeProject# */{
    _ensureDim: function(name){
        /*jshint expr:true*/
        name || def.fail.argumentInvalid('name', "Invalid dimension name '{0}'.", [name]);
        
        var info = def.getOwn(this._dims, name);
        if(!info){
            info = this._dims[name] = this._createDim(name);
            
            this._dimList.push(info);
            
            var groupDimsNames = def.array.lazy(this._dimGroupsDims, info.groupName);
            // TODO: this sorting is lexicographic but should be numeric
            def.array.insert(groupDimsNames, name, def.compare);
        }
        
        return info;
    },
    
    hasDim: function(name){
        return def.hasOwn(this._dims, name);
    },
    
    setDim: function(name, spec){
        var _ = this._ensureDim(name).spec;
        if(spec){
            def.copy(_, spec);
        }
        
        return this;
    },
    
    setDimDefaults: function(name, spec){
        def.setUDefaults(this._ensureDim(name).spec, spec);
        return this;
    },
    
    _createDim: function(name, spec){
        var dimGroupName = pvc.data.DimensionType.dimensionGroupName(name);
        var dimGroupSpec = this._dimGroupSpecs[dimGroupName];
        if(dimGroupSpec) {
            spec = def.create(dimGroupSpec, spec /* Can be null */); 
        }
        return {
            name: name,
            groupName: dimGroupName,
            spec: spec || {}
        };
    },
    
    readDim: function(name){
        var info = this._ensureDim(name);
        if(info.isRead){
            throw def.error.operationInvalid("Dimension '{0}' already is the target of a reader.", [name]);
        }
        if(info.isCalc){
            throw def.error.operationInvalid("Dimension '{0}' is being calculated, so it cannot be the target of a reader.", [name]);
        }
        
        info.isRead = true;
    },
    
    calcDim: function(name){
        var info = this._ensureDim(name);
        if(info.isCalc){
            throw def.error.operationInvalid("Dimension '{0}' already is being calculated.", [name]);
        }
        if(info.isRead){
            throw def.error.operationInvalid("Dimension '{0}' is the target of a reader, so it cannot be calculated.", [name]);
        }
        
        info.isCalc = true;
    },
    
    isReadOrCalc: function(name){
        if(name){
            var info = def.getOwn(this._dims, name);
            if(info){
                return info.isRead || info.isCalc;
            }
        }
        
        return false;
    },
    
    groupDimensionsNames: function(groupDimName){
        return this._dimGroupsDims[groupDimName];
    },
    
    setCalc: function(calcSpec){
        /*jshint expr:true */
        calcSpec || def.fail.argumentRequired('calculations[i]');
        calcSpec.calculation || def.fail.argumentRequired('calculations[i].calculation');
        
        var dimNames = calcSpec.names;
        if(typeof dimNames === 'string'){
            dimNames = dimNames.split(/\s*\,\s*/);
        } else {
            dimNames = def.array.as(dimNames);
        }
        
        if(dimNames && dimNames.length){
            dimNames.forEach(this.calcDim, this);
        }
        
        this._calcList.push(calcSpec);
    },
    
    configureComplexType: function(complexType, translOptions){
        //var keyArgs = {assertExists: false};
        
        this._dimList.forEach(function(dimInfo){
            var dimName = dimInfo.name;
            //if(!complexType.dimensions(dimName, keyArgs)){
            var spec = dimInfo.spec;
            
            spec = pvc.data.DimensionType.extendSpec(dimName, spec, translOptions);
            
            complexType.addDimension(dimName, spec);
            //} // TODO: else assert has not changed?
        });
        
        this._calcList.forEach(function(calcSpec){
            complexType.addCalculation(calcSpec);
        });
    }
});
/**
 * Initializes a translation operation.
 * 
 * @name pvc.data.TranslationOper
 * @class Represents one translation operation 
 * from some data source format to the list of atoms format.
 * 
 * @property {pvc.BaseChart} chart The associated chart.
 * @property {pvc.data.ComplexType} complexType The complex type that represents the translated data.
 * @property {pvc.data.Data} data The data object which will be loaded with the translation result.
 * @property {object} source The source object, of some format, being translated.
 * @property {object} metadata A metadata object describing the source.
 * @property {object} options  An object with translation options.
 * 
 * @constructor
 * @param {pvc.BaseChart} chart The associated chart.
 * @param {pvc.data.ComplexTypeProject} complexTypeProj The complex type project that will represent the translated data.
 * @param {object} source The source object, of some format, to be translated.
 * The source is not modified.
 * @param {object} [metadata] A metadata object describing the source.
 * @param {object} [options] An object with translation options.
 * Options are translator specific.
 * TODO: missing common options here
 */
def.type('pvc.data.TranslationOper')
.init(function(chart, complexTypeProj, source, metadata, options){
    this.chart = chart;
    this.complexTypeProj = complexTypeProj;
    this.source   = source;
    this.metadata = metadata || {};
    this.options  = options  || {};

    this._initType();
    
    if(pvc.debug >= 4) {
        this._logItems = true;
        this._logItemCount = 0;
    }
})
.add(/** @lends pvc.data.TranslationOper# */{
    
    _logItems: false,
    
    /**
     * Logs the contents of the source and metadata properties.
     */
    logSource: def.method({isAbstract: true}),

    /**
     * Obtains the number of fields of the virtual item.
     * <p>
     * The default implementation returns the length of the metadata.
     * </p>
     * 
     * @type number
     * @virtual
     */
    virtualItemSize: function(){
        return this.metadata.length;
    },

    freeVirtualItemSize: function(){
        return this.virtualItemSize() - this._userUsedIndexesCount;
    },

    /**
     * Defines a dimension reader.
     *
     * @param {object} dimReaderSpec A dimensions reader specification.
     *
     * @type undefined
     */
    defReader: function(dimReaderSpec){
        /*jshint expr:true */
        dimReaderSpec || def.fail.argumentRequired('readerSpec');

        var dimNames;
        if(typeof dimReaderSpec === 'string'){
            dimNames = dimReaderSpec;
        } else {
            dimNames =  dimReaderSpec.names;
        }
        
        if(typeof dimNames === 'string'){
            dimNames = dimNames.split(/\s*\,\s*/);
        } else {
            dimNames =  def.array.as(dimNames);
        }
        
        // Consumed/Reserved virtual item indexes
        var indexes = def.array.as(dimReaderSpec.indexes);
        if(indexes) {
            indexes.forEach(this._userUseIndex, this);
        }
        
        var hasDims = !!(dimNames && dimNames.length);
        var reader = dimReaderSpec.reader;
        if(!reader) {
            if(hasDims){
                return  this._userCreateReaders(dimNames, indexes); // -> indexes, possibly expanded
            } // else a reader that only serves to exclude indexes
        } else {
            hasDims || def.fail.argumentRequired('reader.names', "Required argument when a reader function is specified.");
            
            this._userRead(reader, dimNames);
        }
        
        return indexes;
    },

    /**
     * Called once, before {@link #execute},
     * for the translation to configure the complex type (abstract).
     *
     * <p>
     *    If this method is called more than once,
     *    the consequences are undefined.
     * </p>
     *
     * @name pvc.data.TranslationOper#configureType
     * @function
     * @type undefined
     * @virtual
     */
    configureType: function(){
        this._configureTypeCore();
    },
    
    /** @abstract */
    _configureTypeCore: def.method({isAbstract: true}),
    
    _initType: function(){
        this._userDimsReaders = [];
        this._userDimsReadersByDim = {};
        
        this._userItem = [];
        
        this._userUsedIndexes = {};
        this._userUsedIndexesCount = 0;
        
        // -------------
        
        var userDimReaders = this.options.readers;
        if(userDimReaders) {
            userDimReaders.forEach(this.defReader, this);
        }

        var multiChartIndexes = pvc.parseDistinctIndexArray(this.options.multiChartIndexes);
        if(multiChartIndexes) {
            this._multiChartIndexes = this.defReader({names: 'multiChart', indexes: multiChartIndexes });
        }
    },

    _userUseIndex: function(index){
        index = +index; // to number

        /*jshint expr:true */
        (index >= 0) || def.fail.argumentInvalid('index', "Invalid reader index: '{0}'.", [index]);

        !def.hasOwn(this._userUsedIndexes, index) ||
            def.fail.argumentInvalid('index', "Virtual item index '{0}' is already assigned.", [index]);

        this._userUsedIndexes[index] = true;
        this._userUsedIndexesCount++;
        this._userItem[index] = true;
        
        return index;
    },

    _userCreateReaders: function(dimNames, indexes){
        if(!indexes){
            indexes = [];
        } else {
            // Convert indexes to number
            indexes.forEach(function(index, j){
                indexes[j] = +index;
            });
        }

        // Distribute indexes to names, from left to right
        // Excess indexes go to the last *group* name
        // Missing indexes are padded from available indexes starting from the last provided index
        // If not enough available indexes exist, those names end up reading undefined
        var I = indexes.length,
            N = dimNames.length,
            dimName;
        
        if(N > I) {
            // Pad indexes
            var nextIndex = I > 0 ? (indexes[I - 1] + 1) : 0;
            do{
                nextIndex = this._nextAvailableItemIndex(nextIndex);
                indexes[I] = nextIndex;
                this._userUseIndex(nextIndex);

                I++;
            }while(N > I);
        }

        // If they match, it's one-one name <-- index
        var L = (I === N) ? N : (N - 1);

        // The first N-1 names get the first N-1 indexes
        for(var n = 0 ; n < L ; n++) {
            dimName = dimNames[n];
            this._userRead(this._propGet(dimName, indexes[n]), dimName);
        }

        // The last name is the dimension group name that gets all remaining indexes
        if(L < N) {
            // TODO: make a single reader that reads all atoms??
            // Last is a *group* START name
            var splitGroupName = pvc.splitIndexedId(dimNames[N - 1]),
                groupName = splitGroupName[0],
                level     = def.nullyTo(splitGroupName[1], 0);

            for(var i = L ; i < I ; i++, level++) {
                dimName = pvc.buildIndexedId(groupName, level);
                this._userRead(this._propGet(dimName, indexes[i]), dimName);
            }
        }
        
        return indexes;
    },

    _userRead: function(reader, dimNames){
        /*jshint expr:true */
        def.fun.is(reader) || def.fail.argumentInvalid('reader', "Reader must be a function.");
        
        if(def.array.is(dimNames)){
            dimNames.forEach(function(name){
                this._readDim(name, reader);
            }, this);
        } else {
            this._readDim(dimNames, reader);
        }

        this._userDimsReaders.push(reader);
    },

    _readDim: function(name, reader){
        this.complexTypeProj.readDim(name);
        this._userDimsReadersByDim[name] = reader;
    },
    
    /**
     * Performs the translation operation for a data instance.
     * 
     * <p>
     *    The returned atoms are interned in 
     *    the dimensions of the specified data instance.
     * </p>
     * 
     * <p>
     *    If this method is called more than once,
     *    the consequences are undefined.
     * </p>
     * 
     * @param {pvc.data.Data} data The data object in whose dimensions returned atoms are interned.
     * 
     * @returns {def.Query} An enumerable of {@link pvc.data.Atom[]}
     */
    execute: function(data){
        this.data = data;
        
        return this._executeCore();
    },
    
    /**
     * Obtains an enumerable of translated atoms (virtual).
     * 
     * <p>
     *    The default implementation applies 
     *    every dimensions reader returned by {@link #_getDimensionsReaders} 
     *    to every item returned by  {@link #_getItems}.
     *   
     *    Depending on the underlying data source format 
     *    this may or may not be a good translation strategy.
     *    Override to apply a different one.
     * </p>
     * 
     * @returns {def.Query} An enumerable of {@link pvc.data.Atom[]}
     * @virtual
     */
    _executeCore: function(){
        var dimsReaders = this._getDimensionsReaders();
        
        return def.query(this._getItems())
                  .select(function(item){
                      return this._readItem(item, dimsReaders);
                  }, this);
    },
    
    /**
     * Obtains an enumerable of items to translate (virtual).
     * 
     * <p>
     * The default implementation assumes that {@link #source}
     * is directly the desired enumerable of items. 
     * </p>
     * 
     * @type def.Query
     */
    _getItems: function(){
        return this.source;
    },
    
    /**
     * Obtains the dimensions readers array (virtual).
     * 
     * <p>
     * Each dimensions reader function reads one or more dimensions
     * from a source item.
     * It has the following signature:
     * </p>
     * <pre>
     * function(item : any) : pvc.data.Atom[] | pvc.data.Atom
     * </pre>
     * 
     * <p>
     * The default implementation simply returns the {@link #_userDimsReaders} field. 
     * </p>
     * 
     * @name _getDimensionsReaders
     * @type function[]
     * @virtual
     */
    _getDimensionsReaders: function(){
        return this._userDimsReaders;
    },
    
    /**
     * Applies all the specified dimensions reader functions to an item 
     * and sets the resulting atoms in a specified array (virtual).
     * 
     * @param {any} item The item to read.
     * @param {function[]} dimsReaders An array of dimensions reader functions.
     * @returns {map(string any)} A map of read raw values by dimension name.
     * @virtual
     */
    _readItem: function(item, dimsReaders) {
        // This function is performance critical and so does not use forEach
        // or array helpers, avoiding function calls, closures, etc.
        var logItem = this._logItems;
        if(logItem) {
            var logItemCount = this._logItemCount;
            if(logItemCount < 10){
                pvc.log('virtual item [' + this._logItemCount + ']: ' + pvc.stringify(item));
                this._logItemCount++;
            } else {
                pvc.log('...');
                logItem = this._logItems = false;
            }
        }
        
        var r = 0, 
            R = dimsReaders.length, 
            a = 0,
            data = this.data,
            valuesByDimName = {};
        
        while(r < R) {
            dimsReaders[r++].call(data, item, valuesByDimName);
        }
        
        if(logItem) {
            var atoms = {};
            for(var dimName in valuesByDimName){
                var atom = valuesByDimName[dimName];
                if(def.object.is(atom)){
                    atom = ('v' in atom) ? atom.v : ('value' in atom) ? atom.value : '...';
                }
                
                atoms[dimName] = atom;
            }
            
            pvc.log('-> read: ' + pvc.stringify(atoms));
        }
        
        return valuesByDimName;
    },
    
    /**
     * Given a dimension name and a property name,
     * creates a corresponding dimensions reader (protected).
     * 
     * @param {string} dimName The name of the dimension on which to intern read values.
     * @param {string} prop The property name to read from each item.
     * @param {object} [keyArgs] Keyword arguments. 
     * @param {boolean} [keyArgs.ensureDim=true] Creates a dimension with the specified name, with default options, if one does not yet exist. 
     * 
     * @type function
     */
    _propGet: function(dimName, prop) {
        
        function propGet(item, atoms){
            atoms[dimName] = item[prop];
        }
        
        return propGet;
    },
    
    /**
     * Given a dimension name and a raw value of that dimension,
     * creates a dimensions reader that returns the corresponding atom,
     * regardless of the source item supplied to it (protected).
     * 
     * @param {string} dimName The name of the dimension on which to intern <i>constRawValue</i>.
     * @param {string} constRawValue The raw value.
     * 
     * @param {object} [keyArgs] Keyword arguments. 
     * @param {boolean} [keyArgs.ensureDim=true] Creates a dimension with the specified name, with default options, if one does not yet exist.
     * 
     * @type function
     */
    _constGet: function(dimName, constRawValue, keyArgs) {
        var me = this,
            constAtom;
        
        function constGet(item, atoms) {
            atoms[dimName] = 
                    constAtom || 
                    (constAtom = me.data.dimensions(dimName).intern(constRawValue));
        }

        return constGet;
    },
    
    // TODO: docs
    _nextAvailableItemIndex: function(index, L){
        if(index == null) {
            index = 0;
        }
        if(L == null){
            L = Infinity;
        }

        while(index < L && def.hasOwn(this._userItem, index)) {
            index++;
        }
        
        return index < L ? index : -1;
    },
    
    _getUnboundRoleDefaultDimNames: function(roleName, count, dims, level){
        var role = this.chart.visualRoles(roleName, {assertExists: false});
        if(role && !role.isPreBound()){
            var dimGroupName = role.defaultDimensionName;
            if(dimGroupName){
                dimGroupName = dimGroupName.match(/^(.*?)(\*)?$/)[1];
                
                if(!dims){
                    dims = [];
                }
                
                if(level == null){
                    level = 0;
                }
                
                if(count == null) {
                    count = 1;
                }
                
                // Already bound dimensions count
                while(count--){
                    var dimName = pvc.buildIndexedId(dimGroupName, level++);
                    if(!this.complexTypeProj.isReadOrCalc(dimName)){
                        dims.push(dimName);
                    }
                }
                
                return dims.length ? dims : null;
            }
        }
    }
});
/**
 * @name pvc.data.MatrixTranslationOper
 * @class Represents one translation operation, 
 * from a source matrix in some format to 
 * an enumerable of atom arrays.
 * 
 * @extends pvc.data.TranslationOper
 * @abstract
 * 
 * @constructor
 * @param {pvc.BaseChart} chart The associated chart.
 * @param {pvc.data.ComplexType} complexType The complex type that will represent the translated data.
 * @param {pvc.data.Data} data The data object which will be loaded with the translation result.
 * @param {object} source The source matrix, in some format, to be translated.
 * The source is not modified.
 * @param {object} [metadata] A metadata object describing the source.
 * @param {object} [options] An object with translation options.
 * 
 * @param {boolean} [options.seriesInRows=false]
 * Indicates that series are to be switched with categories.
 *
 * @param {Number[]} [options.plot2SeriesIndexes]
 * Array of series indexes in {@link #source} that are second axis' series.
 * Any non-null value is converted to an array.
 * Each value of the array is also converted to a number.
 * A negative value is counted from the end
 * of the series values (-1 is the series last value, ...).
 * <p>
 * Note that the option 'seriesInRows'
 * affects what are considered to be series values.
 *
 * Having determined where series are stored,
 * the order of occurrence of a series value in {@link #source}
 * determines its index.
 * </p>
 */
def.type('pvc.data.MatrixTranslationOper', pvc.data.TranslationOper)
.add(/** @lends pvc.data.MatrixTranslationOper# */{
    
    _initType: function(){
        this.J = this.metadata.length;
        this.I = this.source.length;
        
        this._processMetadata();
        
        this.base();
    },
    
    _knownContinuousColTypes: {'numeric': 1, 'number': 1, 'integer': 1},
    
    _processMetadata: function(){
        // Get the indexes of columns which are 
        // not stated as continuous (numeric..)
        // In these, 
        // we can't trust their stated data type
        // cause when nulls exist on the first row, 
        // they frequently come stated as "string"...
        var knownContinColTypes = this._knownContinuousColTypes;
        var columns = 
            def
            .query(this.metadata)
            // Fix indexes of colDefs
            .select(function(colDef, colIndex){
                // Ensure colIndex is trustable
                colDef.colIndex = colIndex;
                return colDef; 
             })
            .where(function(colDef){
                var colType = colDef.colType;
                return !colType ||
                       knownContinColTypes[colType.toLowerCase()] !== 1;
            })
            .select(function(colDef){ return colDef.colIndex; })
            .array();
        
        // 1 - continuous (number, date)
        // 0 - discrete   (anything else)
        // Assume all are continuous
        var columnTypes = def.array.create(this.J, 1);
        
        // Number of rows in source
        var I = this.I;
        var source = this.source;
        
        // Number of columns remaining to confirm data type
        var J = columns.length;
        
        for(var i = 0 ; i < I && J > 0 ; i++){
            var row = source[i];
            var m = 0;
            while(m < J){
                var j = columns[m];
                var value = row[j];
                if(value != null){
                    columnTypes[j] = this._getSourceValueType(value);
                    
                    columns.splice(m, 1);
                    J--;
                } else {
                    m++;
                }
            }
        }
        
        this._columnTypes = columnTypes;
    },

    // 1 - continuous (number, date)
    // 0 - discrete   (anything else)
    /** @static */
    _getSourceValueType: function(value){
        switch(typeof value){
            case 'number': return 1;
            case 'object':
                if(value instanceof Date){
                    return 1;
                }
        }
        
        return 0; // discrete
    },
    
    logSource: function(){
        var out = [
            "DATA SOURCE SUMMARY",
            pvc.logSeparator,
            "ROWS (" + Math.min(10, this.I) + "/" + this.I + ")"
        ];
        
        def
        .query(this.source)
        .take(10)
        .each(function(row, index){
            out.push("  [" + index + "] " + pvc.stringify(row));
        });
        
        if(this.I > 10){
            out.push('  ...');
        }
        
        out.push("COLS (" + this.J + ")");
        
        var colTypes = this._columnTypes;
        this
        .metadata
        .forEach(function(col, j){
            out.push(
                "  [" + j + "] " + 
                "'" + col.colName + "' (" +
                "type: "      + col.colType + ", " + 
                "inspected: " + (colTypes[j] ? 'continuous' : 'discrete') +
                 (col.colLabel ? (", label: '" + col.colLabel + "'") : "")  + 
                ")");
        });
        
        out.push(pvc.logSeparator);
        pvc.log(out.join('\n'));
    },
    
    /**
     * Creates the set of second axis series keys
     * corresponding to the specified
     * plot2SeriesIndexes and seriesAtoms arrays (protected).
     *
     * Validates that the specified series indexes are valid
     * indexes of seriesAtoms array.
     *
     * @param {Array} plot2SeriesIndexes Array of indexes of the second axis series values.
     * @param {Array} seriesKeys Array of the data source's series atom keys.
     *
     * @returns {Object} A set of second axis series values or null if none.
     *
     * @private
     * @protected
     */
    _createPlot2SeriesKeySet: function(plot2SeriesIndexes, seriesKeys){
        var plot2SeriesKeySet = null,
            seriesCount = seriesKeys.length;
        def.query(plot2SeriesIndexes).each(function(indexText){
            // Validate
            var seriesIndex = +indexText; // + -> convert to number
            if(isNaN(seriesIndex)){
                throw def.error.argumentInvalid('plot2SeriesIndexes', "Element is not a number '{0}'.", [indexText]);
            }

            if(seriesIndex < 0){
                if(seriesIndex <= -seriesCount){
                    throw def.error.argumentInvalid('plot2SeriesIndexes', "Index is out of range '{0}'.", [seriesIndex]);
                }

                seriesIndex = seriesCount + seriesIndex;
            } else if(seriesIndex >= seriesCount){
                throw def.error.argumentInvalid('plot2SeriesIndexes', "Index is out of range '{0}'.", [seriesIndex]);
            }

            // Set
            if(!plot2SeriesKeySet){
                plot2SeriesKeySet = {};
            }
            
            plot2SeriesKeySet[seriesKeys[seriesIndex]] = true;
        });

        return plot2SeriesKeySet;
    },

    // TODO: docs
    _dataPartGet: function(calcAxis2SeriesKeySet, seriesReader) {

        var me = this;
        
        var dataPartDimName = this.options.dataPartDimName;

        var dataPartDimension,
            plot2SeriesKeySet,
            part1Atom,
            part2Atom,
            outAtomsSeries = {};

        function dataPartGet(item, outAtoms) {
            /*
             * First time initialization.
             * Done here because *data* isn't available before.
             */
            if(!dataPartDimension) {
                plot2SeriesKeySet = calcAxis2SeriesKeySet();
                dataPartDimension = me.data.dimensions(dataPartDimName);

                if(pvc.debug >=3 && plot2SeriesKeySet){
                    pvc.log("Second axis series values: " +
                        pvc.stringify(def.keys(plot2SeriesKeySet)));
                }
            }

            var partAtom;
            seriesReader(item, outAtomsSeries);
            var series = outAtomsSeries.series;
            if(series != null && series.v != null){
                series = series.v;
            }
            
            if(def.hasOwn(plot2SeriesKeySet, series)){
                partAtom = part2Atom || (part2Atom = dataPartDimension.intern("1"));
            } else {
                partAtom = part1Atom || (part1Atom = dataPartDimension.intern("0"));
            }
            
            outAtoms[dataPartDimName] = partAtom;
        }

        return dataPartGet;
    }
});
/**
 * @name pvc.data.CrosstabTranslationOper
 * @class A translation from a matrix in crosstab format.
 * <p>
 *    The default <i>matrix-crosstab</i> format is:
 * </p>
 * <pre>
 * +----------+----------+----------+
 * | -        | S1       | S2       | ... (taken from metadataItem.colName)
 * +==========+==========+==========+
 * | C1       | 12       | 45       |
 * | C2       | 11       | 99       |
 * | C3       | null     |  3       |
 * +----------+----------+----------+
 * </pre>
 * <p>Legend:</p>
 * <ul>
 *   <li>C<sub>i</sub> &mdash; Category value <i>i</i></li>
 *   <li>S<sub>j</sub> &mdash; Series value <i>j</i></li>
 * </ul>
 * 
 * TODO: document crosstab options
 * 
 * @extends pvc.data.MatrixTranslationOper
 */
def.type('pvc.data.CrosstabTranslationOper', pvc.data.MatrixTranslationOper)
.add(/** @lends pvc.data.CrosstabTranslationOper# */{
    /* LEGEND
     * ======
     * 
     * Matrix Algebra
     * --------------
     * 
     *      j
     *    +---+
     * i  | v |
     *    +---+
     * 
     * i - index of matrix line
     * j - index of matrix column
     * 
     * v - value at indexes i,j
     * 
     * ----
     * 
     * line  = matrix[i]
     * value = line[j]
     * 
     * 
     * Crosstab Algebra
     * ----------------
     * 
     *      CC
     *    +----+
     * RR | MM |
     *    +----+
     * 
     * RR = row     space
     * CC = column  space
     * MM = measure space
     * 
     * ----
     * As a function
     * 
     * cross-table: RR X CC -> MM
     * 
     * ----
     * Dimension of spaces (called "depth" in the code to not confuse with Dimension)
     * 
     * R  = number of row      components
     * C  = number of column   components
     * M  = number of measure  components
     * 
     * ----
     * Instances / groups / members
     * 
     * <RG> = <r1, ..., rR> = R-tuple of row     values 
     * <CG> = <s1, ..., sS> = C-tuple of column  values 
     * <MG> = <m1, ..., mM> = M-tuple of measure values
     * 
     * r = index of row     group component
     * c = index of column  group component
     * m = index of measure group component
     * 
     * ----
     * Extent of spaces
     * 
     * RG = number of (distinct) row    groups
     * CG = number of (distinct) column groups
     * MG = RG * CG
     * 
     * rg = index of row    group
     * cg = index of column group
     * 
     * 
     * 
     * Crosstab in a Matrix
     * --------------------
     * 
     * Expand components into own columns:
     * | <...RG...> | <=> | r1 | r2 | r3 | ... | rR |
     * 
     * All component values joined with a separator character, ~,
     * occupying only one column:
     * | <~CG~>     | <=> | "c1~c2~c3~...~cC" |
     * 
     * ----
     * 
     * Format: "Measures in columns" (uniform)
     * 
     *             0            R           R+M    R+M*(CG-1)   R+M*CG
     *             o------------+------------+ ... +------------o (j - matrix column)
     *         
     *                          0            1     CG-1         CG
     *                          o------------+ ... +------------o (cg - column group index)
     *        
     *                          +------------+ ... +------------+    <-- this._colGroups
     *                   X      | <~CG~>     |     | <~CG~>     | 
     *                          +------------+     +------------+
     *        
     *      0 o    +------------+------------+ ... +------------+    <-- this._lines
     *        |    | <...RG...> | <...MG...> |     | <...MG...> |
     *        |    |            | <...MG...> |     | <...MG...> |
     *      1 +    +------------+------------+     +------------+
     *                          ^
     *        .                 |
     *        .               m = cg % M
     *        .
     *        
     *        |
     *     RG o
     *       (i - matrix line)
     *       (rg - row group)
     *       
     * i = rg
     * j = R + M*cg
     *
     * Unfortunately, not all measures have to be specified in all column groups.
     * When a measure in column group would have all rows with a null value, it can be omitted.
     * 
     * Virtual Item Structure
     * ----------------------
     * A relational view of the cross groups
     *  
     *    [<...CG...>, <...RG...>, <...MG...>]
     * 
     * This order is chosen to match that of the relational translation.
     *
     * Virtual Item to Dimensions mapping
     * ----------------------------------
     * 
     * A mapping from a virtual item to a list of atoms (of distinct dimensions)
     * 
     * virtual-item --> atom[]
     * 
     * A set of dimensions readers are called and 
     * each returns one or more atoms of distinct dimensions.
     * 
     *  * Each dimension has exactly one dimensions reader that reads its atoms.
     *  * One dimensions reader may read more than one dimension.
     *  * A dimensions reader always reads the same set of dimensions.
     *  
     *  * A dimension consumes data from zero or more virtual item components.
     *  * A virtual item component is consumed by zero or more dimensions.
     *  * A dimension may vary in which virtual item components it consumes, from atom to atom.
     *   
     *  virtual-item-component * <-> * dimension + <-> 1 dimensions reader
     */

    /**
     * Obtains the number of fields of the virtual item.
     * @type number
     * @override
     */
    virtualItemSize: function(){
        return this.R + this.C + this.M;
    },
    
    /**
     * Performs the translation operation (override).
     * @returns {def.Query} An enumerable of {@link map(string any)}
     * @override
     */
    _executeCore: function(){
        if(!this.metadata.length){
            return def.query(); 
        }
        
        var dimsReaders = this._getDimensionsReaders();
        
        // ----------------
        // Virtual item
        
        var item  = new Array(this.virtualItemSize()),
            itemCrossGroupIndex = this._itemCrossGroupIndex,
            me = this
            ;
        
        // Updates VITEM
        // . <- source = line[0..R]
        // . <- source = colGroup[0..C]
        function updateVItemCrossGroup(crossGroupId, source) {
            // Start index of cross group in item
            var itemIndex   = itemCrossGroupIndex[crossGroupId],
                sourceIndex = 0,
                depth       = me[crossGroupId];
            
            while((depth--) > 0) {
                item[itemIndex++] = source[sourceIndex++];
            }
        }
        
        // . <-  line[colGroupIndexes[0..M]]
        function updateVItemMeasure(line, cg) {
            // Start index of cross group in item
            var itemIndex = itemCrossGroupIndex.M;
            var cgIndexes = me._colGroupsIndexes[cg];
            var depth     = me.M;
            
            for(var i = 0 ; i < depth ; i++){
                var lineIndex = cgIndexes[i];
                item[itemIndex++] = lineIndex != null ? line[lineIndex] : null;
            }
        }
        
        // ----------------

        function expandLine(line/*, i*/){
            updateVItemCrossGroup('R', line);
            
            return def.query(this._colGroups)
                .select(function(colGroup, cg){
                    // Update ITEM
                    updateVItemCrossGroup('C', colGroup);
                    updateVItemMeasure(line, cg);
                  
                    // Naive approach...
                    // Call all readers every time
                    // Dimensions that consume rows and/or columns may be evaluated many times.
                    // So, it's very important that pvc.data.Dimension#intern is as fast as possible
                    //  detecting already interned values.
                    return this._readItem(item, dimsReaders);
                }, this);
        }
        
        return def.query(this._lines)
                  .selectMany(expandLine, this);
    },
    
    _processMetadata: function(){
        
        this.base();
        
        this._separator = this.options.separator || '~';
        
        /* Don't change source */
        var lines = pvc.cloneMatrix(this.source);

        this._lines = lines;

        /* Determine R, C and M */
        
        // Default values
        this.R = 1;
        this.C = 1;
        this.M = 1;
        
        this.measuresDirection = null;
        
        var colNames;
        if(this.options.seriesInRows){
            colNames = this.metadata.map(function(d){ return d.colName; });
        } else if(this.options.compatVersion <= 1){
            colNames = this.metadata.map(function(d){ return {v: d.colName}; });
        } else {
            colNames = this.metadata.map(function(d){ return {v: d.colName, f: d.colLabel }; });
        }
        
        // For each cross group,
        // an array with the value types of each of its columns 
        // C|R|M -> [0|1, ...]
        // 1 - continuous (number, date)
        // 0 - discrete   (anything else)
        var itemCrossGroupTypes = this._itemCrossGroupTypes = {
                /*
                'C': [],
                'R': [],
                'M': []
                */
            };
        
        // --------------
        // * isMultiValued
        // * measuresInColumns
        // * measuresIndex, [measuresCount=1]
        // * [categoriesCount = 1]
        
        // ~~~~ R*
        
        if(!this.options.isMultiValued) {
            //    | C
            // ---|---
            // R* | M
            
            this.R = this._getCategoriesCount();
            
            // C = 1
            // M = 1
            
            this._colGroups = colNames.slice(this.R);
            this._colGroupsIndexes = new Array(this._colGroups.length);
            
            // To Array
            this._colGroups.forEach(function(colGroup, cg){
                this._colGroups[cg] = [colGroup];
                this._colGroupsIndexes[cg] = [this.R + cg]; // all the same
            }, this);

            // R is set below 
            itemCrossGroupTypes.C = [0]; // 1 discrete column
            itemCrossGroupTypes.M = [this._columnTypes[this.R]];
        } else {
            /* MULTI-VALUED */
            
            var measuresInColumns = def.get(this.options, 'measuresInColumns', true);
            if(measuresInColumns || this.options.measuresIndex == null) {
                
                this.R = this._getCategoriesCount();

                // First R columns are from row space
                var encodedColGroups = colNames.slice(this.R);
                
                // Remaining are column and measure types
                var L = encodedColGroups.length;

                // Any results in column direction...
                if(L > 0) {
                    
                    if(!measuresInColumns) {
                        // ~~~~ C*  M
                        
                        //    | C*
                        // ---|----
                        // R* | M
                        
                        this._colGroups = encodedColGroups;
                        this._colGroupsIndexes = [];
                        
                        // Split encoded column groups
                        this._colGroups.forEach(function(colGroup, cg){
                            this._colGroups[cg] = this._splitEncodedColGroupCell(colGroup);
                            this._colGroupsIndexes[cg] = [this.R + cg]; // all the same
                        }, this);
                        
                        itemCrossGroupTypes.M = [this._columnTypes[this.R]];
                        
                    } else {
                        // ~~~~ C* M*
                        
                        //    | C*~M*
                        // ---|------
                        // R* | M*
                        
                        this.measuresDirection = 'columns';
                        
                        // Updates: 
                        //   _colGroups, 
                        //   _colGroupsIndexes and 
                        //   M
                        //  _itemCrossGroupTypes.M
                        this._processEncodedColGroups(encodedColGroups);
                    }

                    this.C = this._colGroups[0].length; // may be 0!
                    
                    itemCrossGroupTypes.C = def.array.create(this.C, 0); // C discrete columns
                    
                } else {
                    this.C = this.M = 0;
                    itemCrossGroupTypes.M = itemCrossGroupTypes.C = [];
                }

            } else {
                // TODO: complete this
                // TODO: itemCrossGroupTypes
                
                /* MEASURES IN ROWS */
                
                this.measuresDirection = 'rows';

                // C = 1 (could also be more if an option to make ~ on existed)
                // R = 1 (could be more...)
                // M >= 1

                // The column index at which measure values (of each series) start
                // is the number of row components
                this.R = +this.options.measuresIndex;

                var measuresCount = this.options.measuresCount;
                if (measuresCount == null) {
                    measuresCount = 1;
                }

                // TODO: >= 1 check
                this.M = measuresCount;

                // First R columns are from row space
                // Next follows a non-relevant Measure title column
                this._colGroups = colNames.slice(this.R + 1);

                // To Array of Cells
                this._colGroups.forEach(function(colGroup, cg){
                    this._colGroups[cg] = [colGroup];
                }, this);
            }
        }
        
        // First R columns are from row space
        itemCrossGroupTypes.R = this._columnTypes.slice(0, this.R);

        // ----------------
        // The index at which the first component of
        // each cross group is placed in virtual item
        
        var seriesInRows = this.options.seriesInRows;
        
        var itemGroupIndex = this._itemCrossGroupIndex = {
            'C': !seriesInRows ? 0      : this.R,
            'R': !seriesInRows ? this.C : 0,
            'M': this.C + this.R
        };
        
        var itemTypes = this._itemTypes = new Array(this.virtualItemSize()); // R + C + M
        
        def.eachOwn(itemGroupIndex, function(groupStartIndex, crossGroup){
            itemCrossGroupTypes[crossGroup]
            .forEach(function(type, groupIndex){
                itemTypes[groupStartIndex + groupIndex] = type;
            });
        });
        
        // Logical view
        
        this._itemLogicalGroup = {
            'series':   seriesInRows ? this.R : this.C,
            'category': seriesInRows ? this.C : this.R,
            'value':    this.M
        };
        
        this._itemLogicalGroupIndex = {
            'series':   0,
            'category': this._itemLogicalGroup.series,
            'value':    this.C + this.R
        };
        
        // ----------------

        if(pvc.debug >= 3){
            pvc.log("Crosstab translator " + pvc.stringify({
                R: this.R,
                C: this.C,
                M: this.M
            }));
        }
    },

    _getCategoriesCount: function(){
        var R = this.options.categoriesCount;
        if(R != null && (!isFinite(R) || R < 0)){
            R = null;
        }
        
        if(R == null){
            // Number of consecutive discrete columns, from left
            R = def
                .query(this._columnTypes)
                .whayl(function(type){ return type === 0; }) // 0 = discrete
                .count();
            if(!R){
                // Having no R causes problems 
                // when categories are continuous
                // (in MetricDots for example).
                R = 1;
            }
        }
        
        return R;
    },
    
    _splitEncodedColGroupCell: function(colGroup){
        var values = colGroup.v;
        var labels;
        
        if(values == null){
            values = [];
        } else {
            values = values.split(this._separator);
            labels = colGroup.f;
            if(labels){
                labels = labels.split(this._separator);
            }
        }

        return values.map(function(value, index){
            return {
                v: value,
                f: labels && labels[index]
            };
        });
    },

    /**
     * Analyzes the array of encoded column groups.
     * <p>
     * Creates an array of column groups;
     * where each element of the array is 
     * an array of the column values of the group (C values).
     * </p>
     * <p>
     * In the process the number of encoded measures is determined, {@link #M}.
     * In this respect, note that not all measures need to be supplied
     * in every column group.
     * When a measure is not present, that means that the value of the measure
     * in every row is null.
     * </p>
     * <p>
     * It is assumed that the order of measures in column groups is stable.
     * So, if in one column group "measure 1" is before "measure 2",
     * then it must be also the case in every other column group.
     * This order is then used to place values in the virtual item.
     * </p>
     */
    _processEncodedColGroups: function(encodedColGroups){
        var L = encodedColGroups.length || def.assert("Must have columns"),
            R = this.R,
            colGroups = [],
            currColGroup,
            /*
             * measureName -> {
             *     groupIndex: 0, // Global order of measures within a column group
             *     index: 0       // Index (i, below) of measure's first appearance
             * }
             *
             */
            measuresInfo  = {},
            measuresInfoList = []
            ;
        
        for(var i = 0 ; i < L ; i++){
            var colGroupCell = encodedColGroups[i];
            
            var encColGroupValues = colGroupCell.v;
            var encColGroupLabels = colGroupCell.f;
            var sepIndex = encColGroupValues.lastIndexOf(this._separator);
            
            var meaName, colGroupValues, colGroupLabels;
            
            // MeasureName has precedence,
            // so we may end up with no column group value (and C = 0).
            if(sepIndex < 0){
                // C = 0
                meaName = encColGroupValues;
                encColGroupValues = '';
                colGroupValues = [];
            } else {
                meaName = encColGroupValues.substring(sepIndex + 1);
                encColGroupValues = encColGroupValues.substring(0, sepIndex);
                colGroupValues = encColGroupValues.split(this._separator);

                if(encColGroupLabels != null){
                    colGroupLabels = encColGroupLabels.split(this._separator);
                    colGroupLabels.pop(); // measure label
                }
                
                /*jshint loopfunc:true */
                colGroupValues.forEach(function(value, index){
                    var label = colGroupLabels && colGroupLabels[index];
                    colGroupValues[index] = {v: value, f: label};
                });
            }

            // New column group?
            if(!currColGroup || currColGroup.encValues !== encColGroupValues){
                currColGroup = {
                    startIndex:        i,
                    encValues:    encColGroupValues,
                    values:       colGroupValues,
                    measureNames: [meaName]
                };

                colGroups.push(currColGroup);
            } else {
                currColGroup.measureNames.push(meaName);
            }

            // Check the measure
            var currMeaIndex = (i - currColGroup.startIndex),
                meaInfo = def.getOwn(measuresInfo, meaName);
            if(!meaInfo){
                measuresInfo[meaName] = meaInfo = {
                    name: meaName,
                    groupIndex: currMeaIndex,
                    index: i,
                    type:  this._columnTypes[R + i] // Trust the type of the first column where the measure appears
                };
                measuresInfoList.push(meaInfo);
            } else if(currMeaIndex > meaInfo.groupIndex) {
                meaInfo.groupIndex = currMeaIndex;
            }
        }

        // Sort measures
        measuresInfoList.sort(function(meaInfoA, meaInfoB){
            return def.compare(meaInfoA.groupIndex, meaInfoB.groupIndex) ||
                   def.compare(meaInfoA.index, meaInfoB.index)
                   ;
        });

        // Reassign measure group indexes
        // Fill measure types
        var M = measuresInfoList.length;
        var meaTypes = new Array(M);
        this._itemCrossGroupTypes.M = meaTypes;
        
        measuresInfoList.forEach(function(meaInfoA, index){
            meaInfoA.groupIndex = index;
            meaTypes[index] = meaInfoA.type;
        });

        // Publish colgroups and colgroupIndexes, keeping only relevant information
        var CG = colGroups.length,
            colGroupsValues  = new Array(CG),
            colGroupsIndexes = new Array(CG)
            ;
        
        colGroups.map(function(colGroup, cg){
            colGroupsValues[cg] = colGroup.values;
            
            var colGroupStartIndex = colGroup.startIndex;
            
            // The index in source *line* where each of the M measures can be read
            var meaIndexes = colGroupsIndexes[cg] = new Array(M);
            colGroup.measureNames.forEach(function(meaName2, localMeaIndex){
                // The measure index in VITEM
                var meaIndex = measuresInfo[meaName2].groupIndex;
                
                // Where to read the measure in *line*?
                meaIndexes[meaIndex] = R + colGroupStartIndex + localMeaIndex;
            });
        });
        
        this._colGroups        = colGroupsValues;
        this._colGroupsIndexes = colGroupsIndexes;
        this.M = M;
    },
    
    /**
     * Called once, before {@link #execute},
     * for the translation to configure the complex type.
     *
     * @type undefined
     * @override
     */
    configureType: function(){
        // Map: Dimension Group -> Item cross-groups indexes
        if(this.measuresDirection === 'rows') {
            throw def.error.notImplemented();
        }

        this.base();
    },
    
    /** 
     * Default cross tab mapping from virtual item to dimensions. 
     * @override 
     */
    _configureTypeCore: function(){
        var me = this;
        var itemLogicalGroup = me._itemLogicalGroup;
        var itemLogicalGroupIndex = me._itemLogicalGroupIndex;
        
        var index = 0;
        var dimsReaders = [];
        
        function add(dimGroupName, level, count) {
            var crossEndIndex = itemLogicalGroupIndex[dimGroupName] + count; // exclusive
            while(count > 0) {
                var dimName = pvc.buildIndexedId(dimGroupName, level);
                if(!me.complexTypeProj.isReadOrCalc(dimName)) { // Skip name if occupied and continue with next name
                    
                    // use first available slot for auto dims readers as long as within crossIndex and crossIndex + count
                    index = me._nextAvailableItemIndex(index);
                    if(index >= crossEndIndex) {
                        // this group has no more slots available
                        return;
                    }
                    
                    dimsReaders.push({names: dimName, indexes: index});
                    
                    index++; // consume index
                    count--;
                }
                
                level++;
            }
        }
        
        /* plot2SeriesIndexes only implemented for single-series */
        var dataPartDimName = this.options.dataPartDimName;
        if(dataPartDimName && this.C === 1 && !this.complexTypeProj.isReadOrCalc(dataPartDimName)) {
            // The null test is required because plot2SeriesIndexes can be a number, a string...
            var plot2SeriesIndexes = this.options.plot2SeriesIndexes;
            if(plot2SeriesIndexes != null){
                var seriesKeys = this._colGroups.map(function(colGroup){
                    return '' + colGroup[0].v;
                });
                this._plot2SeriesKeySet = this._createPlot2SeriesKeySet(plot2SeriesIndexes, seriesKeys);
            }
        }
        
        ['series', 'category', 'value'].forEach(function(dimGroupName){
            var L = itemLogicalGroup[dimGroupName];
            if(L > 0){
                add(dimGroupName, 0, L);
            }
        });
        
        if(dimsReaders) {
            dimsReaders.forEach(this.defReader, this);
        }
        
        if(this._plot2SeriesKeySet){
            var seriesReader = this._userDimsReadersByDim.series;
            if(seriesReader) {
                var calcAxis2SeriesKeySet = def.fun.constant(this._plot2SeriesKeySet);
                this._userRead(this._dataPartGet(calcAxis2SeriesKeySet, seriesReader), dataPartDimName);
            }
        }
    }
});
/**
 * @name pvc.data.RelationalTranslationOper
 * 
 * @class Represents one translation operation, 
 * from a source matrix in relational format to 
 * an enumerable of atom arrays.
 * 
 * <p>
 * The default matrix-relational format is:
 * </p>
 * <pre>
 * ---------------------------
 *    0   |    1     |   2
 * ---------------------------
 * series | category | value
 * ---------------------------
 *    T   |     A    |   12
 *    T   |     B    |   45
 *    Q   |     A    |   11
 *    Q   |     B    |   99
 *    Z   |     B    |    3
 * </pre>
 * <p>
 * If the option <i>seriesInRows</i> is true
 * the indexes of series and categories are switched.
 * </p>
 * <p>
 * If the option <i>measuresIndexes</i> is specified,
 * additional value dimensions are created to receive the specified columns.
 * Note that these indexes may consume series and/or category indexes as well. 
 * </p>
 * <p>
 * If only two metadata columns are provided, 
 * then a dummy 'series' column, with the constant null value, is added automatically. 
 * </p>
 * 
 * @extends pvc.data.MatrixTranslationOper
 *  
 * @constructor
 * @param {pvc.BaseChart} chart The associated chart.
 * @param {pvc.data.ComplexType} complexType The complex type that will represent the translated data.
 * @param {object} source The matrix-relational array to be translated.
 * The source is not modified.
 * @param {object} [metadata] A metadata object describing the source.
 * 
 * @param {object} [options] An object with translation options.
 * See additional available options in {@link pvc.data.MatrixTranslationOper}.
 * 
 * @param {(number|string)[]|number|string} [options.measuresIndexes] 
 * An array of indexes of columns of the source matrix
 * that contain value dimensions.
 * <p>
 * Multiple 'value' dimensions ('value', 'value2', 'value3', ...) 
 * are bound in order to the specified indexes.
 * </p>
 * <p>
 * The option 'plot2SeriesIndexes' 
 * is incompatible with and 
 * takes precedence over 
 * this one.
 * </p>
 * <p>
 * The indexes can be numbers or strings that represent numbers.
 * It is also possible to specify a single index instead of an array.
 * </p>
 */
def.type('pvc.data.RelationalTranslationOper', pvc.data.MatrixTranslationOper)
.add(/** @lends pvc.data.RelationalTranslationOper# */{
    M: 0, // number of measures
    C: 0, // number of categories
    S: 0, // number of series
    
    _processMetadata: function(){
        
        this.base();
    
        var metadata = this.metadata;
        
        var J = this.J; // metadata.length
        
        // Split between series and categories
        var C = this.options.categoriesCount;
        if(C != null && (!isFinite(C) || C < 0)){
            C = 0;
        }

        var S;
        
        // Assuming duplicate valuesColIndexes is not valid
        // (v1 did not make this assumption)
        var valuesColIndexes, M;
        if(this.options.isMultiValued){
            valuesColIndexes = pvc.parseDistinctIndexArray(this.options.measuresIndexes, J - 1);
            M = valuesColIndexes ? valuesColIndexes.length : 0;
        }
        
        var D; // discrete count = D = S + C
        if(M == null){
            if(J > 0 && J <= 3 && (C == null || C === 1) && S == null){
                // V1 Stability requirement
                // Measure columns with all values = null,
                // would be detected as type string,
                // and not be chosen as measures.
                M = 1;
                valuesColIndexes = [J - 1];
                C = J >= 2 ? 1 : 0;
                S = J >= 3 ? 1 : 0;
                D = C + S;
                
            } else if(C != null &&  C >= J){
                D = J;
                C = J;
                S = 0;
                M = 0;
            } else {
                // finite C wins over M, and by last S
                var Mmax = C != null ? (J - C) : Infinity; // >= 1
                
                // colIndex has already been fixed on _processMetadata
                valuesColIndexes = def
                    .query(metadata)
                    .where(function(colDef, index){
                        return this._columnTypes[index] !== 0; // 0 = discrete
                    }, this)
                    .select(function(colDef){ return colDef.colIndex; })
                    .take(Mmax)
                    .array()
                    ;

                M = valuesColIndexes.length;
            }
        }
        
        if(D == null){
            // M wins over C
            D = J - M;
            if(D === 0){
                S = C = 0;
            } else if(C != null){
                if(C > D){
                    C = D;
                    S = 0;
                } else {
                    S = D - C;
                }
            } else {
                // Distribute between categories and series
                S = D > 1 ? 1 : 0;
                C = D - S;
            }
        }
        
        var seriesInRows = this.options.seriesInRows;
        var colGroupSpecs = [];
        if(D){
            if(S && !seriesInRows){
                colGroupSpecs.push({name: 'S', count: S});
            }
            
            if(C){
                colGroupSpecs.push({name: 'C', count: C});
            }
            
            if(S && seriesInRows){
                colGroupSpecs.push({name: 'S', count: S});
            }
        }
        
        if(M){
            colGroupSpecs.push({name: 'M', count: M});
        }
        
        var availableInputIndexes = def.range(0, J).array();
        
        // If valuesColIndexes != null, these are reserved for values
        if(valuesColIndexes){
            // Remove these indexes from available indexes
            valuesColIndexes.forEach(function(inputIndex){
                availableInputIndexes.splice(inputIndex, 1);
            });
        }
        
        // Set the fields with actual number of columns of each group
        // Assign the input indexes of each group (Layout)
        var specsByName = {};
        colGroupSpecs.forEach(function(groupSpec){
            var count = groupSpec.count;
            var name  = groupSpec.name;
            
            // Index group by name
            specsByName[name] = groupSpec;
            
            if(valuesColIndexes && name === 'M'){
                groupSpec.indexes = valuesColIndexes;
            } else {
                groupSpec.indexes = availableInputIndexes.splice(0, count);
            }
        }, this);
        
        this.M = M;
        this.S = S;
        this.C = C;
        
        // Compose the total permutation array
        // that transforms the input into the virtual item "normal form":
        // S* C* M*
        var itemPerm = [];
        ['S', 'C', 'M'].forEach(function(name){
            var groupSpec = specsByName[name];
            if(groupSpec){
                def.array.append(itemPerm, groupSpec.indexes);
            }
        });
        
        var colTypes = this._columnTypes;
        this._itemTypes = itemPerm.map(function(index){ return colTypes[index]; });
        
        // The start indexes of each column group
        this._itemCrossGroupIndex = {
            S: 0,
            C: this.S, 
            M: this.S + this.C
        };
        
        this._itemPerm = itemPerm;
        
        if(pvc.debug >= 3){
            var out = [
                "RELATIONAL TRANSLATOR MAPPING",
                pvc.logSeparator,
                "[" + 
                    colGroupSpecs.map(function(groupSpec){
                        return def.array.create(groupSpec.count, groupSpec.name).join('');
                    })
                    .join(' ') +
                "]",
                pvc.logSeparator
            ];

            pvc.log(out.join("\n"));
        }
    },
    
    /** 
     * Default cross tab mapping from virtual item to dimensions. 
     * @override 
     */
    _configureTypeCore: function(){
        var me = this;
        var index = 0;
        var dimsReaders = [];
        
        function add(dimGroupName, colGroupName, level, count) {
            var groupEndIndex = me._itemCrossGroupIndex[colGroupName] + count; // exclusive
            while(count > 0) {
                var dimName = pvc.buildIndexedId(dimGroupName, level);
                if(!me.complexTypeProj.isReadOrCalc(dimName)) { // Skip name if occupied and continue with next name
                    
                    // use first available slot for auto dims readers as long as within the group slots
                    index = me._nextAvailableItemIndex(index);
                    if(index >= groupEndIndex) {
                        // this group has no more slots available
                        return;
                    }
                    
                    dimsReaders.push({names: dimName, indexes: index});
                    
                    index++; // consume index
                    count--;
                }
                
                level++;
            }
        }
        
        if(this.S > 0){
            add('series', 'S', 0, this.S);
        }
        
        if(this.C > 0){
            add('category', 'C', 0, this.C);
        }
        
        if(this.M > 0) {
            add('value', 'M', 0, this.M);
        }

        if(dimsReaders) {
            dimsReaders.forEach(this.defReader, this);
        }
        
        // ----
        // The null test is required because plot2SeriesIndexes can be a number, a string...
        var plot2SeriesIndexes = this.options.plot2SeriesIndexes;
        if(plot2SeriesIndexes != null){
            var seriesReader = this._userDimsReadersByDim.series;
            if(seriesReader) {
                var dataPartDimName = this.options.dataPartDimName;
                this._userRead(relTransl_dataPartGet.call(this, plot2SeriesIndexes, seriesReader), dataPartDimName);
            }
        }
    },
    
    // Permutes the input rows
    _executeCore: function(){
        var dimsReaders = this._getDimensionsReaders();
        var permIndexes = this._itemPerm;
        
        return def.query(this._getItems())
                  .select(function(item){
                      
                      item = pv.permute(item, permIndexes);
                      
                      return this._readItem(item, dimsReaders);
                  }, this);
    }
});

/**
 * Obtains the dimension reader for dimension 'dataPart'.
 * 
 * @name pvc.data.RelationalTranslationOper#_dataPartGet
 * @function
 * @param {Array} plot2SeriesIndexes The indexes of series that are to be shown on the second axis. 
 * @param {function} seriesReader Dimension series atom getter.
 * @type function
 */
function relTransl_dataPartGet(plot2SeriesIndexes, seriesReader) {
    var me = this;
    
    /* Defer calculation of plot2SeriesKeySet because *data* isn't yet available. */
    function calcAxis2SeriesKeySet() {
        var atoms = {};
        var seriesKeys = def.query(me.source)
                                .select(function(item){
                                    seriesReader(item, atoms);
                                    var value = atoms.series;
                                    if(value != null && value.v != null){
                                        value = value.v;
                                    }
                                    
                                    return value || null;
                                })
                                /* distinct excludes null keys */
                                .distinct()
                                .array();

        return me._createPlot2SeriesKeySet(plot2SeriesIndexes, seriesKeys);
    }
    
    return this._dataPartGet(calcAxis2SeriesKeySet, seriesReader);
}/**
 * Initializes an atom instance.
 * 
 * @name pvc.data.Atom
 * 
 * @class An atom represents a unit of information.
 * 
 * <p>
 * To create an atom, 
 * call the corresponding dimension's
 * {@link pvc.data.Dimension#intern} method.
 * 
 * Usually this is done by a {@link pvc.data.TranslationOper}.
 * </p>
 * 
 * @property {pvc.data.Dimension} dimension The owner dimension.
 * 
 * @property {number} id
 *           A unique object identifier.
 *           
 * @property {any} rawValue The raw value from which {@link #value} is derived.
 *           <p>
 *           It is not always defined. 
 *           Values may be the result of
 *           combining multiple source values.
 *            
 *           Values may even be constant
 *           and, as such, 
 *           not be derived from 
 *           any of the source values.
 *           </p>
 * 
 * @property {any} value The typed value of the atom.
 *           It must be consistent with the corresponding {@link pvc.data.DimensionType#valueType}.
 * 
 * @property {string} label The formatted value.
 *           <p>
 *           Only the null atom can have a empty label.
 *           </p>
 *           
 * @property {string} key The value of the atom expressed as a
 *           string in a way that is unique amongst all atoms of its dimension.
 *           <p>
 *           Only the null atom has a key equal to "".
 *           </p>
 * @property {string} globalKey A semantic key that is unique across atoms of every dimensions.
 * 
 * @constructor
 * @private
 * @param {pvc.data.Dimension} dimension The dimension that the atom belongs to.
 * @param {any} value The typed value.
 * @param {string} label The formatted value.
 * @param {any} rawValue The source value.
 * @param {string} key The key.
 */
def.type('pvc.data.Atom')
.init(
function(dimension, value, label, rawValue, key) {
    this.dimension = dimension;
    this.id = (value == null ? -def.nextId() : def.nextId()); // Ensure null sorts first, when sorted by id
    this.value = value;
    this.label = label;
    if(rawValue !== undefined){
        this.rawValue = rawValue;
    }
    this.key = key;
})
.add( /** @lends pvc.data.Atom */{
    isVirtual: false,
    
    rawValue: undefined,

    /**
     * Obtains the label of the atom.
     */
    toString: function(){
        var label = this.label;
        if(label != null){
            return label;
        }
        
        label = this.value;
        return label != null ? ("" + label) : "";
    }
});


/**
 * Comparer for atom according to their id.
 */
function atom_idComparer(a, b) {
    return a.id - b.id; // works for numbers...
}

/**
 * Reverse comparer for atom according to their id.
 */
function atom_idComparerReverse(a, b) {
    return b.id - a.id; // works for numbers...
}var complex_nextId = 1;

/**
 * Initializes a complex instance.
 * 
 * @name pvc.data.Complex
 * 
 * @class A complex is a set of atoms, 
 *        of distinct dimensions,
 *        all owned by the same data.
 * 
 * @property {number} id
 *           A unique object identifier.
 * 
 * @property {number} key
 *           A semantic identifier.
 *           
 * @property {pvc.data.Data} owner
 *           The owner data instance.
 * 
 * @property {object} atoms
 *           A index of {@link pvc.data.Atom} by the name of their dimension type.
 * 
 * @constructor
 * @param {pvc.data.Complex} [source] 
 *        A complex that provides for an owner and default base atoms.
 * 
 * @param {map(string any)} [atomsByName] 
 *        A map of atoms or raw values by dimension name.
 * 
 * @param {string[]} [dimNames] The dimension names of atoms in {@link atomsByName}.
 * The dimension names in this list will be used to build 
 * the key and label of the complex.
 * When unspecified, all the dimensions of the associated complex type
 * will be used to create the key and label.
 * Null atoms are not included in the label.
 * 
 * @param {object} [atomsBase] 
 *        An object to serve as prototype to the {@link #atoms} object.
 *        <p>
 *        Atoms already present in this object are not set locally.
 *        The key and default label of a complex only contain information 
 *        from its own atoms.
 *        </p>
 *        <p>
 *        The default value is the {@link #atoms} of the argument {@link source},
 *        when specified.
 *        </p>
 */
def
.type('pvc.data.Complex')
.init(function(source, atomsByName, dimNames, atomsBase, wantLabel, calculate) {
    /*jshint expr:true */
    
    /* NOTE: this function is a hot spot and as such is performance critical */
    
    this.id = complex_nextId++;
    
    var owner;
    if(source){
        owner = source.owner;
        if(!atomsBase){
            atomsBase = source.atoms;
        }
    }
    
    this.owner = owner || this;
    this.atoms = atomsBase ? Object.create(atomsBase) : {};
	
    var hadDimNames = !!dimNames;
    if(!dimNames){
        dimNames = owner.type._dimsNames;
    }
    
    var atomsMap = this.atoms;
    var D = dimNames.length;
    var i, dimName;
    
    if(atomsByName){
        /* Fill the atoms map */
        var ownerDims = owner._dimensions;
        
        var addAtom = function(dimName, value){
            if(value != null){ // nulls are already in base proto object
                var dimension = def.getOwn(ownerDims, dimName);
                var atom = dimension.intern(value);
                if(!atomsBase || atom !== atomsBase[dimName]) { // don't add atoms already in base proto object
                    atomsMap[dimName] = atom;
                }
            }
        };
    
        if(!hadDimNames){
            for(dimName in atomsByName){
                addAtom(dimName, atomsByName[dimName]);
            }
        } else {
            for(i = 0 ; i < D ; i++){
                dimName = dimNames[i];
                addAtom(dimName, atomsByName[dimName]);
            }
        }
        
        if(calculate){
            var newAtomsByName = owner.type._calculate(this); // may be null
            for(dimName in newAtomsByName){
                if(!def.hasOwnProp.call(atomsMap, dimName)){ // not yet added
                    addAtom(dimName, newAtomsByName[dimName]);
                }
            }
        }
    }
    
    /* Build Key and Label */
    if(!D){
        this.value = null;
        this.key   = '';
        if(wantLabel){
            this.label = "";
        }
    } else if(D === 1){
        var singleAtom = atomsMap[dimNames[0]];
        this.value     = singleAtom.value;    // always typed when only one
        this.rawValue  = singleAtom.rawValue; // original
        this.key       = singleAtom.key;      // string
        if(wantLabel){
            this.label = singleAtom.label;
        }
    } else {
        var key, label;
        var labelSep = owner.labelSep;
        var keySep   = owner.keySep;
        
        for(i = 0 ; i < D ; i++){
            dimName = dimNames[i];
            var atom = atomsMap[dimName];
            
            // Add to key, null or not
            if(!i){
                key = atom.key;
            } else {
                key += keySep + atom.key;
            }
            
            // Add to label, when non-empty
            if(wantLabel){
                var atomLabel = atom.label;
                if(atomLabel){
                    if(!label){
                        label = atomLabel;
                    } else {
                        label += labelSep + atomLabel;
                    }
                }
            }
        }
        
        this.value = this.rawValue = this.key = key;
        if(wantLabel){
            this.label = label;
        }
    }
})
.add(/** @lends pvc.data.Complex# */{
    
    /**
     * The separator used between labels of dimensions of a complex.
     * Generally, it is the owner's labelSep that is used.
     */
    labelSep: " ~ ",
    
    keySep: ',',
    
    label: null,
    
    rawValue: undefined,
    
    ensureLabel: function(){
        var label = this.label;
        if(label != null){ // TODO: don't think this is being used...
            label = "";
            var labelSep = this.owner.labelSep;
            def.eachOwn(this.atoms, function(atom){
                var alabel = atom.label;
                if(alabel){
                    if(label){
                        label += labelSep + alabel;
                    } else {
                        label = alabel;
                    }
                }
            });
            
            this.label = label;
        }
        
        return label;
    },

    view: function(dimNames){
        return new pvc.data.ComplexView(this, dimNames);
    },
    
    toString : function() {
       var s = [ '' + this.constructor.typeName ];
       
       if (this.index != null) {
           s.push("#" + this.index);
       }

       this.owner.type.dimensionsNames().forEach(function(name) {
           s.push(name + ": " + pvc.stringify(this.atoms[name].value));
       }, this);

       return s.join(" ");
   }
});

pvc.data.Complex.values = function(complex, dimNames){
    var atoms = complex.atoms;
    return dimNames.map(function(dimName){
        return atoms[dimName].value;
    });
};

pvc.data.Complex.labels = function(complex, dimNames){
    var atoms = complex.atoms;
    return dimNames.map(function(dimName){
        return atoms[dimName].label;
    });
};/**
 * Initializes a complex view instance.
 * 
 * @name pvc.data.ComplexView
 * 
 * @class Represents a view of certain dimensions over a given source complex instance.
 * @extends pvc.data.Complex
 * 
 * @property {pvc.data.Complex} source The source complex instance.
 * @property {string} label The composite label of the own atoms in the view.
 * @constructor
 * @param {pvc.data.Complex} source The source complex instance.
 * @param {string[]} viewDimNames The dimensions that should be revealed by the view.
 */
def.type('pvc.data.ComplexView', pvc.data.Complex)
.init(function(source, viewDimNames){

    this.source = source;
    
    this.viewDimNames = viewDimNames;
    
    /* Collect desired source atoms */
    var sourceAtoms = source.atoms,
        ownSourceAtoms = [];

    viewDimNames.forEach(function(dimName){
        if(def.hasOwnProp.call(sourceAtoms, dimName)){
            ownSourceAtoms[dimName] = sourceAtoms[dimName];
        }
    });

    // Call base constructor
    this.base(source, ownSourceAtoms, viewDimNames, source.owner.atoms, /* wantLabel */ true);
})
.add({
    values: function(){
        return pvc.data.Complex.values(this, this.viewDimNames);
    },
    labels: function(){
        return pvc.data.Complex.labels(this, this.viewDimNames);
    }
});
/**
 * Initializes a datum instance.
 * 
 * @name pvc.data.Datum
 * 
 * @class A datum is a complex that contains atoms for all the
 * dimensions of the associated {@link #data}.
 *
 * @extends pvc.data.Complex
 * 
 * @property {boolean} isNull Indicates if the datum is a null datum.
 * <p>
 * A null datum is a datum that doesn't exist in the data source,
 * but is created for auxiliary reasons (null pattern).
 * </p>
 *
 * @property {boolean} isSelected The datum's selected state (read-only).
 * @property {boolean} isVisible The datum's visible state (read-only).
 * 
 * @constructor
 * @param {pvc.data.Data} data The data instance to which the datum belongs.
 * Note that the datum will belong instead to the owner of this data. 
 * However the datums atoms will inherit from the atoms of the specified data.
 * This is essentially to facilitate the creation of null datums.
 * @param {map(string any)} [atomsByName] A map of atoms or raw values by dimension name.
 * @param {boolean} [isNull=false] Indicates if the datum is a null datum.
 */
def.type('pvc.data.Datum', pvc.data.Complex)
.init(
function(data, atomsByName, isNull){
    
    this.base(data, atomsByName, /* dimNames */ null, /*atomsBase*/ null, /*wantLabel*/ false, /*calculate*/!isNull);
    
    if(isNull) {
        this.isNull = true;
    } // otherwise inherit prototype default value
})
.add(/** @lends pvc.data.Datum# */{
    
    isSelected: false,
    isVisible:  true,
    isNull:     false,
    
    isVirtual:  false, // like isNull, but is actually in a Data
    
    isTrend:    false,
    trendType:  null,
    
    isInterpolated: false,
    //isInterpolatedMiddle: false,
    interpolation: null,
    
    /**
     * Sets the selected state of the datum to a specified value.
     * 
     * @param {boolean} [select=true] The desired selected state.
     * 
     * @returns {boolean} true if the selected state changed, false otherwise.
     */
    setSelected: function(select){
        // Null datums are always not selected
        if(this.isNull){ return false; }
        
        // Normalize 'select'
        select = (select == null) || !!select;

        var changed = this.isSelected !== select;
        if(changed){
            if(!select){
                delete this.isSelected;
            } else {
                this.isSelected = true;
            }
            
            
            /*global data_onDatumSelectedChanged:true */
            data_onDatumSelectedChanged.call(this.owner, this, select);
        }

        return changed;
    },
    
    /**
     * Toggles the selected state of the datum.
     * 
     * @type {undefined}
     */
    toggleSelected: function(){
        return this.setSelected(!this.isSelected);
    },
    
    /**
     * Sets the visible state of the datum to a specified value.
     * 
     * @param {boolean} [visible=true] The desired visible state.
     * 
     * @returns {boolean} true if the visible state changed, false otherwise.
     */
    setVisible: function(visible){
        // Null datums are always visible
        if(this.isNull){ return false; }
        
        // Normalize 'visible'
        visible = (visible == null) || !!visible;

        var changed = this.isVisible !== visible;
        if(changed){
            this.isVisible = visible;
            //if(!this.isNull){
                /*global data_onDatumVisibleChanged:true */
                data_onDatumVisibleChanged.call(this.owner, this, visible);
            //}
        }

        return changed;
    },
    
    /**
     * Toggles the visible state of the datum.
     * 
     * @type {undefined}
     */
    toggleVisible: function(){
        return this.setVisible(!this.isVisible);
    }
});

/**
 * Called by the owner data to clear the datum's selected state (internal).
 * @name pvc.data.Datum#_deselect
 * @function
 * @type undefined
 * @private
 * 
 * @see pvc.data.Data#clearSelected
 */
function datum_deselect(){
    delete this.isSelected;
}

/**
 * Initializes a dimension instance.
 * 
 * @name pvc.data.Dimension
 * 
 * @class A dimension holds unique atoms,
 * of a given dimension type,
 * and for a given data instance.
 *
 * @property {pvc.data.Data} data The data that owns this dimension.
 * @property {pvc.data.DimensionType} type The dimension type of this dimension.
 * @property {string} name Much convenient property with the name of {@link #type}.
 * 
 * @property {pvc.data.Dimension} parent The parent dimension.
 * A root dimension has a null parent.
 * 
 * @property {pvc.data.Dimension} linkParent The link parent dimension.
 * 
 * @property {pvc.data.Dimension} root The root dimension.
 * A root dimension has itself as the value of {@link #root}.
 * 
 * @property {pvc.data.Dimension} owner The owner dimension.
 * An owner dimension is the topmost root dimension (accessible from this one).
 * An owner dimension owns its atoms, while others simply contain them.
 * The value of {@link pvc.data.Atom#dimension} is an atom's <i>owner</i> dimension.
 * 
 * @constructor
 * 
 * @param {pvc.data.Data} data The data that owns this dimension.
 * @param {pvc.data.DimensionType} type The type of this dimension.
 */
def.type('pvc.data.Dimension')
.init(function(data, type){
    /* NOTE: this function is a hot spot and as such is performance critical */
    this.data  = data;
    this.type  = type;
    this.root  = this;
    this.owner = this;
    
    var name = type.name;
    
    this.name = name;
    
    // Cache
    // -------
    // The atom id comparer ensures we keep atoms in the order they were added, 
    //  even when no semantic comparer is provided.
    // This is important, at least, to keep the visible atoms cache in the correct order.
    this._atomComparer = type.atomComparer();
    this._atomsByKey = {};
    
    if(data.isOwner()){
        // Owner
        // Atoms are interned by #intern
        this._atoms = [];
        
        dim_createVirtualNullAtom.call(this);
        
    } else {
        // Not an owner
        var parentData = data.parent;
        
        var source; // Effective parent / atoms source
        if(parentData){
            // Not a root
            source = parentData._dimensions[name];
            dim_addChild.call(source, this);
            
            this.root = data.parent.root;
        } else {
            parentData = data.linkParent;
            // A root that is not topmost
            /*jshint expr:true */
            parentData || def.assert("Data must have a linkParent");
            
            source = parentData._dimensions[name];
            dim_addLinkChild.call(source, this);
        }
        
        // Not in _atomsKey
        this._nullAtom = this.owner._nullAtom; // may be null
        
        this._lazyInit = function(){ /* captures 'source' and 'name' variable */
            this._lazyInit = null;
            
            // Collect distinct atoms in data._datums
            var datums = this.data._datums;
            var L = datums.length;
            var atomsByKey = this._atomsByKey;
            for(var i = 0 ; i < L ; i++){
                // NOTE: Not checking if atom is already added,
                // but it has no adverse side-effect.
                var atom = datums[i].atoms[name];
                atomsByKey[atom.key] = atom;
            }
            
            // Filter parentEf dimension's atoms; keeps order.
            this._atoms = source.atoms().filter(function(atom){
                return def.hasOwnProp.call(atomsByKey, atom.key);
            });
        };
    }
})
.add(/** @lends pvc.data.Dimension# */{
    
    parent: null,
    
    linkParent: null,
    
    /**
     * The array of child dimensions.
     * @type pvc.data.Dimension[] 
     */
    _children: null,
    
    /**
     * The array of link child dimensions.
     * @type pvc.data.Dimension[] 
     */
    _linkChildren: null,
    
    /**
     * A map of the contained atoms by their {@link pvc.data.Atom#key} property.
     * 
     * Supports the intern(...), atom(.), and the control of the visible atoms cache.
     *
     * @type object
     */
    _atomsByKey: null,
    
    /**
     * A map of the count of visible datums per atom {@link pvc.data.Atom#key} property.
     *
     * @type object
     */
    _atomVisibleDatumsCount: null, 
    
    /** 
     * Indicates if the object has been disposed.
     * 
     * @type boolean
     * @private 
     */
    _disposed: false,

    /**
     * The atom with a null value.
     *
     * @type pvc.data.Atom
     * @private
     */
    _nullAtom: null,
    
    /**
     * The virtual null atom.
     *
     * <p>
     * This atom exists to resolve situations 
     * where a null atom does not exist in the loaded data.
     * When a null <i>datum</i> is built, it may not specify
     * all dimensions. When such an unspecified dimension
     * is accessed the virtual null atom is returned by 
     * lookup of the atoms prototype chain (see {@link pvc.data.Data#_atomsBase}.
     * </p>
     * 
     * @type pvc.data.Atom
     * @private
     */
    _virtualNullAtom: null,
    
    /**
     * Cache of sorted visible and invisible atoms.
     * A map from visible state to {@link pvc.data.Atom[]}.
     * <p>
     * Cleared whenever any atom's "visible state" changes.
     * </p>
     * 
     * @type object
     * @private
     */
    _visibleAtoms: null, 
    
    /**
     * Cache of sorted visible and invisible indexes.
     * A map from visible state to {@link number[]}.
     * <p>
     * Cleared whenever any atom's "visible state" changes.
     * </p>
     * 
     * @type object
     * @private
     */
    _visibleIndexes: null,
    
    /**
     * Cache of the dimension type's normal order atom comparer.
     * 
     * @type function
     * @private
     */
    _atomComparer: null,
    
    /**
     * The ordered array of contained atoms.
     * <p>
     * The special null atom, if existent, is the first item in the array.
     *</p>
     *<p>
     * On a child dimension it is a filtered version 
     * of the parent's array, 
     * and thus has the same atom relative order.
     * 
     * In a link child dimension it is copy
     * of the link parent's array.
     * </p>
     * 
     * @type pvc.data.Atom[]
     * @see #_nullAtom
     */
    _atoms: null,

    /**
     * An object with cached results of the {@link #sum} method.
     *
     * @type object
     */
    _sumCache: null,

    /**
     * Obtains the number of atoms contained in this dimension.
     * 
     * <p>
     * Consider calling this method on the root or owner dimension.
     * </p>
     *
     * @returns {Number} The number of contained atoms.
     *
     * @see pvc.data.Dimension#root
     * @see pvc.data.Dimension#owner
     */
    count: function(){
        if(this._lazyInit) { this._lazyInit(); }
        return this._atoms.length;
    },
    
    /**
     * Indicates if an atom belonging to this dimension 
     * is considered visible in it.
     * 
     * <p>
     * An atom is considered visible in a dimension
     * if there is at least one datum of the dimension's data
     * that has the atom and is visible.
     * </p>
     *
     * @param {pvc.data.Atom} atom The atom of this dimension whose visible state is desired.
     * 
     * @type boolean
     */
    isVisible: function(atom){
        if(this._lazyInit) { this._lazyInit(); }
        
        // <Debug>
        /*jshint expr:true */
        def.hasOwn(this._atomsByKey, atom.key) || def.assert("Atom must exist in this dimension.");
        // </Debug>
        
        return dim_getVisibleDatumsCountMap.call(this)[atom.key] > 0;
    },
    
    /**
     * Obtains the atoms contained in this dimension,
     * possibly filtered.
     * 
     * <p>
     * Consider calling this method on the root or owner dimension.
     * </p>
     * 
     * @param {Object} [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.visible=null] 
     *      Only considers atoms that  
     *      have the specified visible state.
     * 
     * @returns {pvc.data.Atom[]} An array with the requested atoms.
     * Do <b>NOT</b> modify the returned array.
     * 
     * @see pvc.data.Dimension#root
     * @see pvc.data.Dimension#owner
     */
    atoms: function(keyArgs){
        if(this._lazyInit) { this._lazyInit(); }
        
        var visible = def.get(keyArgs, 'visible');
        if(visible == null){
            return this._atoms;
        }
        
        visible = !!visible;
        
        /*jshint expr:true */
        this._visibleAtoms || (this._visibleAtoms = {});
        
        return this._visibleAtoms[visible] || 
               (this._visibleAtoms[visible] = dim_calcVisibleAtoms.call(this, visible));
    },
    
    /**
     * Obtains the local indexes of all, visible or invisible atoms.
     * 
     * @param {Object} [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.visible=null] 
     *      Only considers atoms that 
     *      have the specified visible state.
     * 
     * @type number[]
     */
    indexes: function(keyArgs){
        if(this._lazyInit) { this._lazyInit(); }
        
        var visible = def.get(keyArgs, 'visible');
        if(visible == null) {
            // Not used much so generate each time
            return pv.range(0, this._atoms.length);
        }
        
        visible = !!visible;
        
        /*jshint expr:true */
        this._visibleIndexes || (this._visibleIndexes = {});
        return this._visibleIndexes[visible] || 
               (this._visibleIndexes[visible] = dim_calcVisibleIndexes.call(this, visible));
    },
    
    /**
     * Obtains an atom that represents the specified value, if one exists.
     * 
     * @param {any} value A value of the dimension type's {@link pvc.data.DimensionType#valueType}.
     * 
     * @returns {pvc.data.Atom} The existing atom with the specified value, or null if there isn't one.
     */
    atom: function(value){
        if(value == null || value === '') {
            return this._nullAtom; // may be null
        }
        
        if(value instanceof pvc.data.Atom) {
            return value;
        }
        
        if(this._lazyInit) { this._lazyInit(); }

        var key = this.type._key ? this.type._key.call(null, value) : value;
        return this._atomsByKey[key] || null; // undefined -> null
    },
    
    /**
     * Obtains the minimum and maximum atoms of the dimension,
     * possibly filtered.
     * 
     * <p>
     * Assumes that the dimension type is comparable.
     * If not the result will coincide with "first" and "last".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * <p>
     * Consider calling this method on the root or owner dimension.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link #atoms} for additional keyword arguments. 
     * @param {boolean} [keyArgs.abs=false] Determines if the extent should consider the absolute value.
     * 
     * @returns {object} 
     * An extent object with 'min' and 'max' properties, 
     * holding the minimum and the maximum atom, respectively,
     * if at least one atom satisfies the selection;
     * undefined otherwise.
     * 
     * @see #root
     * @see #owner
     * @see #atoms
     * @see pvc.data.DimensionType.isComparable
     */
    extent: function(keyArgs){
        // Assumes atoms are sorted (null, if existent is the first).
        var atoms  = this.atoms(keyArgs);
        var L = atoms.length;
        if(!L){ return undefined; }
        
        var offset = this._nullAtom && atoms[0].value == null ? 1 : 0;
        var countWithoutNull = L - offset;
        if(countWithoutNull > 0){
            var min = atoms[offset];
            var max = atoms[L - 1];
            
            // ------------------
            var tmp;
            if(min !== max && def.get(keyArgs, 'abs', false)){
                var minSign = min.value < 0 ? -1 : 1;
                var maxSign = max.value < 0 ? -1 : 1;
                if(minSign === maxSign){
                    if(maxSign < 0){
                        tmp = max;
                        max = min;
                        min = tmp;
                    }
                } else if(countWithoutNull > 2){
                    // There's a third atom in between
                    // min is <= 0
                    // max is >= 0
                    // and, of course, min !== max
                    
                    // One of min or max has the biggest abs value
                    if(max.value < -min.value){
                        max = min;
                    }
                    
                    // The smallest atom is the one in atoms that is closest to 0, possibly 0 itself
                    var zeroIndex = def.array.binarySearch(atoms, 0, this.type.comparer(), function(a){ return a.value; });
                    if(zeroIndex < 0){
                        zeroIndex = ~zeroIndex;
                        // Not found directly. 
                        var negAtom = atoms[zeroIndex - 1];
                        var posAtom = atoms[zeroIndex];
                        if(-negAtom.value < posAtom.value){
                            min = negAtom;
                        } else {
                            min = posAtom;
                        }
                    } else {
                        // Zero was found
                        // It is the minimum
                        min = atoms[zeroIndex];
                    }
                } else if(max.value < -min.value){
                    // min is <= 0
                    // max is >= 0
                    // and, of course, min !== max
                    tmp = max;
                    max = min;
                    min = tmp;
                }
            }
            
            // -----------------
            
            return {min: min, max: max};
        }
        
        return undefined;
    },
    
    /**
     * Obtains the minimum atom of the dimension,
     * possibly after filtering.
     * 
     * <p>
     * Assumes that the dimension type is comparable.
     * If not the result will coincide with "first".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * <p>
     * Consider calling this method on the root or owner dimension.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link #atoms} for a list of available filtering keyword arguments. 
     *
     * @returns {pvc.data.Atom} The minimum atom satisfying the selection;
     * undefined if none.
     * 
     * @see #root
     * @see #owner
     * @see #atoms
     * @see pvc.data.DimensionType.isComparable
     */
    min: function(keyArgs){
        // Assumes atoms are sorted.
        var atoms = this.atoms(keyArgs);
        var L = atoms.length;
        if(!L){ return undefined; }
        
        var offset = this._nullAtom && atoms[0].value == null ? 1 : 0;
        return (L > offset) ? atoms[offset] : undefined;
    },
    
    /**
     * Obtains the maximum atom of the dimension,
     * possibly after filtering.
     * 
     * <p>
     * Assumes that the dimension type is comparable.
     * If not the result will coincide with "last".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * <p>
     * Consider calling this method on the root or owner dimension.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link #atoms} for a list of available filtering keyword arguments. 
     *
     * @returns {pvc.data.Atom} The maximum atom satisfying the selection;
     * undefined if none.
     * 
     * @see #root
     * @see #owner
     * @see #atoms
     * 
     * @see pvc.data.DimensionType.isComparable
     */
    max: function(keyArgs){
        // Assumes atoms are sorted.
        var atoms = this.atoms(keyArgs);
        var L = atoms.length;
        
        return L && atoms[L - 1].value != null ? atoms[L - 1] : undefined;
    },
    
    /**
     * Obtains the sum of this dimension's values over all datums of the data,
     * possibly after filtering.
     * 
     * <p>
     * Assumes that the dimension type {@link pvc.data.DimensionType#valueType} is "Number".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link pvc.data.Data#datums} for a list of available filtering keyword arguments. 
     *
     * @param {boolean} [keyArgs.abs=false] Indicates if it is the sum of the absolute value that is desired.
     * @param {boolean} [keyArgs.zeroIfNone=true] Indicates that zero should be returned when there are no datums
     * or no datums with non-null values.
     * When <tt>false</tt>, <tt>null</tt> is returned, in that situation.
     *
     * @returns {number} The sum of considered datums or <tt>0</tt> or <tt>null</tt>, if none.
     * 
     * @see #root
     * @see #owner
     * @see #atoms
     */
    sum: function(keyArgs){
        var isAbs = !!def.get(keyArgs, 'abs', false),
            zeroIfNone = def.get(keyArgs, 'zeroIfNone', true),
            key   = dim_buildDatumsFilterKey(keyArgs) + ':' + isAbs;
              
        var sum = def.getOwn(this._sumCache, key);
        if(sum === undefined) {
            var dimName = this.name;
            sum = this.data.datums(null, keyArgs).reduce(function(sum2, datum){
                var value = datum.atoms[dimName].value;
                if(isAbs && value < 0){ // null < 0 is false
                    value = -value;
                }

                return sum2 != null ? (sum2 + value) : value; // null preservation
            },
            null);
            
            (this._sumCache || (this._sumCache = {}))[key] = sum;
        }
        
        return zeroIfNone ? (sum || 0) : sum;
    },
    
    /**
     * Obtains the percentage of a specified atom or value,
     * over the <i>sum</i> of the absolute values of a specified datum set.
     * 
     * <p>
     * Assumes that the dimension type {@link pvc.data.DimensionType#valueType} is "Number".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * @param {pvc.data.Atom|any} [atomOrValue] The atom or value on which to calculate the percent.
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link pvc.data.Dimension#sum} for a list of available filtering keyword arguments. 
     *
     * @returns {number} The calculated percentage.
     * 
     * @see #root
     * @see #owner
     */
    percent: function(atomOrValue, keyArgs){
        var value = (atomOrValue instanceof pvc.data.Atom) ? atomOrValue.value : atomOrValue;
        if(!value) { // nully or zero
            return 0;
        }
        // if value != 0 => sum != 0, but JIC, we test for not 0...
        var sum = this.sum(def.create(keyArgs, {abs: true}));
        return sum ? (Math.abs(value) / sum) : 0;
    },
    
    /**
     * Obtains the percentage of the local <i>sum</i> of a specified selection,
     * over the <i>sum</i> of the absolute values of an analogous selection in the parent data.
     * 
     * <p>
     * Assumes that the dimension type {@link pvc.data.DimensionType#valueType} is "Number".
     * </p>
     * 
     * <p>
     * Does not consider the null atom.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link pvc.data.Dimension#sum} for a list of available filtering keyword arguments. 
     *
     * @returns {number} The calculated percentage.
     * 
     * @see #root
     * @see #owner
     */
    percentOverParent: function(keyArgs){
        var value = this.sum(keyArgs); // normal sum
        if(!value) { // nully or zero
            return 0;
        }
        
        // if value != 0 => sum != 0, but JIC, we test for not 0...
        var parentData = this.data.parent;
        if(!parentData) {
            return 0;
        }

        // The following would not work because, in each group,
        //  abs would not be used...
        //var sum = parentData.dimensions(this.name).sum();

        var sum = parentData.dimensionsSumAbs(this.name, keyArgs);

        return sum ? (Math.abs(value) / sum) : 0;
    },
    
    
    format: function(value, sourceValue){
        return "" + (this.type._formatter ? this.type._formatter.call(null, value, sourceValue) : "");
    },
    
    /**
     * Obtains an atom that represents the specified sourceValue,
     * creating one if one does not yet exist.
     * 
     * <p>
     * Used by a translation to 
     * obtain atoms of a dimension for raw values of source items.
     * </p>
     * <p>
     * If this method is not called on an owner dimension,
     * and if the requested values isn't locally present,
     * the call is recursively forwarded to the dimension's
     * parent or link parent until the atom is found.
     * Ultimately, if the atom does not yet exist, 
     * it is created in the owner dimension. 
     * </p>
     * <p>
     * An empty string value is considered equal to a null value. 
     * </P>
     * @param {any | pvc.data.Atom} sourceValue The source value.
     * @param {boolean} [isVirtual=false] Indicates that 
     * the (necessarily non-null) atom is the result of interpolation or regression.
     * 
     * @type pvc.data.Atom
     */
    intern: function(sourceValue, isVirtual){
        // NOTE: This function is performance critical!
      
        // The null path and the existing atom path 
        // are as fast and direct as possible
        
        // - NULL -
        if(sourceValue == null || sourceValue === '') {
            return this._nullAtom || dim_createNullAtom.call(this, sourceValue);
        }
        
        if(sourceValue instanceof pvc.data.Atom){
            if(sourceValue.dimension !== this){
                throw def.error.operationInvalid("Atom is of a different dimension.");
            }
            
            return sourceValue;
        }
        
        var value, label;
        var type = this.type;
        
        // Is google table style cell {v: , f: } ?
        if(typeof sourceValue === 'object' && ('v' in sourceValue)){
            // Get info and get rid of the cell
            label = sourceValue.f;
            sourceValue = sourceValue.v;
        }
        
        // - CONVERT - 
        if(!isVirtual){
            var converter = type._converter;
            value = converter ? converter(sourceValue) : sourceValue;
            if(value == null || value === '') {
                // Null after all
                return this._nullAtom || dim_createNullAtom.call(this, sourceValue);
            }
        } else {
            value = sourceValue;
        }
        
        // - CAST -
        // Any cast function?
        var cast = type.cast;
        if(cast) {
            value = cast(value);
            if(value == null || value === ''){
                // Null after all (normally a cast failure)
                return this._nullAtom || dim_createNullAtom.call(this);
            }
        }
        
        // - KEY -
        var keyFun = type._key;
        var key = '' + (keyFun ? keyFun(value) : value);
        // <Debug>
        /*jshint expr:true */
        key || def.fail.operationInvalid("Only a null value can have an empty key.");
        // </Debug>
        
        // - ATOM -
        var atom = this._atomsByKey[key];
        if(atom){
            if(!isVirtual && atom.isVirtual){
                delete atom.isVirtual;
            }
            return atom;
        }
        
        return dim_createAtom.call(
                   this,
                   type,
                   sourceValue,
                   key,
                   value,
                   label,
                   isVirtual);
    },
    
    /**
     * Disposes the dimension and all its children.
     */
    dispose: function(){
        if(!this._disposed){
            /*global data_disposeChildList:true */
            data_disposeChildList(this._children,     'parent');
            data_disposeChildList(this._linkChildren, 'linkParent');
            
            // myself
            
            if(this.parent)     { dim_removeChild.call(this.parent, this); }
            if(this.linkParent) { dim_removeLinkChild.call(this.linkParent, this); }
            
            dim_clearVisiblesCache.call(this);
            
            this._lazyInit  = null;
            
            this._atoms = 
            this._nullAtom = 
            this._virtualNullAtom = null;
            
            this._disposed = true;
        }
    }
});

/**
 * Creates an atom, 
 * in the present dimension if it is the owner dimension,
 * or delegates the creation to its parent, or linked parent dimension.
 * 
 * The atom must not exist in the present dimension.
 * 
 * @name pvc.data.Dimension#_createAtom
 * @function
 * @param {pvc.data.DimensionType} type The dimension type of this dimension.
 * @param {any} sourceValue The source value.
 * @param {string} key The key of the value.
 * @param {any} value The typed value.
 * @param {string} [label] The label, if it is present directly
 * in {@link sourceValue}, in Google format.
 * @type pvc.data.Atom
 */
function dim_createAtom(type, sourceValue, key, value, label, isVirtual){
    var atom;
    if(this.owner === this){
        // Create the atom
        
        // - LABEL -
        if(label == null){
            var formatter = type._formatter;
            if(formatter){
                label = formatter(value, sourceValue);
            } else {
                label = value;
            }
        }

        label = "" + label; // J.I.C.
        
        if(!label && pvc.debug >= 2){
            pvc.log("Only the null value should have an empty label.");
        }
        
        // - ATOM! -
        atom = new pvc.data.Atom(this, value, label, sourceValue, key);
        if(isVirtual){
            atom.isVirtual = true;
        }
    } else {
        var source = this.parent || this.linkParent;
        atom = source._atomsByKey[key] ||
               dim_createAtom.call(
                    source, 
                    type, 
                    sourceValue, 
                    key, 
                    value, 
                    label,
                    isVirtual);
    }
        
    // Insert atom in order (or at the end when !_atomComparer)
    def.array.insert(this._atoms, atom, this._atomComparer);
    
    dim_clearVisiblesCache.call(this);
    
    this._atomsByKey[key] = atom;
    
    return atom;
}

/**
 * Ensures that the specified atom exists in this dimension.
 * The atom must have been created in a dimension of this dimension tree.
 * 
 * If the virtual null atom is found it is replaced by the null atom,
 * meaning that, after all, the null is really present in the data.
 * 
 * @param {pvc.data.Atom} atom the atom to intern.
 * 
 * @name pvc.data.Dimension#_internAtom
 * @function
 * @type pvc.data.Atom
 */
function dim_internAtom(atom){
    var key = atom.key;
    
    // Root load will fall in this case
    if(atom.dimension === this){
        /*jshint expr:true */
        (this.owner === this) || def.assert("Should be an owner dimension");
        
        if(!key && atom === this._virtualNullAtom){
            /* This indicates that there is a dimension for which 
             * there was no configured reader, 
             * so nulls weren't read.
             * 
             * We will register the real null, 
             * and the virtual null atom will not show up again,
             * because it appears through the prototype chain
             * as a default value.
             */
            atom = this.intern(null);
        }
        
        return atom;
    }
    
    if(!this._lazyInit){
        // Else, not yet initialized, so there's no need to add the atom now
        var localAtom = this._atomsByKey[key];
        if(localAtom){
            if(localAtom !== atom){
                throw def.error.operationInvalid("Atom is from a different root data.");
            }
            
            return atom;
        }
        
        if(this.owner === this) {
            // Should have been created in a dimension along the way.
            throw def.error.operationInvalid("Atom is from a different root data.");
        }
    }
    
    dim_internAtom.call(this.parent || this.linkParent, atom);
    
    if(!this._lazyInit){
        // Insert atom in order (or at the end when !_atomComparer)
        this._atomsByKey[key] = atom;
        
        if(!key){
            this._nullAtom = atom;
            this._atoms.unshift(atom);
        } else {
            def.array.insert(this._atoms, atom, this._atomComparer);
        }
        
        dim_clearVisiblesCache.call(this);
    }
    
    return atom;
}

/**
 * Builds a key string suitable for identifying a call to {@link pvc.data.Data#datums}
 * with no where specification.
 *
 * @name pvc.data.Dimension#_buildDatumsFilterKey
 * @function
 * @param {object} [keyArgs] The keyword arguments used in the call to {@link pvc.data.Data#datums}.
 * @type string
 */
function dim_buildDatumsFilterKey(keyArgs){
    var visible  = def.get(keyArgs, 'visible'),
        selected = def.get(keyArgs, 'selected');
    return (visible == null ? null : !!visible) + ':' + (selected == null ? null : !!selected);
}

/**
 * Creates the null atom if it isn't created yet.
 * 
 * @name pvc.data.Dimension#_createNullAtom
 * @function
 * @param {any} [sourceValue] The source value of null. Can be used to obtain the null format.
 * @type undefined
 * @private
 */
function dim_createNullAtom(sourceValue){
    var nullAtom = this._nullAtom;
    if(!nullAtom){
        if(this.owner === this){
            var typeFormatter = this.type._formatter;
            var label = "" + (typeFormatter ? typeFormatter.call(null, null, sourceValue) : "");
            
            nullAtom = new pvc.data.Atom(this, null, label, null, '');
            
            this.data._atomsBase[this.name] = nullAtom; 
        } else {
            // Recursively set the null atom, up the parent/linkParent chain
            // until reaching the owner (root) dimension.
            nullAtom = dim_createNullAtom.call(this.parent || this.linkParent, sourceValue);
        }
        
        this._atomsByKey[''] = this._nullAtom = nullAtom;
        
        // The null atom is always in the first position
        this._atoms.unshift(nullAtom);
    }
    
    return nullAtom;
}

/**
 * Creates the virtual null atom if it isn't created yet.
 * 
 * @name pvc.data.Dimension#_createNullAtom
 * @function
 * @type undefined
 * @private
 */
function dim_createVirtualNullAtom(){
    // <Debug>
    /*jshint expr:true */
    (this.owner === this) || def.assert("Can only create atoms on an owner dimension.");
    // </Debug>
    
    if(!this._virtualNullAtom){
        var label = "" + (this.type._formatter ? this.type._formatter.call(null, null, null) : "");
        
        this._virtualNullAtom = new pvc.data.Atom(this, null, label, null, '');

        this.data._atomsBase[this.name] = this._virtualNullAtom; 
    }
    
    return this._virtualNullAtom;
}

/**
 * Uninternalizes the specified atom from the dimension (internal).
 * 
 * @name pvc.data.Dimension#_unintern
 * @function
 * @param {pvc.data.Atom} The atom to uninternalize.
 * @type undefined
 * @private
 * @internal
 */
function dim_unintern(atom){
    // <Debug>
    /*jshint expr:true */
    (this.owner === this) || def.assert("Can only unintern atoms on an owner dimension.");
    (atom && atom.dimension === this) || def.assert("Not an interned atom");
    // </Debug>
    
    if(atom === this._virtualNullAtom){
        return;
    }
    
    // Remove the atom
    var key = atom.key;
    if(this._atomsByKey[key] === atom){
        def.array.remove(this._atoms, atom, this._atomComparer);
        delete this._atomsByKey[key];
        
        if(!key){
            delete this._nullAtom;
            this.data._atomsBase[this.name] = this._virtualNullAtom;
        }
    }
    
    dim_clearVisiblesCache.call(this);
}

function dim_uninternUnvisitedAtoms(){
    // <Debug>
    /*jshint expr:true */
    (this.owner === this) || def.assert("Can only unintern atoms of an owner dimension.");
    // </Debug>
    
    var atoms = this._atoms;
    if(atoms){
        var atomsByKey = this._atomsByKey;
        var i = 0;
        var L = atoms.length;
        while(i < L){ 
            var atom = atoms[i];
            if(atom.visited){
                delete atom.visited;
                i++;
            } else if(atom !== this._virtualNullAtom) {
                // Remove the atom
                atoms.splice(i, 1);
                L--;
                
                var key = atom.key;
                delete atomsByKey[key];
                if(!key){
                    delete this._nullAtom;
                    this.data._atomsBase[this.name] = this._virtualNullAtom;
                }
            }
        }
        
        dim_clearVisiblesCache.call(this);
    }
}

function dim_uninternVirtualAtoms(){
    // This assumes that this same function has been called on child/link child dimensions
    var atoms = this._atoms;
    if(atoms){
        var atomsByKey = this._atomsByKey;
        var i = 0;
        var L = atoms.length;
        var removed;
        while(i < L){ 
            var atom = atoms[i];
            if(!atom.isVirtual){
                i++;
            } else {
                // Remove the atom
                atoms.splice(i, 1);
                L--;
                removed = true;
                var key = atom.key || def.assert("Cannot be the null or virtual null atom.");
                delete atomsByKey[key];
            }
        }
        
        if(removed){
            dim_clearVisiblesCache.call(this);
        }
    }
}

/**
 * Clears all caches affected by datum/atom visibility.
 * 
 * @name pvc.data.Dimension#_clearVisiblesCache
 * @function
 * @type undefined
 * @private
 * @internal
 */
function dim_clearVisiblesCache(){
    this._atomVisibleDatumsCount =
    this._sumCache =
    this._visibleAtoms = 
    this._visibleIndexes = null;
}

/**
 * Called by a dimension's data when its datums have changed.
 * 
 * @name pvc.data.Dimension#_onDatumsChanged
 * @function
 * @type undefined
 * @private
 * @internal
 */
function dim_onDatumsChanged(){
    dim_clearVisiblesCache.call(this);
}

/**
 * Adds a child dimension.
 * 
 * @name pvc.data.Dimension#_addChild
 * @function
 * @param {pvc.data.Dimension} child The child to add.
 * @type undefined
 * @private
 */
function dim_addChild(child){
    /*global data_addColChild:true */
    data_addColChild(this, '_children', child, 'parent');
    
    child.owner = this.owner;
}

/**
 * Removes a child dimension.
 *
 * @name pvc.data.Dimension#_removeChild
 * @function
 * @param {pvc.data.Dimension} child The child to remove.
 * @type undefined
 * @private
 */
function dim_removeChild(child){
    /*global data_removeColChild:true */
    data_removeColChild(this, '_children', child, 'parent');
}

/**
 * Adds a link child dimension.
 * 
 * @name pvc.data.Dimension#_addLinkChild
 * @function
 * @param {pvc.data.Dimension} child The link child to add.
 * @type undefined
 * @private
 */
function dim_addLinkChild(linkChild){
    data_addColChild(this, '_linkChildren', linkChild, 'linkParent');
    
    linkChild.owner = this.owner;
}

/**
 * Removes a link child dimension.
 *
 * @name pvc.data.Dimension#_removeLinkChild
 * @function
 * @param {pvc.data.Dimension} linkChild The child to remove.
 * @type undefined
 * @private
 */
function dim_removeLinkChild(linkChild){
    data_removeColChild(this, '_linkChildren', linkChild, 'linkParent');
}

/**
 * Called by the data of this dimension when 
 * the visible state of a datum has changed. 
 * 
 * @name pvc.data.Dimension#_onDatumVisibleChanged
 * @function
 * @type undefined
 * @private
 * @internal
 */
function dim_onDatumVisibleChanged(datum, visible) {
    var map;
    if(!this._disposed && (map = this._atomVisibleDatumsCount)) {
        var atom = datum.atoms[this.name],
            key = atom.key;
        
        // <Debug>
        /*jshint expr:true */
        def.hasOwn(this._atomsByKey, key) || def.assert("Atom must exist in this dimension.");
        // </Debug>
        
        var count = map[key];
        
        // <Debug>
        (visible || (count > 0)) || def.assert("Must have had accounted for at least one visible datum."); 
        // </Debug>
        
        map[key] = (count || 0) + (visible ? 1 : -1);
        
        // clear dependent caches
        this._visibleAtoms =
        this._sumCache = 
        this._visibleIndexes = null;
    }
}

/**
 * Obtains the map of visible datums count per atom, 
 * creating the map if necessary.
 * 
 * @name pvc.data.Dimension#_getVisibleDatumsCountMap
 * @function
 * @type undefined
 * @private
 */
function dim_getVisibleDatumsCountMap() {
    var map = this._atomVisibleDatumsCount;
    if(!map) {
        map = {};
        
        this.data.datums(null, {visible: true}).each(function(datum){
            var atom = datum.atoms[this.name],
                key  = atom.key;
            map[key] = (map[key] || 0) + 1;
        }, this);
        
        this._atomVisibleDatumsCount = map;
    }
    
    return map;
}

/**
 * Calculates the list of indexes of visible or invisible atoms.
 * <p>
 * Does not include the null atom.
 * </p>
 * 
 * @name pvc.data.Dimension#_calcVisibleIndexes
 * @function
 * @param {boolean} visible The desired atom visible state.
 * @type number[]
 * @private
 */
function dim_calcVisibleIndexes(visible){
    var indexes = [];
    
    this._atoms.forEach(function(atom, index){
        if(this.isVisible(atom) === visible) {
            indexes.push(index);
        }
    }, this);
    
    return indexes;
}

/**
 * Calculates the list of visible or invisible atoms.
 * <p>
 * Does not include the null atom.
 * </p>
 * 
 * @name pvc.data.Dimension#_calcVisibleAtoms
 * @function
 * @param {boolean} visible The desired atom visible state.
 * @type number[]
 * @private
 */
function dim_calcVisibleAtoms(visible){
    return def.query(this._atoms)
            .where(function(atom){ return this.isVisible(atom) === visible; }, this)
            .array();
}
/**
 * Initializes a data instance.
 * 
 * @name pvc.data.Data
 * 
 * @class A data represents a set of datums of the same complex type {@link #type}.
 * <p>
 * A data <i>may</i> have a set of atoms that are shared by all of its datums. 
 * In that case, the {@link #atoms} property holds those atoms.
 * </p>
 * <p>
 * A data has one dimension per dimension type of the complex type {@link #type}.
 * Each holds information about the atoms of it's type in this data.
 * Dimensions are obtained by calling {@link #dimensions}.
 * </p>
 * <p>
 * A data may have child data instances.
 * </p>
 * 
 * @extends pvc.data.Complex
 * 
 * @borrows pv.Dom.Node#visitBefore as #visitBefore
 * @borrows pv.Dom.Node#visitAfter as #visitAfter
 * 
 * @borrows pv.Dom.Node#nodes as #nodes
 * @borrows pv.Dom.Node#firstChild as #firstChild
 * @borrows pv.Dom.Node#lastChild as #lastChild
 * @borrows pv.Dom.Node#previousSibling as #previousSibling
 * @borrows pv.Dom.Node#nextSibling as #nextSibling
 * 
 * @property {pvc.data.ComplexType} type The type of the datums of this data.
 * 
 * @property {pvc.data.Data} root The root data. 
 * The {@link #root} of a root data is itself.
 * 
 * @property {pvc.data.Data} parent The parent data. 
 * A root data has a no parent.
 * 
 * @property {pvc.data.Data} linkParent The link parent data.
 * 
 * @property {Number} depth The depth of the data relative to its root data.
 * @property {string} label The composite label of the (common) atoms in the data.
 * 
 * @property {string} absLabel The absolute label of the data; 
 * a composition of all labels up to the root data.
 * 
 * @property {number} absKey
 *           The absolute semantic identifier;
 *           a composition of all keys up to the root data.
 * 
 * @constructor
 * @param {object} keyArgs Keyword arguments
 * @param {pvc.data.Data}   [keyArgs.parent]      The parent data.
 * @param {pvc.data.Data}   [keyArgs.linkParent]  The link parent data.
 * @param {map(string union(any pvc.data.Atom))} [keyArgs.atoms] The atoms shared by contained datums.
 * @param {string[]} [keyArgs.dimNames] The dimension names of atoms in {@link keyArgs.atoms}.
 * This argument must be specified whenever {@link keyArgs.atoms} is.
 * @param {pvc.data.Datum[]|def.Query} [keyArgs.datums] The contained datums array or enumerable.
 * @param {pvc.data.Data}    [keyArgs.owner] The owner data.
 * The topmost root data is its own owner.
 * An intermediate root data must specify its owner data.
 * 
 * @param {pvc.data.ComplexType} [keyArgs.type] The complex type.
 * Required when no parent or owner are specified.
 * 
 * @param {number} [index=null] The index at which to insert the child in its parent or linked parent.
 */
def.type('pvc.data.Data', pvc.data.Complex)
.init(function(keyArgs){
    /* NOTE: this function is a hot spot and as such is performance critical */
    
    /*jshint expr:true*/
    keyArgs || def.fail.argumentRequired('keyArgs');
    
    this._visibleDatums = new def.Map();
    
    var owner,
        atoms,
        atomsBase,
        dimNames,
        datums,
        index,
        parent = this.parent = keyArgs.parent || null;
    if(parent){
        // Not a root
        this.root  = parent.root;
        this.depth = parent.depth + 1;
        this.type  = parent.type;
        datums     = keyArgs.datums || def.fail.argumentRequired('datums');
        
        owner = parent.owner;
        atoms     = keyArgs.atoms   || def.fail.argumentRequired('atoms');
        dimNames  = keyArgs.dimNames|| def.fail.argumentRequired('dimNames');
        atomsBase = parent.atoms;
    } else {
        // Root (topmost or not)
        this.root = this;
        // depth = 0
        
        dimNames = [];
        
        var linkParent = keyArgs.linkParent || null;
        if(linkParent){
            // A root that is not topmost - owned, linked
            owner = linkParent.owner;
            //atoms = pv.values(linkParent.atoms); // is atomsBase, below
            
            this.type   = owner.type;
            datums      = keyArgs.datums || def.fail.argumentRequired('datums');//linkParent._datums.slice();
            this._leafs = [];
            
            /* 
             * Inherit link parent atoms.
             */
            atomsBase = linkParent.atoms;
            //atoms = null
            
            index = def.get(keyArgs, 'index', null);
            
            data_addLinkChild.call(linkParent, this, index);
        } else {
            // Topmost root - an owner
            owner = this;
            //atoms = null
            atomsBase = {};
            
            if(keyArgs.labelSep){
                this.labelSep = keyArgs.labelSep;
            }
            
            this.type = keyArgs.type || def.fail.argumentRequired('type');
            
            // Only owner datas cache selected datums
            this._selectedDatums = new def.Map();
        }
    }
    
    /*global data_setDatums:true */
    if(datums){
        data_setDatums.call(this, datums);
    }
    
    // Must anticipate setting this (and not wait for the base constructor)
    // because otherwise new Dimension( ... ) fails.
    this.owner = owner;
    
    /* Need this because of null interning/un-interning and atoms chaining */
    this._atomsBase = atomsBase;
    
    this._dimensions = {};
    this.type.dimensionsList().forEach(this._initDimension, this);
    
    // Call base constructors
    this.base(owner, atoms, dimNames, atomsBase, /* wantLabel */ true);
    
    pv.Dom.Node.call(this, /* nodeValue */null);
    delete this.nodeValue;
    this._children = this.childNodes; // pv.Dom.Node#childNodes
    
    // Build absolute label and key
    // The absolute key is relative to the root data (not the owner - the topmost root)
    if(parent){
        index = def.get(keyArgs, 'index', null);
        
        data_addChild.call(parent, this, index);
        
        if(parent.absLabel){
            this.absLabel = def.string.join(owner.labelSep, parent.absLabel, this.label);
        } else {
            this.absLabel = this.label;
        }
        
        if(parent.absKey){
            this.absKey = def.string.join(",", parent.absKey, this.key);
        } else {
            this.absKey = this.key;
        }
    } else {
        this.absLabel = this.label;
        this.absKey   = this.key;
    }
})

// Mix pv.Dom.Node.prototype
.add(pv.Dom.Node)

.add(/** @lends pvc.data.Data# */{
    parent:       null,
    linkParent:   null,
    
    /**
     * The dimension instances of this data.
     * @type pvc.data.Dimension[]
     */
    _dimensions: null, 
    
    /**
     * The names of unbound dimensions.
     * @type string[]
     */
    _freeDimensionNames: null,
    
    /**
     * The child data instances of this data.
     * @type pvc.data.Data[]
     * @internal
     */
    _children: null,
    
    /**
     * The link child data instances of this data.
     * @type pvc.data.Data[]
     * @internal
     */
    _linkChildren: null,
    
    /**
     * The leaf data instances of this data.
     * 
     * @type pvc.data.Data[] 
     * @internal
     */
    _leafs: null,
    
    /** 
     * The map of child datas by their key.
     * 
     * @type string
     * @internal
     */
    _childrenByKey: null,
    
    /**
     * A map of visible datums indexed by id.
     * @type def.Map
     */
    _visibleDatums: null,
    
    /**
     * A map of selected datums indexed by id.
     * @type def.Map
     */
    _selectedDatums: null, 
    
    /**
     * Cache of link child data by grouping operation key.
     * @type object
     * @internal
     */
    _groupByCache: null,

    /**
     * An object with cached results of the {@link #dimensionsSumAbs} method.
     *
     * @type object
     */
    _sumAbsCache: null,

    /**
     * The height of the tree of datas headed by a root data.
     * Only defined in root datas. 
     */
    treeHeight: null,
    
    /**
     * The grouping operation object used to create this data. 
     * Only defined in root datas.
     * @type pvc.data.GroupingOper
     */
    _groupOper: null,
    
    /**
     * A grouping specification object used to create this data, 
     * along with {@link #groupLevel}. 
     * Only defined in datas that have children.
     * 
     * @type pvc.data.GroupingSpec
     */
    _groupSpec: null,
    
    /**
     * A grouping level specification object used to create this data, 
     * along with {@link #groupSpec}. 
     * Only defined in datas that have children.
     * 
     * @type pvc.data.GroupingLevelSpec
     */
    _groupLevel: null,
    
    /** 
     * The datums of this data.
     * @type pvc.data.Datum[]
     * @internal
     */
    _datums: null,
    
    /** 
     * A map of the datums of this data indexed by id.
     * @type object
     * @internal
     */
    _datumsById: null, 
    
    depth:    0,
    label:    "",
    absLabel: "",
    
    /** 
     * Indicates if the object has been disposed.
     * 
     * @type boolean 
     */
    _disposed: false,
    
    /**
     * Indicates that the data was a parent group 
     * in the flattening group operation.
     * 
     * @type boolean
     */
    _isFlattenGroup: false,
    _isDegenerateFlattenGroup: false,
    
    _initDimension: function(dimType){
        this._dimensions[dimType.name] = 
                new pvc.data.Dimension(this, dimType);
    },
    
    /**
     * Obtains a dimension given its name.
     * 
     * <p>
     * If no name is specified,
     * a map with all dimensions indexed by name is returned.
     * Do <b>NOT</b> modify this map.
     * </p>
     * 
     * <p>
     * There is one dimension instance per 
     * dimension type of the data's complex type.
     * </p>
     * <p>
     * If this is not a root data,
     * the dimensions will be child dimensions of
     * the corresponding parent data's dimensions.
     * </p>
     * <p>
     * If this is a root data,
     * the dimensions will 
     * have no parent dimension, but instead, an owner dimension.
     * </p>
     * 
     * @param {string} [name] The dimension name.
     * @param {object} [keyArgs] Keyword arguments.
     * @param {string} [keyArgs.assertExists=true} Indicates that a missing child should be signaled as an error.
     * 
     * @type pvc.data.Dimension
     */
    dimensions: function(name, keyArgs){
        if(name == null) {
            return this._dimensions;
        }
        
        var dim = def.getOwn(this._dimensions, name);
        if(!dim && def.get(keyArgs, 'assertExists', true)) {
            throw def.error.argumentInvalid('name', "Undefined dimension '{0}'.", [name]); 
        }
         
        return dim;
    },
    
    /**
     * Obtains an array of the names of dimensions that are not bound in {@link #atoms}.
     * @type string[]
     */
    freeDimensionNames: function(){
        if(!this._freeDimensionNames) {
            var free = this._freeDimensionNames = [];
            def.eachOwn(this._dimensions, function(dim, dimName){
                var atom = this.atoms[dimName];
                if(!(atom instanceof pvc.data.Atom) || atom.value == null){
                    free.push(dimName);
                }
            }, this);
        }
        return this._freeDimensionNames;
    },
    
    /**
     * Indicates if the data is an owner.
     * 
     * @type boolean
     */
    isOwner: function(){
        return this.owner === this;
    },
    
    /**
     * Obtains an enumerable of the child data instances of this data.
     * 
     * @type pvc.data.Data | def.Query
     */
    children: function(){
        if(!this._children) {
            return def.query();
        }

//        @param {object} [keyArgs] Keyword arguments. 
//        @param {string} [keyArgs.key=null} The key of the desired child.
//        @param {string} [keyArgs.assertExists=true} Indicates that a missing child should be signaled as an error.
//        var key = def.get(keyArgs, 'key');
//        if(key != null) {
//            var child = def.getOwn(this._childrenByKey, key);
//            if(!child && def.get(keyArgs, 'assertExists', true)) {
//               throw def.error.argumentInvalid("Undefined child data with key '{0}'.", [key]); 
//            }
//            
//            return child;
//        }
        
        return def.query(this._children);
    },

    /**
     * Obtains the number of children.
     *
     * @type number
     */
    childCount: function(){
        return this._children ? this._children.length : 0;
    },

    /**
     * Obtains an enumerable of the leaf data instances of this data.
     * 
     * @type def.Query 
     */
    leafs: function(){
        return def.query(this._leafs);
    },
    
    /**
     * Obtains the number of contained datums.
     * @type number
     */
    count: function(){
        return this._datums.length;
    },
    
    /**
     * Obtains the single datum of this data, 
     * or null, when the data no datums or has more than one.
     * 
     * @type pvc.data.Datum
     */
    singleDatum: function(){
        var datums = this._datums;
        return datums.length === 1 ? datums[0] : null;
    },
    
    /**
     * Disposes the child datas, the link child datas and the dimensions.
     * @type undefined
     */
    dispose: function(){
        if(!this._disposed){
            data_disposeChildLists.call(this);
            if(this._selectedDatums) { this._selectedDatums.clear(); }
            this._visibleDatums.clear();
            
            def.eachOwn(this._dimensions, function(dimension){ dimension.dispose(); });
            
            //  myself
            
            if(this.parent){
                this.parent.removeChild(this);
                this.parent = null;
            }
            
            if(this.linkParent) {
                /*global data_removeLinkChild:true */
                data_removeLinkChild.call(this.linkParent, this);
            }
            
            this._disposed = true;
        }
    },
    
    /**
     * Disposes the child datas and the link child datas.
     * @type undefined
     */
    disposeChildren: function(){
        /*global data_disposeChildLists:true */
        data_disposeChildLists.call(this);
    }
});

/**
 * Adds a child data.
 * 
 * @name pvc.data.Data#_addChild
 * @function
 * @param {pvc.data.Data} child The child data to add.
 * @param {number} [index=null] The index at which to insert the child.
 * @type undefined
 * @private
 */
function data_addChild(child, index){
    // this   -> ((pv.Dom.Node#)child).parentNode
    // child  -> ((pv.Dom.Node#)this).childNodes
    // ...
    this.insertAt(child, index);
    
    (this._childrenByKey || (this._childrenByKey = {}))[child.key] = child;
}

/**
 * Adds a link child data.
 * 
 * @name pvc.data.Data#_addLinkChild
 * @function
 * @param {pvc.data.Data} child The link child data to add.
 * @param {number} [index=null] The index at which to insert the child.
 * @type undefined
 * @private
 */
function data_addLinkChild(linkChild, index){
    /*global data_addColChild:true */
    data_addColChild(this, '_linkChildren', linkChild, 'linkParent', index);
}

/**
 * Removes a link child data.
 *
 * @name pvc.data.Data#_removeLinkChild
 * @function
 * @param {pvc.data.Data} child The link child data to remove.
 * @type undefined
 * @private
 */
function data_removeLinkChild(linkChild){
    /*global data_removeColChild:true */
    data_removeColChild(this, '_linkChildren', linkChild, 'linkParent');
}

/**
 * Disposes the child datas and the link child datas.
 * 
 * @name pvc.data.Data#_disposeChildLists
 * @function
 * @type undefined
 * @private
 */
function data_disposeChildLists() {
    /*global data_disposeChildList:true */
    data_disposeChildList(this._children, 'parent');
    this._childrenByKey = null;
    
    data_disposeChildList(this._linkChildren, 'linkParent');
    this._groupByCache = null;  
    
    // ~ datums.{isSelected, isVisible, isNull}, children
    this._sumAbsCache = null;
}

/**
 * Called to assert that this is an owner data.
 *  
 * @private
 */
function data_assertIsOwner(){
    /*jshint expr:true */
    this.isOwner() || def.fail("Can only be called on the owner data.");
}
pvc.data.Data.add(/** @lends pvc.data.Data# */{
    /**
     * Obtains the number of selected datums.
     * <p>
     * This method is only optimized when called on an owner data.
     * </p>
     * 
     * @type Number
     */
    selectedCount: function(){
        if(!this.isOwner()){
            return this.datums(null, {selected: true}).count();
        }
        
        return this._selectedDatums.count;
    },
    
    /**
     * Obtains the selected datums, in an unspecified order.
     * <p>
     * If the datums should be sorted, 
     * they can be sorted by their {@link pvc.data.Datum#id}.
     * 
     * Alternatively, {@link #datums} can be called,
     * with the <tt>selected</tt> keyword argument.
     * </p>
     * @type pvc.data.Datum[]
     */
    selectedDatums: function(){
        if(!this.isOwner()){
            return this.datums(null, {selected: true}).array();
        }
        
        return this._selectedDatums.values();
    },
    
    /**
     * Obtains a map containing the selected datums, indexed by id.
     * 
     * @type def.Map(pvc.data.Datum)
     */
    selectedDatumMap: function(){
        if(!this.isOwner()){
            
            var datums = this
                .datums(null, {selected: true})
                .object({
                    name: function(datum){ return datum.id; }
                });
            
            return new def.Set(datums);
        }
        
        return this._selectedDatums.clone();
    },
    
    /**
     * Obtains the number of visible datums.
     * 
     * @type Number
     */
    visibleCount: function(){
        return this._visibleDatums.count;
    },
    
    /**
     * Replaces currently selected datums with the specified datums.
     *
     * @param {pvc.data.Datum[]|def.query<pvc.data.Datum>} [datums] The new datums to be selected.
     * @returns {boolean} Returns <tt>true</tt> if any datum was selected and <tt>false</tt> otherwise. 
     */
    replaceSelected: function(datums){
        /*global datum_deselect:true */
        
        // Clear all but the ones we'll be selecting.
        // This way we can have a correct changed flag.
        var alreadySelectedById = 
            def
            .query(datums)
            .where(function(datum){ return datum.isSelected; })
            .object({ name: function(datum){ return datum.id; } });
        
        var changed = this.owner.clearSelected(function(datum){
                return !def.hasOwn(alreadySelectedById, datum.id); 
            });
        
        changed |= pvc.data.Data.setSelected(datums, true);
        
        return changed;
    },
    
    /**
     * Clears the selected state of any selected datum.
     *
     * @param {pvc.data.Datum} [funFilter] Allows excluding atoms from the clear operation.
     * @returns {boolean} Returns <tt>true</tt> if any datum was selected and <tt>false</tt> otherwise. 
     */
    clearSelected: function(funFilter){
        /*global datum_deselect:true */
        
        if(this.owner !== this){
             return this.owner.clearSelected(funFilter);
        }
        
        if(!this._selectedDatums.count) {
            return false;
        }
        
        var changed;
        if(funFilter){
            changed = false;
            this._selectedDatums
                .values()
                .filter(funFilter)
                .forEach(function(datum){
                    changed = true;
                    datum_deselect.call(datum);
                    this._selectedDatums.rem(datum.id);
                }, this);
        } else {
            changed = true;
            this._selectedDatums.values().forEach(function(datum){
                /*global datum_deselect:true */
                datum_deselect.call(datum);
            });
    
            this._selectedDatums.clear();
        }
        
        return changed;
    }
});

/**
 * Called by a datum on its owner data 
 * when its selected state changes.
 * 
 * @name pvc.data.Data#_onDatumSelectedChanged
 * @function
 * @param {pvc.data.Datum} datum The datum whose selected state changed.
 * @param {boolean} selected The new datum selected state.
 * @type undefined
 * @internal
 */
function data_onDatumSelectedChanged(datum, selected){
    // <Debug>
    /*jshint expr:true */
    !datum.isNull || def.assert("Null datums do not notify selected changes");
    // </Debug>
    
    if(selected){
        this._selectedDatums.set(datum.id, datum);
    } else {
        this._selectedDatums.rem(datum.id);
    }

    this._sumAbsCache = null;
}

/**
 * Called by a datum on its owner data 
 * when its visible state changes.
 * 
 * @name pvc.data.Data#_onDatumVisibleChanged
 * @function
 * @param {pvc.data.Datum} datum The datum whose visible state changed.
 * @param {boolean} selected The new datum visible state.
 * @type undefined
 * @internal
 */
function data_onDatumVisibleChanged(datum, visible){
    if(def.hasOwn(this._datumsById, datum.id)) {
        
        // <Debug>
        /*jshint expr:true */
        !datum.isNull || def.assert("Null datums do not notify visible changes");
        // </Debug>
        
        if(visible){
            this._visibleDatums.set(datum.id, datum);
        } else {
            this._visibleDatums.rem(datum.id);
        }
        
        this._sumAbsCache = null;

        // Notify dimensions
        def.eachOwn(this._dimensions, function(dimension){
            /*global dim_onDatumVisibleChanged:true */
            dim_onDatumVisibleChanged.call(dimension, datum, visible);
        });
        
        // Notify child and link child datas
        this._children.forEach(function(data){
            data_onDatumVisibleChanged.call(data, datum, visible);
        });
        
        if(this._linkChildren) {
            this._linkChildren.forEach(function(data){
                data_onDatumVisibleChanged.call(data, datum, visible);
            });
        }
    }
}

/**
 * Sets the selected state of the given datums
 * to the state 'select'.
 * 
 * @param {def.Query} datums An enumerable of {@link pvc.data.Datum} to set.
 * @param {boolean} selected The desired selected state.
 * 
 * @returns {boolean} true if at least one datum changed its selected state.
 * @static
 */
pvc.data.Data.setSelected = function(datums, selected){
    var anyChanged = false;

    if(datums){
        def.query(datums).each(function(datum){
            if(datum.setSelected(selected)){
                // data_onDatumSelectedChanged has already been called
                anyChanged = true;
            }
        });
    }

    return anyChanged;
};

/**
 * Pseudo-toggles the selected state of the given datums.
 * If all are selected, clears their selected state.
 * Otherwise, selects all.
 * 
 * @param {def.Query} datums An enumerable of {@link pvc.data.Datum} to toggle.
 * 
 * @returns {boolean} true if at least one datum changed its selected state.
 * @static
 */
pvc.data.Data.toggleSelected = function(datums){
    if(!def.array.isLike(datums)){
        datums = def.query(datums).array();
    }
    
    // Ensure null datums don't affect the result
    var allSelected = def.query(datums).all(function(datum){ return datum.isNull || datum.isSelected; });
    return this.setSelected(datums, !allSelected);
};

/**
 * Sets the visible state of the given datums
 * to the state 'visible'.
 * 
 * @param {def.Query} datums An enumerable of {@link pvc.data.Datum} to set.
 * @param {boolean} visible The desired visible state.
 * 
 * @returns {boolean} true if at least one datum changed its visible state.
 * @static
 */
pvc.data.Data.setVisible = function(datums, visible){
    var anyChanged = false;

    if(datums){
        def.query(datums).each(function(datum){
            if(datum.setVisible(visible)){
                // data_onDatumVisibleChanged has already been called
                anyChanged = true;
            }
        });
    }

    return anyChanged;
};

/**
 * Pseudo-toggles the visible state of the given datums.
 * If all are visible, hides them.
 * Otherwise, shows them all.
 * 
 * @param {def.Query} datums An enumerable of {@link pvc.data.Datum} to toggle.
 * 
 * @returns {boolean} true if at least one datum changed its visible state.
 * @static
 */
pvc.data.Data.toggleVisible = function(datums){
    if(!def.array.isLike(datums)){
        datums = def.query(datums).array();
    }
    
    // Ensure null datums don't affect the result (null datums are always visible)
    var allVisible = def.query(datums).all(function(datum){ return datum.isVisible; });
    return pvc.data.Data.setVisible(datums, !allVisible);
};

/**
 * Initializes a grouping specification.
 * 
 * <p>
 * A grouping specification contains information similar to that of an SQL 'order by' clause.
 * </p>
 * 
 * <p>
 * A grouping specification supports the grouping operation.
 * </p>
 * 
 * @see pvc.data.GroupingOper
 * 
 * @name pvc.data.GroupingSpec
 * 
 * @class Contains information about a grouping operation.
 * 
 * @property {string} id A <i>semantic</i> identifier of this grouping specification.
 * @property {boolean} isSingleDimension Indicates that there is only one level and dimension.
 * @property {boolean} isSingleLevel Indicates that there is only one level.
 * @property {boolean} hasCompositeLevels Indicates that there is at least one level with more than one dimension.
 * @property {pvc.data.ComplexType} type The complex type against which dimension names were resolved.
 * @property {pvc.data.GroupingLevelSpec} levels An array of level specifications.
 * @property {pvc.data.DimensionType} firstDimension The first dimension type, if any.
 * @property {string} flatteningMode Indicates if the grouping is
 * flattened using pre or post order depth-first search.
 * Possible values are <tt>null</tt>, <tt>'tree-pre'</tt> and <tt>'tree-post'</tt>.
 * @property {string} flattenRootLabel The label of the root node of a flattening operation.
 *
 * @constructor
 * @param {def.Query} levelSpecs An enumerable of {@link pvc.data.GroupingLevelSpec}.
 * @param {pvc.data.ComplexType} [type] A complex type.
 * @param {object} [keyArgs] Keyword arguments.
 * @param {string} [keyArgs.flatteningMode=null] The flattening mode.
 * @param {string} [keyArgs.flattenRootLabel=''] The label of the root node of a flattening operation.
 */
def.type('pvc.data.GroupingSpec')
.init(function(levelSpecs, type, keyArgs){
    this.type = type || null;
    
    var ids = [];
    
    this.hasCompositeLevels = false;
    
    var dimNames = []; // accumulated dimension names
    
    this.levels = def.query(levelSpecs || undefined) // -> null query
        .where(function(levelSpec){ return levelSpec.dimensions.length > 0; })
        .select(function(levelSpec){
            ids.push(levelSpec.id);
            
            def.array.append(dimNames, levelSpec.dimensionNames());
            
            if(!this.hasCompositeLevels && levelSpec.dimensions.length > 1) {
                this.hasCompositeLevels = true;
            }
            
            levelSpec._setAccDimNames(dimNames.slice(0));
            
            return levelSpec;
        }, this)
        .array();
    
    this._dimNames = dimNames;
    
    // The null grouping has zero levels
    this.depth             = this.levels.length;
    this.isSingleLevel     = this.depth === 1;
    this.isSingleDimension = this.isSingleLevel && !this.hasCompositeLevels;
    this.firstDimension    = this.depth > 0 ? this.levels[0].dimensions[0] : null;
    
    this.flatteningMode   = def.get(keyArgs, 'flatteningMode'  ) || null;
    this.flattenRootLabel = def.get(keyArgs, 'flattenRootLabel') || '';
    
    this.id = (this.flatteningMode || '') + "##" +
              this.flattenRootLabel + "##" +
              ids.join('||');
})
.add(/** @lends pvc.data.GroupingSpec# */{
    /**
     * Late binds a grouping specification to a complex type.
     * @param {pvc.data.ComplexType} type A complex type.
     */
    bind: function(type){
        this.type = type || def.fail.argumentRequired('type');
        this.levels.forEach(function(levelSpec){
            levelSpec.bind(type);
        });
    },

    /**
     * Obtains an enumerable of the contained dimension specifications.
     * @type def.Query
     */
    dimensions: function(){
        return def.query(this.levels)
                  .selectMany(function(level){ return level.dimensions; });
    },

    dimensionNames: function(){
        return this._dimNames;
    },
    
    view: function(complex){
        return complex.view(this.dimensionNames());
    },

    /**
     * Indicates if the data resulting from the grouping is discrete or continuous.
     * @type boolean
     */
    isDiscrete: function(){
        var d;
        return !this.isSingleDimension || 
               (!!(d = this.firstDimension) && d.type.isDiscrete);
    },
    
    /**
     * Obtains the dimension type of the first dimension spec., if any.
     * @type pvc.visual.DimensionType
     */
    firstDimensionType: function(){
        var d = this.firstDimension;
        return d && d.type;
    },
    
    /**
     * Obtains the dimension name of the first dimension spec., if any.
     * @type string
     */
    firstDimensionName: function(){
        var dt = this.firstDimensionType();
        return dt && dt.name;
    },
    
    /**
     * Obtains the dimension value type of the first dimension spec., if any.
     * @type string
     */
    firstDimensionValueType: function(){
        var dt = this.firstDimensionType();
        return dt && dt.valueType;
    },
    
    /**
     * Indicates if the grouping has no levels.
     * @type boolean
     */
    isNull: function(){
        return !this.levels.length;
    },

    /**
     * Obtains a version of this grouping specification
     * that conforms to the specified arguments.
     *
     * @param {string} [keyArgs.flatteningMode] The desired flatening mode.
     * Supports the value 'singleLevel' as a way to signify the same as
     * what the method {@link #singleLevelGrouping} does.
     *
     * @param {boolean} [keyArgs.reverse=false] Indicates that each dimension's order should be reversed.
     * @type pvc.data.GroupingSpec
     */
    ensure: function(keyArgs){
        var grouping = this,
            flatteningMode = def.get(keyArgs, 'flatteningMode');

        if(flatteningMode){
            if(flatteningMode === 'singleLevel'){
                // Supports reverse
                return grouping.singleLevelGrouping(keyArgs);
            }

            var flattenRootLabel = def.get(keyArgs, 'flattenRootLabel') || '';
            if(this.flatteningMode !== flatteningMode || (this.flattenRootLabel !== flattenRootLabel)){
                grouping = new pvc.data.GroupingSpec(grouping.levels, grouping.type, {
                    flatteningMode:   flatteningMode,
                    flattenRootLabel: flattenRootLabel
                });
            }
        }

        if (def.get(keyArgs, 'reverse', false)){
            grouping = grouping.reversed();
        }

        return grouping;
    },

    /**
     * Obtains a single-level version of this grouping specification.
     * 
     * <p>
     * If this grouping specification is itself single-level, 
     * then it is returned.
     * </p> 
     * 
     * @param {object} [keyArgs] Keyword arguments
     * @param {boolean} [keyArgs.reverse=false] Indicates that each dimension's order should be reversed.
     * @type pvc.data.GroupingSpec 
     */
    singleLevelGrouping: function(keyArgs){
        var reverse = !!def.get(keyArgs, 'reverse', false);
        if(this.isSingleLevel && !reverse) {
            return this;
        }
        
        /*jshint expr:true */
        this._singleLevelGrouping || (this._singleLevelGrouping = {});
        
        var singleLevel = this._singleLevelGrouping[reverse];
        if(!singleLevel) {
            var dimSpecs = this.dimensions()
                            .select(function(dimSpec){
                                return reverse ? 
                                    new pvc.data.GroupingDimensionSpec(dimSpec.name, !dimSpec.reverse, dimSpec.type.complexType) :
                                    dimSpec;
                            });
                            
            var levelSpec = new pvc.data.GroupingLevelSpec(dimSpecs, this.type);
            
            singleLevel = new pvc.data.GroupingSpec([levelSpec], this.type, {flatteningMode: this.flatteningMode});
            
            this._singleLevelGrouping[reverse] = singleLevel;
        }
        
        return singleLevel;
    },
    
    /**
     * Obtains a reversed version of this grouping specification.
     * 
     * @type pvc.data.GroupingSpec 
     */
    reversed: function(){
        var reverseGrouping = this._reverseGrouping;
        if(!reverseGrouping) {
            
            var levelSpecs = def.query(this.levels)
                    .select(function(levelSpec){
                        var dimSpecs = def.query(levelSpec.dimensions)
                                .select(function(dimSpec){
                                    return new pvc.data.GroupingDimensionSpec(dimSpec.name, !dimSpec.reverse, dimSpec.type.complexType);
                                });
                        
                        return new pvc.data.GroupingLevelSpec(dimSpecs, this.type);
                    });

            reverseGrouping = new pvc.data.GroupingSpec(levelSpecs, this.type, {flatteningMode: this.flatteningMode});
            
            this._reverseGrouping = reverseGrouping;
        }
        
        return reverseGrouping;
    },

    toString: function(){
        return def.query(this.levels)
                .select(function(level){ return '' + level; })
                .array()
                .join(', ');
    }
});

def.type('pvc.data.GroupingLevelSpec')
.init(function(dimSpecs, type){
    var ids = [];
    var dimNames = [];
    
    this.dimensions = def.query(dimSpecs)
       .select(function(dimSpec){
           ids.push(dimSpec.id);
           dimNames.push(dimSpec.name);
           return dimSpec;
       })
       .array();
    
    this._dimNames = dimNames;
    
    this.dimensionsInDefOrder = this.dimensions.slice(0);
    if(type){
        this._sortDimensions(type);
    }
    
    this.id = ids.join(',');
    this.depth = this.dimensions.length;
    
    var me = this;
    this.comparer = function(a, b){ return me.compare(a, b); };
})
.add( /** @lends pvc.data.GroupingLevelSpec */{
    _sortDimensions: function(type){
        type.sortDimensionNames(
            this.dimensionsInDefOrder,
            function(d){ return d.name; });
    },
    
    _setAccDimNames: function(accDimNames){
        this._accDimNames = accDimNames;
    },
    
    accDimensionNames: function(){
        return this._accDimNames;
    },
    
    dimensionNames: function(){
        return this._dimNames;
    },
    
    bind: function(type){
        this._sortDimensions(type);
        
        this.dimensions.forEach(function(dimSpec){ dimSpec.bind(type); });
    },
    
    compare: function(a, b){
        for(var i = 0, D = this.depth ; i < D ; i++) {  
            var result = this.dimensions[i].compareDatums(a, b);
            if(result !== 0) {
                return result;
            }
        }
        
        return 0;
    },
    
    key: function(datum){
        var key      = '';
        var atoms    = {};
        var datoms   = datum.atoms;
        var dimNames = this._dimNames;
        var keySep   = datum.owner.keySep;
        
        // This builds a key compatible with that of pvc.data.Complex#key
        for(var i = 0, D = this.depth ; i < D ; i++) {
            var dimName = dimNames[i];
            var atom = datoms[dimName];
            atoms[dimName] = atom;
            if(!i){
                key = atom.key;
            } else {
                key += keySep + atom.key;
            }
        }
        
        return {key: key, atoms: atoms, dimNames: dimNames};
    },

    toString: function(){
        return def.query(this.dimensions)
                .select(function(dimSpec){ return '' + dimSpec; })
                .array()
                .join('|');
    }
});

def.type('pvc.data.GroupingDimensionSpec')
.init(function(name, reverse, type){
    this.name     = name;
    this.reverse  = !!reverse;
    this.id = this.name + ":" + (this.reverse ? '0' : '1');
    if(type){
        this.bind(type);
    }
})
.add( /** @lends pvc.data.GroupingDimensionSpec */ {
    type: null,
    comparer: null,

    /**
     * Late binds a dimension specification to a complex type.
     * @param {pvc.data.ComplexType} type A complex type.
     */
    bind: function(type){
        /*jshint expr:true */
        type || def.fail.argumentRequired('type');
        
        this.type     = type.dimensions(this.name);
        this.comparer = this.type.atomComparer(this.reverse);
    },

    compareDatums: function(a, b){
        //if(this.type.isComparable) {
            var result  = this.comparer(a.atoms[this.name], b.atoms[this.name]);
            if(result !== 0) {
                return result;
            }
            return 0;
        //}
        
        // Use datum source order
        //return this.reverse ? (b.id - a.id) : (a.id - b.id);
    },

    toString: function(){
        return this.name + (this.reverse ? ' desc' : '');
    }
});

/**
 * Parses a grouping specification string.
 * 
 * @param {string|string[]} [specText] The grouping specification text,
 * or array of grouping specification level text.
 * When unspecified, a null grouping is returned.
 * 
 * <p>
 * An example:
 * </p>
 * <pre>
 * "series1 asc, series2 desc, category"
 * </pre>
 * <p>
 * The following will group all the 'series' in one level and the 'category' in another: 
 * </p>
 * <pre>
 * "series1 asc|series2 desc, category"
 * </pre>
 * 
 * @param {pvc.data.ComplexType} [type] A complex type against which to resolve dimension names.
 * 
 * @type pvc.data.GroupingSpec
 */
pvc.data.GroupingSpec.parse = function(specText, type){
    if(!specText){
        return new pvc.data.GroupingSpec(null, type);
    }
    
    var levels;
    if(def.array.is(specText)) {
        levels = specText;
    } else if(def.string.is(specText)) {
        levels = specText.split(/\s*,\s*/); 
    }

    var levelSpecs = def.query(levels)
               .select(function(levelText){
                   var dimSpecs = groupSpec_parseGroupingLevel(levelText, type);
                   return new pvc.data.GroupingLevelSpec(dimSpecs, type);
               });
    
    return new pvc.data.GroupingSpec(levelSpecs, type);
};

var groupSpec_matchDimSpec = /^\s*(.+?)(?:\s+(asc|desc))?\s*$/i;

/**
 * @private
 * @static
 */
function groupSpec_parseGroupingLevel(groupLevelText, type) {
    /*jshint expr:true */
    def.string.is(groupLevelText) || def.fail.argumentInvalid('groupLevelText', "Invalid grouping specification.");
    
    return def.query(groupLevelText.split(/\s*\|\s*/))
       .where(def.truthy)
       .select(function(dimSpecText){
            var match   = groupSpec_matchDimSpec.exec(dimSpecText) ||
                            def.fail.argumentInvalid('groupLevelText', "Invalid grouping level syntax '{0}'.", [dimSpecText]),
                name    = match[1],
                order   = (match[2] || '').toLowerCase(),
                reverse = order === 'desc';
               
            return new pvc.data.GroupingDimensionSpec(name, reverse, type);
        });
}
/**
 * Initializes a data operation.
 * 
 * @name pvc.data.DataOper
 * 
 * @class The base abstract class for a data operation.
 * Performs an initial query on the datums of the opertion's link parent
 * and hands the final implementation to a derived class.
 * 
 * @property {string} key Set on construction with a value that identifies the operation.
 * 
 * @constructor
 *
 * @param {pvc.data.Data} linkParent The link parent data.
 * @param {object} [keyArgs] Keyword arguments.
 */
def.type('pvc.data.DataOper')
.init(function(linkParent, keyArgs){
    this._linkParent = linkParent;
}).
add(/** @lends pvc.data.DataOper */{
    
    key: null,

    /**
     * Performs the data operation.
     * 
     * @returns {pvc.data.Data} The resulting root data.
     */
    execute: def.method({isAbstract: true})
});

/**
 * Initializes a grouping operation.
 * 
 * @name pvc.data.GroupingOper
 * 
 * @class Performs one grouping operation according to a grouping specification.
 * @extends pvc.data.DataOper
 * 
 * @constructor
 *
 * @param {pvc.data.Data} linkParent The link parent data.
 * 
 * @param {string|string[]|pvc.data.GroupingSpec|pvc.data.GroupingSpec[]} groupingSpecs A grouping specification as a string, an object or array of either.
 * 
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.data.DataOper} for any additional arguments.
 * 
 * @param {boolean} [keyArgs.isNull=null]
 *      Only considers datums with the specified isNull attribute.
 * @param {boolean} [keyArgs.visible=null]
 *      Only considers datums that have the specified visible state.
 * @param {boolean} [keyArgs.selected=null]
 *      Only considers datums that have the specified selected state.
 * @param {function} [keyArgs.where] A datum predicate.
 * @param {string} [keyArgs.whereKey] A key for the specified datum predicate,
 * previously returned by this function.
 * <p>
 * If this argument is specified, and it is not the value <c>null</c>,
 * it can be used to cache results.
 * If this argument is specified, and it is the value <c>null</c>,
 * the results are not cached.
 * If it is not specified, and <tt>keyArgs</tt> is specified,
 * one is returned.
 * If it is not specified and <tt>keyArgs</tt> is not specified,
 * then the instance will have a null {@link #key} property value.
 * </p>
 * <p>
 * If a key not previously returned by this operation is specified,
 * then it should be prefixed with a "_" character,
 * in order to not collide with keys generated internally.
 * </p>
 */
def.type('pvc.data.GroupingOper', pvc.data.DataOper)
.init(function(linkParent, groupingSpecs, keyArgs){
    /* Grouping spec may be specified as text or object */
    /*jshint expr:true */
    groupingSpecs || def.fail.argumentRequired('groupingSpecs');

    this.base(linkParent, keyArgs);

    this._where      = def.get(keyArgs, 'where');
    this._visible    = def.get(keyArgs, 'visible',  null);
    this._selected   = def.get(keyArgs, 'selected', null);
    this._isNull     = def.get(keyArgs, 'isNull',   null);
    
    /* 'Where' predicate and its key */
    var hasKey = this._selected == null, // TODO: Selected state changes do not yet invalidate cache...
        whereKey = '';
    if(this._where){
        whereKey = def.get(keyArgs, 'whereKey');
        if(!whereKey){
            if(!keyArgs || whereKey === null){
                // Force no key
                hasKey = false;
            } else {
                whereKey = '' + def.nextId('dataOperWhereKey');
                keyArgs.whereKey = whereKey;
            }
        }
    }

    // grouping spec ids is semantic keys, although the name is not 'key'
    var ids = [];
    this._groupSpecs = def.array.as(groupingSpecs).map(function(groupSpec){
        if(groupSpec instanceof pvc.data.GroupingSpec) {
            if(groupSpec.type !== linkParent.type) {
                throw def.error.argumentInvalid('groupingSpecText', "Invalid associated complex type.");
            }
        } else {
            // Must be a non-empty string, or throws
            groupSpec = pvc.data.GroupingSpec.parse(groupSpec, linkParent.type);
        }
        
        ids.push(groupSpec.id);

        return groupSpec;
    });
    
    /* Operation key */
    if(hasKey){
        this.key = ids.join('!!') +
                   "||visible:"  + this._visible +
                   "||isNull:"   + this._isNull  +
                   //"||selected:" + this._selected +
                   "||where:"    + whereKey;
    }
}).
add(/** @lends pvc.data.GroupingOper */{

    /**
     * Performs the grouping operation.
     *
     * @returns {pvc.data.Data} The resulting root data.
     */
    execute: function(){
        /* Setup a priori datum filters */
        
        /*global data_whereState: true */
        var datumsQuery = data_whereState(def.query(this._linkParent._datums), {
            visible:  this._visible,
            selected: this._selected,
            isNull:   this._isNull,
            where:    this._where
        });
        
        /* Group datums */
        var rootNode = this._group(datumsQuery);

        /* Render node into a data */
        return this._generateData(rootNode, null, this._linkParent);
    },
    
    executeAdd: function(rootData, datums){
        
        /*global data_whereState: true */
        var datumsQuery = data_whereState(def.query(datums), {
            visible:  this._visible,
            selected: this._selected,
            isNull:   this._isNull,
            where:    this._where
        });
        
        /* Group new datums */
        var rootNode = this._group(datumsQuery);

        /* Render node into specified root data */
        this._generateData(rootNode, null, this._linkParent, rootData);
        
        return rootNode.datums;
    },

    _group: function(datumsQuery){

        // Create the root node
        var rootNode = {
            isRoot: true,
            treeHeight: def
                .query(this._groupSpecs)
                .select(function(spec){
                    var levelCount = spec.levels.length;
                    if(!levelCount) { 
                        return 0; 
                    }
                    return !!spec.flatteningMode ? 1 : levelCount;
                })
                .reduce(def.add, 0),
                
            datums: []
            // children
            // atoms       // not on rootNode
            // isFlattenGroup // on parents of a flattened group spec
        };

        if(rootNode.treeHeight > 0){
            this._groupSpecRecursive(rootNode, datumsQuery, 0);
        }
        
        return rootNode;
    },
    
    _groupSpecRecursive: function(specParentNode, specDatumsQuery, specIndex){
        var groupSpec     = this._groupSpecs[specIndex];
        var levelSpecs    = groupSpec.levels;
        var L             = levelSpecs.length;
        var doFlatten     = !!groupSpec.flatteningMode;
        var nextSpecIndex = specIndex + 1;
        var isLastSpec    = (nextSpecIndex >= this._groupSpecs.length);
        var isPostOrder   = doFlatten && (groupSpec.flatteningMode === 'tree-post');
        var specGroupParent;
        
        if(doFlatten){
            specParentNode.children = [];
            specParentNode.childrenByKey = {}; // Don't create children with equal keys
            
            // Must create a rootNode for the grouping operation
            // Cannot be specParentNode (TODO: Why?)
            specGroupParent = {
                key:      '', // Key is local to groupSpec (when not flattened, it is local to level)
                absKey:   '', 
                atoms:    {},
                datums:   [],
                label:    groupSpec.flattenRootLabel,
                dimNames: []
            };

            if(!isPostOrder){
                specParentNode.children.push(specGroupParent);
                specParentNode.childrenByKey[''] = specGroupParent;
            }
        } else {
            specGroupParent = specParentNode;
        }

        /* Group datums */
        groupLevelRecursive.call(this, specGroupParent, specDatumsQuery, 0);

        if(doFlatten){

            if(isPostOrder){
                specParentNode.children.push(specGroupParent);
            }

            // Add datums of specGroupParent to specParentNode.
            specParentNode.datums = specGroupParent.datums;
        }
        
        function groupLevelRecursive(levelParentNode, levelDatums, levelIndex){
            
            var levelSpec = levelSpecs[levelIndex];
            
            if(!doFlatten){
                levelParentNode.children = [];
                levelParentNode.groupSpec = groupSpec;
                levelParentNode.groupLevelSpec = levelSpec;
            }
            
            var childNodes = this._groupDatums(levelSpec, levelParentNode, levelDatums, doFlatten);
            var isLastSpecLevel = levelIndex === L - 1;
            var willRecurseParent = doFlatten && !isLastSpec;
            
            // Add children's datums to levelParentNode, in post order.
            // This way, datums are reordered to follow the grouping "pattern". 
            // 
            // NOTE: levelParentNode.datums is initially empty
            var levelParentDatums = willRecurseParent ? 
                    [] : 
                    levelParentNode.datums;
            
            childNodes
            .forEach(function(child){
                /* On all but the last level,
                 * the datums of *child* are set to the 
                 * union of datums of its own children.
                 * The datums will have been added, 
                 * by the end of the following recursive call.
                 */
                var childDatums = child.datums; // backup original datums
                if(!(isLastSpec && isLastSpecLevel)){
                    child.datums = [];
                }
                
                var specParentChildIndex;
                if(!doFlatten){
                    levelParentNode.children.push(child);
                } else {
                    // Add children at a "hidden" property
                    // so that the test "if(!child._children.length)"
                    // below, can be done.
                    def.array.lazy(levelParentNode, '_children').push(child);
                    
                    if(def.hasOwn(specParentNode.childrenByKey, child.key)){
                        // Duplicate key.
                        // Don't add as child of specParentNode.
                        // 
                        // We need to add its datums to group parent, anyway.
                        def.array.append(levelParentDatums, childDatums);
                        return;
                    }
                    
                    specParentChildIndex = specParentNode.children.length;
                    if(!isPostOrder){
                        specParentNode.children.push(child);
                        specParentNode.childrenByKey[child.key] = child;

                        levelParentNode.isFlattenGroup = true;
                    }
                }
                
                if(!isLastSpecLevel){
                    groupLevelRecursive.call(this, child, childDatums, levelIndex + 1);
                } else if(!isLastSpec) {
                    this._groupSpecRecursive(child, childDatums, nextSpecIndex);
                }

                // Datums already added to 'child'.
                def.array.append(levelParentDatums, child.datums);

                if(doFlatten && isPostOrder){
                    if(def.hasOwn(specParentNode.childrenByKey, child.key)){
                        /*jshint expr:true*/
                        child.isFlattenGroup || def.assert("Must be a parent for duplicate keys to exist.");
                        
                        // A child of child
                        // was registered with the same key,
                        // because it is all-nulls (in descending level's keys).
                        // But it is better to show the parent instead of the child,
                        // so we remove the child and add the parent.
                        // Yet, we cannot show only the parent
                        // if *child* has more than one child,
                        // cause then, the datums of the null child.child
                        // would only be in *child*, but
                        // the datums of the non-null child.child
                        // would be both in *child* and in child.child.
                        // This would mess up the scales and waterfall control code,
                        // not knowing whether to ignore the flatten group or not.
                        if(child._children.length === 1){
                            specParentNode.children.splice(
                                    specParentChildIndex, 
                                    specParentNode.children.length - specParentChildIndex);
                            
                            // A total group that must be accounted for
                            // because it has own datums.
                            child.isDegenerateFlattenGroup = true;
                        }
                        // else, both are added to specParentNode,
                        // and their datas will be given separate keys
                        // they will both be shown.
                        // Below, we overwrite anyway, with no harmful effect
                    }
                    
                    specParentNode.children.push(child);
                    specParentNode.childrenByKey[child.key] = child;
                    
                    levelParentNode.isFlattenGroup = true;
                }
            }, this);

            if(willRecurseParent) {
                // datums can no longer change
                this._groupSpecRecursive(levelParentNode, levelParentDatums, nextSpecIndex);
            }
        }
    },
    
    _groupDatums: function(levelSpec, levelParentNode, levelDatums, doFlatten){
        // The first datum of each group is inserted here in order,
        // according to the level's comparer.
        var firstDatums = [];
        
        // The first child is inserted here 
        // at the same index as that of 
        // the first datum in firstDatums.
        var childNodes = new def.OrderedMap();
        
        // Group levelDatums By the levelSpec#key(.)
        def
        .query(levelDatums)
        .each(function(datum){
            /*  newChild = { key: '', atoms: {}, dimNames: [] } */
            var newChild = levelSpec.key(datum);
            var key      = newChild.key;
            var child    = childNodes.get(key);
            if(child){
                child.datums.push(datum);
            } else {
                // First datum with key -> new child
                child = newChild;
                child.datums   = [datum];
                
                if(doFlatten){
                    // child.atoms must contain (locally) those of the levelParentNode,
                    // so that when flattened, they have a unique key 
                    def.copy(child.atoms, levelParentNode.atoms);
                    
                    // The key is the absKey, trimmed of keySep at the end
                    if(levelParentNode.dimNames.length){
//                        child.key = levelParentNode.key + 
//                                    datum.owner.keySep + 
//                                    key;
                        
                        var keySep = datum.owner.keySep;
                        
                        child.absKey = 
                            levelParentNode.absKey + 
                            keySep + 
                            key;
                        
                        var K = keySep.length;
                        var trimKey = child.absKey;
                        while(trimKey.lastIndexOf(keySep) === trimKey.length - K){
                            trimKey = trimKey.substr(0, trimKey.length - K);
                        }
                        
                        child.key = trimKey;
                    } else {
                        child.absKey = key;
                    }
                    
                    // don't change local key variable
                    child.dimNames = levelSpec.accDimensionNames();
                }
                
                var datumIndex = def.array.insert(firstDatums, datum, levelSpec.comparer);
                childNodes.add(key, child, ~datumIndex);
            }
        });
        
        return childNodes;
    },
    
    _generateData: function(node, parentNode, parentData, rootData){
        var data, isNew;
        if(node.isRoot){
            // Root node
            if(rootData){
                data = rootData;
                /*global data_addDatumsLocal:true*/
                data_addDatumsLocal.call(data, node.datums);
            } else {
                isNew = true;
                
                // Create a *linked* rootNode data
                data = new pvc.data.Data({
                    linkParent: parentData,
                    datums:     node.datums
                });
                data.treeHeight = node.treeHeight;
                data._groupOper = this;
            }
        } else {
            if(rootData){
                data = def.get(parentData._childrenByKey, node.key);
                if(data){
                    // Add the datums to the data, and its atoms to its dimensions
                    // Should also update linkedChildren (not children).
                    /*global data_addDatumsSimple:true*/
                    data_addDatumsSimple.call(data, node.datums);
                }
            }
            
            if(!data){
                isNew = true;
                var index, siblings;
                if(rootData && (siblings = parentData._children)){
                    // Insert the new sibling in correct order
                    // node.datums[0] is representative of the new Data's position
                    index = ~def.array.binarySearch(siblings, node.datums[0], parentNode.groupLevelSpec.comparer);
                }
                
                data = new pvc.data.Data({
                    parent:   parentData,
                    atoms:    node.atoms,
                    dimNames: node.dimNames,
                    datums: node.datums,
                    index:  index
                });
            }
        }

        if(isNew && node.isFlattenGroup){
            data._isFlattenGroup = true;
            data._isDegenerateFlattenGroup = !!node.isDegenerateFlattenGroup;
            
            var label = node.label;
            if(label){
                data.label    += label;
                data.absLabel += label;
            }
        }

        var childNodes = node.children;
        if(childNodes && childNodes.length){
            if(isNew){
                data._groupSpec      = node.groupSpec;
                data._groupLevelSpec = node.groupLevelSpec;
            }
            
            childNodes.forEach(function(childNode){
                this._generateData(childNode, node, data, rootData);
            }, this);

        } else if(isNew && !node.isRoot){
            // A leaf node
            var leafs = data.root._leafs;
            data.leafIndex = leafs.length;
            leafs.push(data);
        }
        
        return data;
    }
});
def
.type('pvc.data.LinearInterpolationOper')
.init(function(allPartsData, data, catRole, serRole, valRole, stretchEnds){
    this._newDatums = [];
    
    this._data = data;
    
    var allCatDataRoot = allPartsData.flattenBy(catRole, {ignoreNulls: false});
    var allCatDatas    = allCatDataRoot._children;
    
    var serDatas1 = this._serDatas1 = serRole.isBound() ?
                        data.flattenBy(serRole).children().array() :
                        [null]; // null series
    
    this._isCatDiscrete = catRole.grouping.isDiscrete();
    this._firstCatDim   = !this._isCatDiscrete ? data.owner.dimensions(catRole.firstDimensionName()) : null;
    this._stretchEnds    = stretchEnds;
    var valDim = this._valDim  = data.owner.dimensions(valRole.firstDimensionName());
    
    var visibleKeyArgs = {visible: true, zeroIfNone: false};
    
    this._catInfos = allCatDatas.map(function(allCatData, catIndex){
        
        var catData = data._childrenByKey[allCatData.key];
        
        var catInfo = {
            data:           catData || allCatData, // may be null?
            value:          allCatData.value,
            isInterpolated: false,
            serInfos:       null,
            index:          catIndex
        };
        
        catInfo.serInfos = 
            serDatas1
            .map(function(serData1){
                var group = catData;
                if(group && serData1){
                    group = group._childrenByKey[serData1.key];
                }
                
                var value = group ?
                            group.dimensions(valDim.name)
                                 .sum(visibleKeyArgs) : 
                            null;
                
                return {
                    data:    serData1,
                    group:   group,
                    value:   value,
                    isNull:  value == null,
                    catInfo: catInfo
                };
            }, this);
        
        return catInfo;
    });
    
    this._serCount  = serDatas1.length;
    this._serStates = 
        def
        .range(0, this._serCount)
        .select(function(serIndex){ 
            return new pvc.data.LinearInterpolationOperSeriesState(this, serIndex); 
        }, this)
        .array()
        ;
    
    // Determine the sort order of the continuous base categories
    // Categories assumed sorted.
//    if(!this._isCatDiscrete && catDatas.length >= 2){
//        if((+catDatas[1].value) >= (+catDatas[0].value)){
//            this._comparer = def.compare;
//        } else {
//            this._comparer = def.compareReverse;
//        }
//    }
})
.add({
    interpolate: function(){
        var catInfo;
        while((catInfo = this._catInfos.shift())){
            catInfo.serInfos.forEach(this._visitSeries, this);
        }
        
        // Add datums created during interpolation
        var newDatums = this._newDatums;
        if(newDatums.length){
            this._data.owner.add(newDatums);
        }
    },
    
    _visitSeries: function(catSerInfo, serIndex){
        this._serStates[serIndex].visit(catSerInfo);
    },
    
    nextUnprocessedNonNullCategOfSeries: function(serIndex){
        // NOTE: while interpolating, 
        // only catInfos remaining to be processed
        // remain in the _catInfos array (see {@link #interpolate}).
        // As such, this finds the "next" (unprocessed) 
        // non-null cat. info.
        var catIndex = 0,
            catCount = this._catInfos.length;
        
        while(catIndex < catCount){
            var catInfo = this._catInfos[catIndex++];
            //if(!catInfo.isInterpolated){
            var catSerInfo = catInfo.serInfos[serIndex];
            if(!catSerInfo.isNull){
                return catSerInfo;
            }
            //}
        }
    }

    // NOTE: This was only needed when selection needed to
    // divide in half between the last and next.
//    _setCategory: function(catValue){
//        /*jshint expr:true  */
//        !this._isCatDiscrete || def.assert("Only for continuous base.");
//        
//        // Insert sort into this._catInfos
//        
//        // catValue may be a new dimension value
//        var catAtom = this._firstCatDim.intern(catValue, /* isVirtual */ true);
//        
//        catValue = catAtom.value; // now may be a Date object...
//        
//        // Check if and where to insert
//        var index = 
//            def
//            .array
//            .binarySearch(
//                this._catInfos, 
//                +catValue,
//                this._comparer,
//                function(catInfo){  return +catInfo.value; });
//        
//        if(index < 0){
//            // New category
//            // Insert at the two's complement of index
//            var catInfo = {
//                atom:  catAtom,
//                value: catValue,
//                label: this._firstCatDim.format(catValue),
//                isInterpolated: true
//            };
//            
//            catInfo.serInfos = 
//                def
//                .range(0, this._serCount)
//                .select(function(serScene, serIndex){
//                    return {
//                        value:   null,
//                        isNull:  true,
//                        catInfo: catInfo
//                    };
//                })
//                .array();
//            
//            this._catInfos.splice(~index, 0, catInfo);
//        }
//        
//        return index;
//    }
});def
.type('pvc.data.LinearInterpolationOperSeriesState')
.init(function(interpolation, serIndex){
    this.interpolation = interpolation;
    this.index = serIndex;
    
    this._lastNonNull(null);
})
.add({
    visit: function(catSeriesInfo){
        if(catSeriesInfo.isNull){
            this._interpolate(catSeriesInfo);
        } else {
            this._lastNonNull(catSeriesInfo);
        }
    },
    
    _lastNonNull: function(catSerInfo){
        if(arguments.length){
            this.__lastNonNull = catSerInfo; // Last non-null
            this.__nextNonNull = undefined;
        }
        
        return this.__lastNonNull;
    },

    _nextNonNull: function(){
        return this.__nextNonNull;
    },
    
    _initInterpData: function(){
        // When a null category is found, 
        // and it is the first category, or it is right after a non-null category,
        // the prop. __nextNonNull will have the value undefined 
        // (because _nextNonNull is reset to undefined every time that __lastNonNull is set).
        //
        // Then, the __nextNonNull category is determined, 
        // by looking ahead of the current (null) category
        // (see {@link Interpolation#nextUnprocessedNonNullCategOfSeries}).
        // 
        // If both a last and a next exist,
        // the slope of the line connecting these is determined.
        // 
        // The next processed category, if null, will not
        // pass the test this.__nextNonNull !== undefined,
        // guaranteeing that this initialization is only performed
        // once for each series "segment" of null dots that is 
        // surrounded by non-null dots.
        
        // The start of a new segment?
        if(this.__nextNonNull !== undefined){
            return;
        }
        
        // Will be null if the series starts 
        //  with null categories:
        // S: 0 - 0 - x
        var last = this.__lastNonNull;
        
        // Make sure not to store undefined to distinguish from uninitialized.
        // When "last" is null, a non-null "next" is used in 
        //  {@link #_interpolate } to "extend" the beginning of the series.
        var next = this.__nextNonNull = 
           this.interpolation
               .nextUnprocessedNonNullCategOfSeries(this.index) || 
           null;
                                
        if(next && last){
            var fromValue  = last.value;
            var toValue    = next.value;
            var deltaValue = toValue - fromValue;
            
            if(this.interpolation._isCatDiscrete){
                var stepCount = next.catInfo.index - last.catInfo.index;
                /*jshint expr:true */
                (stepCount >= 2) || def.assert("Must have at least one interpolation point.");
                
                this._stepValue   = deltaValue / stepCount;
                this._middleIndex = ~~(stepCount / 2); // Math.floor <=> ~~
                
                var dotCount = (stepCount - 1);
                this._isOdd  = (dotCount % 2) > 0;
            } else {
                var fromCat  = +last.catInfo.value;
                var toCat    = +next.catInfo.value;
                var deltaCat = toCat - fromCat;
                
                this._steep = deltaValue / deltaCat; // should not be infinite, cause categories are different
                
                this._middleCat = (toCat + fromCat) / 2;
                
                // NOTE: This was only needed when selection needed to
                // divide in half between the last and next.
                // (Maybe) add a category
                //this.interpolation._setCategory(this._middleCat);
            }
        }
    },
    
    _interpolate: function(catSerInfo){
        this._initInterpData();
        
        var next = this.__nextNonNull;
        var last = this.__lastNonNull;
        var one  = next || last;
        if(!one){
            return;
        }
        
        var value, group/*, isInterpolatedMiddle*/;
        var interpolation = this.interpolation;
        var catInfo = catSerInfo.catInfo;
        
        if(next && last){
            if(interpolation._isCatDiscrete){
                var groupIndex = (catInfo.index - last.catInfo.index);
                value = last.value + this._stepValue * groupIndex;
                
                if(this._isOdd){
                    group = groupIndex < this._middleIndex ? last.group : next.group;
                    //isInterpolatedMiddle = groupIndex === this._middleIndex;
                } else {
                    group = groupIndex <= this._middleIndex ? last.group : next.group;
                    //isInterpolatedMiddle = false;
                }
                
            } else {
                var cat = +catInfo.value;
                var lastCat = +last.catInfo.value;
                
                value = last.value + this._steep * (cat - lastCat);
                group = cat < this._middleCat ? last.group : next.group;
                //isInterpolatedMiddle = cat === this._middleCat;
            }
        } else {
            // Only "stretch" ends on stacked visualization
            if(!interpolation._stretchEnds) {
                return;
            }
            
            value = one.value;
            group = one.group;
            //isInterpolatedMiddle = false;
        }
        
        // -----------
        
        // Multi, series, ... atoms, other measures besides valDim.
        var atoms = Object.create(group._datums[0].atoms);
        
        // Category atoms
        //if(interpolation._isCatDiscrete || !catInfo.isInterpolated){
        def.copyOwn(atoms, catInfo.data.atoms);
//        } else {
//            // cat is a new category value
//            var catAtom = catInfo.atom;
//            
//            atoms[catAtom.dimension.name] = catAtom;
//        }
        
        // Value atom
        var valueAtom = interpolation._valDim.intern(value, /* isVirtual */ true);
        atoms[valueAtom.dimension.name] = valueAtom;
        
        // Create datum with collected atoms
        var newDatum = new pvc.data.Datum(group.owner, atoms);
        
        newDatum.isVirtual = true;
        newDatum.isInterpolated = true;
        newDatum.interpolation = 'linear';
        
        //newDatum.isInterpolatedMiddle = isInterpolatedMiddle;
        
        interpolation._newDatums.push(newDatum);
    }
});def
.type('pvc.data.ZeroInterpolationOper')
.init(function(allPartsData, data, catRole, serRole, valRole, stretchEnds){
    this._newDatums = [];
    
    this._data = data;
    
    var allCatDataRoot = allPartsData.flattenBy(catRole, {ignoreNulls: false});
    var allCatDatas    = allCatDataRoot._children;
    
    var serDatas1 = this._serDatas1 = serRole.isBound() ?
                        data.flattenBy(serRole).children().array() :
                        [null]; // null series
    
    this._isCatDiscrete = catRole.grouping.isDiscrete();
    this._firstCatDim   = !this._isCatDiscrete ? data.owner.dimensions(catRole.firstDimensionName()) : null;
    this._stretchEnds   = stretchEnds;
    var valDim = this._valDim  = data.owner.dimensions(valRole.firstDimensionName());
    
    var visibleKeyArgs = {visible: true, zeroIfNone: false};
    
    this._catInfos = allCatDatas.map(function(allCatData, catIndex){
        
        var catData = data._childrenByKey[allCatData.key];
        
        var catInfo = {
            data:           catData || allCatData,
            value:          allCatData.value,
            isInterpolated: false,
            serInfos:       null,
            index:          catIndex
        };
        
        catInfo.serInfos = 
            serDatas1
            .map(function(serData1){
                var group = catData;
                if(group && serData1){
                    group = group._childrenByKey[serData1.key];
                }
                
                var value = group ?
                            group.dimensions(valDim.name)
                                 .sum(visibleKeyArgs) : 
                            null;
                
                return {
                    data:    serData1,
                    group:   group,
                    value:   value,
                    isNull:  value == null,
                    catInfo: catInfo
                };
            }, this);
        
        return catInfo;
    });
    
    this._serCount  = serDatas1.length;
    this._serStates = 
        def
        .range(0, this._serCount)
        .select(function(serIndex){ 
            return new pvc.data.ZeroInterpolationOperSeriesState(this, serIndex); 
        }, this)
        .array()
        ;
})
.add({
    interpolate: function(){
        var catInfo;
        while((catInfo = this._catInfos.shift())){
            catInfo.serInfos.forEach(this._visitSeries, this);
        }
        
        // Add datums created during interpolation
        var newDatums = this._newDatums;
        if(newDatums.length){
            this._data.owner.add(newDatums);
        }
    },
    
    _visitSeries: function(catSerInfo, serIndex){
        this._serStates[serIndex].visit(catSerInfo);
    },
    
    nextUnprocessedNonNullCategOfSeries: function(serIndex){
        var catIndex = 0,
            catCount = this._catInfos.length;
        
        while(catIndex < catCount){
            var catInfo = this._catInfos[catIndex++];
            var catSerInfo = catInfo.serInfos[serIndex];
            if(!catSerInfo.isNull){
                return catSerInfo;
            }
        }
    }
});def
.type('pvc.data.ZeroInterpolationOperSeriesState')
.init(function(interpolation, serIndex){
    this.interpolation = interpolation;
    this.index = serIndex;
    
    this._lastNonNull(null);
})
.add({
    visit: function(catSeriesInfo){
        if(catSeriesInfo.isNull){
            this._interpolate(catSeriesInfo);
        } else {
            this._lastNonNull(catSeriesInfo);
        }
    },
    
    _lastNonNull: function(catSerInfo){
        if(arguments.length){
            this.__lastNonNull = catSerInfo; // Last non-null
            this.__nextNonNull = undefined;
        }
        
        return this.__lastNonNull;
    },

    _nextNonNull: function(){
        return this.__nextNonNull;
    },
    
    _initInterpData: function(){
        // The start of a new segment?
        if(this.__nextNonNull !== undefined){
            return;
        }
        
        var last = this.__lastNonNull;
        var next = this.__nextNonNull = 
           this.interpolation
               .nextUnprocessedNonNullCategOfSeries(this.index) || 
           null;
                                
        if(next && last){
            var fromValue  = last.value;
            var toValue    = next.value;
            var deltaValue = toValue - fromValue;
            
            if(this.interpolation._isCatDiscrete){
                var stepCount = next.catInfo.index - last.catInfo.index;
                /*jshint expr:true */
                (stepCount >= 2) || def.assert("Must have at least one interpolation point.");
                
                this._middleIndex = ~~(stepCount / 2); // Math.floor <=> ~~
                
                var dotCount = (stepCount - 1);
                this._isOdd  = (dotCount % 2) > 0;
            } else {
                var fromCat  = +last.catInfo.value;
                var toCat    = +next.catInfo.value;
                this._middleCat = (toCat + fromCat) / 2;
            }
        }
    },
    
    _interpolate: function(catSerInfo){
        this._initInterpData();
        
        var next = this.__nextNonNull;
        var last = this.__lastNonNull;
        var one  = next || last;
        if(!one){
            return;
        }
        
        var group;
        var interpolation = this.interpolation;
        var catInfo = catSerInfo.catInfo;
        
        if(next && last){
            if(interpolation._isCatDiscrete){
                var groupIndex = (catInfo.index - last.catInfo.index);
                if(this._isOdd){
                    group = groupIndex < this._middleIndex ? last.group : next.group;
                } else {
                    group = groupIndex <= this._middleIndex ? last.group : next.group;
                }
                
            } else {
                var cat = +catInfo.value;
                group = cat < this._middleCat ? last.group : next.group;
            }
        } else {
            // Only "stretch" ends on stacked visualization
            if(!interpolation._stretchEnds) {
                return;
            }
            
            group = one.group;
        }
        
        // -----------
        
        // Multi, series, ... atoms, other measures besides valDim.
        var atoms = Object.create(group._datums[0].atoms);
        
        // Category atoms
        def.copyOwn(atoms, catInfo.data.atoms);
        
        // Value atom
        var zeroAtom = interpolation._zeroAtom ||
                       (interpolation._zeroAtom = 
                           interpolation._valDim.intern(0, /* isVirtual */ true));
        
        atoms[zeroAtom.dimension.name] = zeroAtom;
        
        // Create datum with collected atoms
        var newDatum = new pvc.data.Datum(group.owner, atoms);
        newDatum.isVirtual = true;
        newDatum.isInterpolated = true;
        newDatum.interpolation  = 'zero';
        
        interpolation._newDatums.push(newDatum);
    }
});pvc.data.Data.add(/** @lends pvc.data.Data# */{
    
    /**
     * Loads or reloads the data with the specified enumerable of atoms.
     * 
     * <p>
     * Can only be called on an owner data. 
     * Child datas are instead "loaded" on construction, 
     * with a subset of its parent's datums.
     * </p>
     * 
     * <p>
     * This method was designed to be fed with the output
     * of {@link pvc.data.TranslationOper#execute}.
     * </p>
     * 
     * @param {def.Query} atomz An enumerable of {@link map(string union(any || pvc.data.Atom))}.
     * @param {object} [keyArgs] Keyword arguments.
     * @param {function} [keyArgs.isNull] Predicate that indicates if a datum is considered null.
     * @param {function} [keyArgs.where] Filter function that approves or excludes each newly read new datum.
     */
    load: function(atomz, keyArgs){
        /*global data_assertIsOwner:true */
        data_assertIsOwner.call(this);
        
        var whereFun  = def.get(keyArgs, 'where');
        var isNullFun = def.get(keyArgs, 'isNull');
        var datums = 
            def
            .query(atomz)
            .select(function(atoms){
                var datum = new pvc.data.Datum(this, atoms);
                
                if(isNullFun && isNullFun(datum)){
                    datum.isNull = true;
                }
                
                if(whereFun && !whereFun(datum)) {
                    return null;
                }
                
                return datum;
            }, this)
            ;
        
        data_setDatums.call(this, datums, { doAtomGC: true });
    },
    
    clearVirtuals: function(){
        // Recursively clears all virtual datums and atoms
        var datums = this._datums;
        if(datums){
            this._sumAbsCache = null;
            
            var visibleDatums  = this._visibleDatums;
            var selectedDatums = this._selectedDatums;
            
            var i = 0;
            var L = datums.length;
            var removed;
            while(i < L){
                var datum = datums[i];
                if(datum.isVirtual){
                    var id = datum.id;
                    if(selectedDatums && datum.isSelected) {
                        selectedDatums.rem(id);
                    }
                    
                    if(datum.isVisible) {
                        visibleDatums.rem(id);
                    }
                    
                    datums.splice(i, 1);
                    L--;
                    removed = true;
                } else {
                    i++;
                }
            }
            
            if(removed){
                if(!datums.length && this.parent){
                    // "Me is a group"
                    this.dispose();
                    return;
                }

                var children = this._children;
                if(children){
                    i = 0;
                    L = children.length;
                    while(i < L){
                        var childData = children[i];
                        childData.clearVirtuals();
                        if(!childData.parent){
                            // Child group was empty and removed itself
                            L--;
                        } else {
                            i++;
                        }
                    }
                }
                
                if(this._linkChildren){
                    this._linkChildren.forEach(function(linkChildData){
                        linkChildData.clearVirtuals();
                    });
                }
            }
        }
        
        def.eachOwn(this._dimensions, function(dim){
            /*global dim_uninternVirtualAtoms:true*/
            dim_uninternVirtualAtoms.call(dim);
        });
    },
    
    /**
     * Adds new datums to the owner data.
     * @param {pvc.data.Datum[]|def.Query} datums The datums to add. 
     */
    add: function(datums){
        /*global data_assertIsOwner:true */
        data_assertIsOwner.call(this);
        
        /*global data_setDatums:true */
        data_setDatums.call(this, datums, {
            isAdditive: true,
            doAtomGC:   true 
        });
    },
    
    /**
     * Groups the datums of this data, possibly filtered,
     * according to a grouping specification.
     * 
     * <p>
     * The result of the grouping operation over a set of datums
     * is a new <i>linked child</i> data.
     * 
     * It is a root data, 
     * but shares the same {@link #owner} and {@link #atoms} with this,
     * and has the considered datums in {@link #datums}.
     * 
     * The data will contain one child data per distinct atom,
     * of the first grouping level dimension, 
     * found in the datums.
     * Each child data will contain the datums sharing that atom.
     * 
     * This logic extends to all following grouping levels.
     * </p>
     * 
     * <p>
     * Datums with null atoms on a grouping level dimension are excluded.
     * </p>
     * 
     * @param {string|string[]|pvc.data.GroupingOperSpec} groupingSpecText A grouping specification string or object.
     * <pre>
     * "series1 asc, series2 desc, category"
     * </pre>
     * 
     * @param {Object} [keyArgs] Keyword arguments object.
     * See additional keyword arguments in {@link pvc.data.GroupingOper}
     * 
     * @see #where
     * @see pvc.data.GroupingLevelSpec
     *
     * @returns {pvc.data.Data} The resulting root data.
     */
    groupBy: function(groupingSpecText, keyArgs){
        var groupOper = new pvc.data.GroupingOper(this, groupingSpecText, keyArgs),
            cacheKey  = groupOper.key,
            groupByCache,
            data;

        if(cacheKey){
            groupByCache = this._groupByCache;

            // Check cache for a linked data with that key
            data = groupByCache && groupByCache[cacheKey];
        }

        if(!data) {
            if(pvc.debug >= 7){
                pvc.log("[GroupBy] " + (cacheKey ? ("Cache key not found: '" + cacheKey + "'") : "No Cache key"));
            }
            
            data = groupOper.execute();

            if(cacheKey){
                (groupByCache || (this._groupByCache = {}))[cacheKey] = data;
            }
        } else if(pvc.debug >= 7){
            pvc.log("[GroupBy] Cache key hit '" + cacheKey + "'");
        }
        
        return data;
    },

    flattenBy: function(role, keyArgs){
        var grouping = role.flattenedGrouping(keyArgs) || 
                       def.fail.operationInvalid("Role is unbound.");
        
        return this.groupBy(grouping, keyArgs);
    },
    
    /**
     * Creates a linked data with the result of filtering
     * the datums of this data.
     *
     * <p>
     * This operation differs from {@link #datums} only in the type of output,
     * which is a new linked data, instead of an enumerable of the filtered datums.
     * See {@link #datums} for more information on the filtering operation.
     * </p>
     *
     * @param {object} [whereSpec] A "where" specification.
     * @param {object} [keyArgs] Keyword arguments object.
     * See {@link #datums} for information on available keyword arguments.
     *
     * @returns {pvc.data.Data} A linked data containing the filtered datums.
     */
    where: function(whereSpec, keyArgs){
        var datums = this.datums(whereSpec, keyArgs);
        return new pvc.data.Data({linkParent: this, datums: datums});
    },

    /**
     * Obtains the datums of this data, 
     * possibly filtered according 
     * to a specified "where" specification,
     * datum selected state and 
     * filtered atom visible state.
     *
     * @param {object} [whereSpec] A "where" specification.
     * A structure with the following form:
     * <pre>
     * // OR of datum filters
     * whereSpec = [datumFilter1, datumFilter2, ...] | datumFilter;
     * 
     * // AND of dimension filters
     * datumFilter = {
     *      // OR of dimension values
     *      dimName1: [value1, value2, ...],
     *      dimName2: value1,
     *      ...
     * }
     * </pre>
     * <p>Values of a datum filter can also directly be atoms.</p>
     * <p>
     *    An example of a "where" specification:
     * </p>
     * <pre>
     * whereSpec = [
     *     // Datums whose series is 'Europe' or 'Australia', 
     *     // and whose category is 2001 or 2002 
     *     {series: ['Europe', 'Australia'], category: [2001, 2002]},
     *     
     *     // Union'ed with
     *     
     *     // Datums whose series is 'America' 
     *     {series: 'America'},
     * ];
     * </pre>
     *  
     * @param {object} [keyArgs] Keyword arguments object.
     * 
     * @param {boolean} [keyArgs.isNull=null]
     *      Only considers datums with the specified isNull attribute.
     * 
     * @param {boolean} [keyArgs.visible=null]
     *      Only considers datums that have the specified visible state.
     * 
     * @param {boolean} [keyArgs.selected=null]
     *      Only considers datums that have the specified selected state.
     * 
     * @param {function} [keyArgs.where] A arbitrary datum predicate.
     *
     * @param {string[]} [keyArgs.orderBySpec] An array of "order by" strings to be applied to each 
     * datum filter of <i>whereSpec</i>.
     * <p>
     * An "order by" string is the same as a grouping specification string, 
     * although it is used here with a slightly different meaning.
     * Here's an example of an "order by" string:
     * <pre>
     * "series1 asc, series2 desc, category"
     * </pre
     * </p>
     * 
     * <p>
     * When not specified, altogether or individually, 
     * these are determined to match the corresponding datum filter of <i>whereSpec</i>.
     * </p>
     * 
     * <p>
     * If a string is specified it is treated as the "order by" string corresponding 
     * to the first datum filter.
     * </p>
     * 
     * @returns {def.Query} A query object that enumerates the desired {@link pvc.data.Datum}.
     */
    datums: function(whereSpec, keyArgs){
        if(!whereSpec){
            if(!keyArgs){
                return def.query(this._datums);
            }
            
            return data_whereState(def.query(this._datums), keyArgs);
        }
        
        whereSpec = data_processWhereSpec.call(this, whereSpec, keyArgs);
        
        return data_where.call(this, whereSpec, keyArgs);
    },
    
    /**
     * Obtains the first datum that 
     * satisfies a specified "where" specification.
     * <p>
     * If no datum satisfies the filter, null is returned.
     * </p>
     * 
     * @param {object} whereSpec A "where" specification.
     * See {@link #datums} to know about this structure.
     * 
     * @param {object} [keyArgs] Keyword arguments object.
     * See {@link #datums} for additional available keyword arguments.
     * 
     * @param {boolean} [keyArgs.createNull=false] Indicates if a 
     * null datum should be returned when no datum is satisfied the specified filter.
     * <p>
     * The assumption is that the "where" specification
     * contains one datum filter, and in turn,
     * that it specifies <b>all</b> the dimensions of this data's complex type.  
     * </p>
     * <p>
     * The first specified datum filter is used as a source to the datums' atoms.
     * Also, it is the first atom of each dimension filter that is used.
     * </p>
     * 
     * @returns {pvc.data.Datum} 
     * The first datum that satisfies the specified filter, 
     * a null datum, if <i>keyArgs.createNull</i> is truthy, 
     * or <i>null</i>.
     * 
     * @see pvc.data.Data#datums 
     */
    datum: function(whereSpec, keyArgs){
        /*jshint expr:true */
        whereSpec || def.fail.argumentRequired('whereSpec');
        
        whereSpec = data_processWhereSpec.call(this, whereSpec, keyArgs);
        
        var datum = data_where.call(this, whereSpec, keyArgs).first() || null;
        if(!datum && def.get(keyArgs, 'createNull') && whereSpec.length) {
            
            /* Create Null Datum */
            var sourceDatumFilter = whereSpec[0],
                atoms = {};
            
            for(var dimName in this._dimensions){
                var dimAtoms = sourceDatumFilter[dimName];
                if(dimAtoms) {
                    atoms[dimName] = dimAtoms[0];
                }
            }
            
            // true => null datum
            datum = new pvc.data.Datum(this, atoms, true);
        }
        
        return datum;
    },
    
    /**
     * Obtains the first datum of this data, if any.
     * @type {pvc.data.Datum} The first datum or <i>null</i>. 
     */
    firstDatum: function(){
        return this._datums.length ? this._datums[0] : null;
    },
    
    /**
     * Sums the absolute value 
     * of the sum of a specified dimension on each child.
     *
     * @param {string} dimName The name of the dimension to sum on each child data.
     * @param {object} [keyArgs] Optional keyword arguments that are
     * passed to each dimension's {@link pvc.data.Dimension#sum} method.
     * 
     * @type number
     */
    dimensionsSumAbs: function(dimName, keyArgs){
        /*global dim_buildDatumsFilterKey:true */
        var key = dimName + ":" + dim_buildDatumsFilterKey(keyArgs),
            sum = def.getOwn(this._sumAbsCache, key);

        if(sum == null) {
            sum = this.children()
                    /* non-degenerate flattened parent groups would account for the same values more than once */
                    .where(function(childData){ return !childData._isFlattenGroup || childData._isDegenerateFlattenGroup; })
                    .select(function(childData){
                        return Math.abs(childData.dimensions(dimName).sum(keyArgs));
                    }, this)
                    .reduce(def.add, 0);

            (this._sumAbsCache || (this._sumAbsCache = {}))[key] = sum;
        }

        return sum;
    }
});


/**
 * Called to add or replace the contained {@link pvc.data.Datum} instances. 
 * 
 * When replacing, all child datas and linked child datas are disposed.
 * 
 * When adding, the specified datums will be added recursively 
 * to this data's parent or linked parent, and its parent, until the owner data is reached.
 * When crossing a linked parent, 
 * the other linked children of that parent
 * are given a chance to receive a new datum, 
 * and it will be added if it satisfies its inclusion criteria.
 * 
 * The datums' atoms must be consistent with the base atoms of this data.
 * If this data inherits a non-null atom in a given dimension and:
 * <ul>
 * <li>a datum has another non-null atom, an error is thrown.</li>
 * <li>a datum has a null atom, an error is thrown.
 * </ul>
 * 
 * @name pvc.data.Data#_setDatums
 * @function
 * @param {pvc.data.Datum[]|def.Query} newDatums An array or enumerable of datums.
 * When an array, and in replace mode, 
 * it is used directly to keep the stored datums and may be modified if necessary.
 * 
 * @param {object} [keyArgs] Keyword arguments.
 * 
 * @param {boolean} [keyArgs.isAdditive=false] Indicates that the specified datums are to be added, 
 * instead of replace existing datums.
 * 
 * @param {boolean} [keyArgs.doAtomGC=true] Indicates that atom garbage collection should be performed.
 * 
 * @type undefined
 * @private
 */
function data_setDatums(newDatums, keyArgs){
    // But may be an empty list
    /*jshint expr:true */
    newDatums || def.fail.argumentRequired('newDatums');
    
    var doAtomGC   = def.get(keyArgs, 'doAtomGC',   false);
    var isAdditive = def.get(keyArgs, 'isAdditive', false);
    
    var visibleDatums  = this._visibleDatums;
    var selectedDatums = this._selectedDatums;
    
    var newDatumsByKey = {};
    var prevDatumsByKey;
    var prevDatums = this._datums;
    if(prevDatums){
        // Visit atoms of existing datums
        // We cannot simply mark all atoms of every dimension
        // cause now, the dimensions may already contain new atoms
        // used (or not) by the new datums
        var processPrevAtoms = isAdditive && doAtomGC;
        
        // Index existing datums by (semantic) key
        // So that old datums may be preserved
        prevDatumsByKey = 
            def
            .query(prevDatums)
            .uniqueIndex(function(datum){
                
                if(processPrevAtoms){ // isAdditive && doAtomGC
                    data_processDatumAtoms.call(
                            this, 
                            datum, 
                            /* intern */      false, 
                            /* markVisited */ true);
                }
                
                return datum.key;
            }, this);
        
        // Clear caches and/or children
        if(isAdditive){
            this._sumAbsCache = null;
        } else {
            /*global data_disposeChildLists:true*/
            data_disposeChildLists.call(this);
            if(selectedDatums) { selectedDatums.clear(); }
            visibleDatums.clear();
        }
    } else {
        isAdditive = false;
    }
    
    var datumsById;
    if(isAdditive){
        datumsById = this._datumsById;
    } else {
        datumsById = this._datumsById = {};
    }
    
    if(def.array.is(newDatums)){
        var i = 0;
        var L = newDatums.length;
        while(i < L){
            var inDatum  = newDatums[i];
            var outDatum = setDatum.call(this, inDatum);
            if(!outDatum){
                newDatums.splice(i, 1);
                L--;
            } else {
                if(outDatum !== inDatum){
                    newDatums[i] = outDatum;
                }
                i++;
            }
        }
    } else if(newDatums instanceof def.Query){
        newDatums = 
            newDatums
            .select(setDatum, this)
            .where(def.notNully)
            .array();
    } else {
        throw def.error.argumentInvalid('newDatums', "Argument is of invalid type.");
    }
    
    if(doAtomGC){
        // Atom garbage collection
        // Unintern unused atoms
        def.eachOwn(this._dimensions, function(dimension){
            /*global dim_uninternUnvisitedAtoms:true*/
            dim_uninternUnvisitedAtoms.call(dimension);
        });
    }
    
    if(isAdditive){
        // newDatums contains really new datums (excluding duplicates)
        // These can be further filtered in the grouping operation
        
        def.array.append(prevDatums, newDatums);
        
        // II - Distribute added datums by linked children
        if(this._linkChildren){
            this._linkChildren.forEach(function(linkChildData){
                data_addDatumsSimple.call(linkChildData, newDatums);
            });
        }
    } else {
        this._datums = newDatums;
    }
    
    function setDatum(newDatum){
        if(!newDatum){
            // Ignore
            return;
        }
        
        /* Use already existing same-key datum, if any */
        var key = newDatum.key;
        
        if(def.hasOwnProp.call(newDatumsByKey, key)){
            // Duplicate in input datums, ignore
            return;
        }
        
        if(prevDatumsByKey){
            var prevDatum = def.getOwn(prevDatumsByKey, key);
            if(prevDatum){
                // Duplicate with previous datums
                if(isAdditive){
                    // Ignore
                    return;
                }
                
                // Prefer to *re-add* the old datum and ignore the new one
                // Not new
                newDatum = prevDatum;
                
                // The old datum is going to be kept.
                // In the end, it will only contain the datums that were "removed"
                //delete prevDatumsByKey[key];
            }
            // else newDatum is really new
        }
        
        newDatumsByKey[key] = newDatum;
        
        var id = newDatum.id;
        datumsById[id] = newDatum;
        
        data_processDatumAtoms.call(
                this,
                newDatum,
                /* intern      */ !!this._dimensions, // When creating a linked data, datums are set when dimensions aren't yet created. 
                /* markVisited */ doAtomGC);
        
        // TODO: make this lazy?
        if(!newDatum.isNull){
            if(selectedDatums && newDatum.isSelected) {
                selectedDatums.set(id, newDatum);
            }
        
            if(newDatum.isVisible) {
                visibleDatums.set(id, newDatum);
            }
        }
        
        return newDatum;
    }
}

/**
 * Processes the atoms of this datum.
 * If a virtual null atom is found then the null atom of that dimension
 * is interned.
 * If desired the processed atoms are marked as visited.
 * 
 * @name pvc.data.Datum._processAtoms
 * @function
 * @param {boolean} [intern=false] If virtual nulls should be detected.
 * @param {boolean} [markVisited=false] If the atoms should be marked as visited. 
 * @type undefined
 * @internal
 */
function data_processDatumAtoms(datum, intern, markVisited){
    
    var dims = this._dimensions;
    if(!dims){
        // data is still initializing and dimensions are not yet created
        intern = false;
    }
    
    def.each(datum.atoms, function(atom){
        if(intern){
            // Ensure that the atom exists in the local dimension
            
            var localDim = def.getOwn(dims, atom.dimension.name) ||
                           def.fail.argumentInvalid("Datum has atoms of foreign dimension.");
            
            /*global dim_internAtom:true */
            dim_internAtom.call(localDim, atom);
        }
        
        if(markVisited){
            // Mark atom as visited
            atom.visited = true;
        }
    });
}

function data_addDatumsSimple(newDatums){
    // But may be an empty list
    /*jshint expr:true */
    newDatums || def.fail.argumentRequired('newDatums');
    
    var groupOper = this._groupOper;
    if(groupOper){
        // This data gets its datums, 
        //  possibly filtered (groupOper calls data_addDatumsLocal).
        // Children get their new datums.
        // Linked children of children get their new datums.
        newDatums = groupOper.executeAdd(this, newDatums);
    } else {
        data_addDatumsLocal.call(this, newDatums);
    }
    
    // Distribute added datums by linked children
    if(this._linkChildren){
        this._linkChildren.forEach(function(linkChildData){
            data_addDatumsSimple.call(linkChildData, newDatums);
        });
    }
}

function data_addDatumsLocal(newDatums){
    var visibleDatums  = this._visibleDatums;
    var selectedDatums = this._selectedDatums;
    
    // Clear caches
    this._sumAbsCache = null;
    
    var datumsById = this._datumsById;
    var datums = this._datums;
    
    newDatums.forEach(addDatum, this);
    
    function addDatum(newDatum){
        var id = newDatum.id;
        
        datumsById[id] = newDatum;
        
        data_processDatumAtoms.call(
                this,
                newDatum,
                /* intern      */ true, 
                /* markVisited */ false);
        
        // TODO: make this lazy?
        if(!newDatum.isNull){
            if(selectedDatums && newDatum.isSelected) {
                selectedDatums.set(id, newDatum);
            }
        
            if(newDatum.isVisible) {
                visibleDatums.set(id, newDatum);
            }
        }
        
        datums.push(newDatum);
    }
}

/**
 * Processes a given "where" specification.
 * <p>
 * Normalizes and validates the specification syntax, 
 * validates dimension names,
 * readily excludes uninterned (unexistent) and duplicate values and
 * atoms based on their "visible state".
 * </p>
 * 
 * <p>
 * The returned specification contains dimensions instead of their names
 * and atoms, instead of their values. 
 * </p>
 * 
 * @name pvc.data.Data#_processWhereSpec
 * @function
 * 
 * @param {object} whereSpec A "where" specification to be normalized.
 * TODO: A structure with the following form: ... 
 *
 * @return Array A <i>processed</i> "where" of the specification.
 * A structure with the following form:
 * <pre>
 * // OR of processed datum filters
 * whereProcSpec = [datumProcFilter1, datumProcFilter2, ...] | datumFilter;
 * 
 * // AND of processed dimension filters
 * datumProcFilter = {
 *      // OR of dimension atoms
 *      dimName1: [atom1, atom2, ...],
 *      dimName2: atom1,
 *      ...
 * }
 * </pre>
 * 
 * @private
 */
function data_processWhereSpec(whereSpec){
    var whereProcSpec = [];
    
    whereSpec = def.array.as(whereSpec);
    if(whereSpec){
        whereSpec.forEach(processDatumFilter, this);
    }
    
    return whereProcSpec;
    
    function processDatumFilter(datumFilter){
        if(datumFilter != null) {
            /*jshint expr:true */
            (typeof datumFilter === 'object') || def.fail.invalidArgument('datumFilter');
            
            /* Map: {dimName1: atoms1, dimName2: atoms2, ...} */
            var datumProcFilter = {},
                any = false;
            for(var dimName in datumFilter) {
                var atoms = processDimensionFilter.call(this, dimName, datumFilter[dimName]);
                if(atoms) {
                    any = true;
                    datumProcFilter[dimName] = atoms;
                }
            }
            
            if(any) {
                whereProcSpec.push(datumProcFilter);
            }
        }
    }
    
    function processDimensionFilter(dimName, values){
        // throws if it doesn't exist
        var dimension = this.dimensions(dimName),
            atoms = def.query(values)
                       .select(function(value){ return dimension.atom(value); }) // null if it doesn't exist
                       .where(def.notNully)
                       .distinct(function(atom){ return atom.key; })
                       .array();
        
        return atoms.length ? atoms : null;
    }
}

/**
 * Filters a datum query according to a specified predicate, 
 * datum selected and visible state.
 * 
 * @name pvc.data.Data#_whereState
 * @function
 * 
 * @param {def.query} q A datum query.
 * @param {object} [keyArgs] Keyword arguments object.
 * See {@link #groupBy} for additional available keyword arguments.
 * 
 * @returns {def.Query} A query object that enumerates the desired {@link pvc.data.Datum}.
 * @private
 * @static
 */
function data_whereState(q, keyArgs){
    var selected = def.get(keyArgs, 'selected'),
        visible  = def.get(keyArgs, 'visible'),
        where    = def.get(keyArgs, 'where'),
        isNull   = def.get(keyArgs, 'isNull')
        ;

    if(visible != null){
        q = q.where(function(datum){ return datum.isVisible === visible; });
    }
    
    if(isNull != null){
        q = q.where(function(datum){ return datum.isNull === isNull; });
    }
    
    if(selected != null){
        q = q.where(function(datum){ return datum.isSelected === selected; });
    }
    
    if(where){
        q = q.where(where);
    }
    
    return q;
}

// All the "Filter" and "Spec" words below should be read as if they were prepended by "Proc"
/**
 * Obtains the datums of this data filtered according to 
 * a specified "where" specification,
 * and optionally, 
 * datum selected state and filtered atom visible state.
 * 
 * @name pvc.data.Data#_where
 * @function
 * 
 * @param {object} [whereSpec] A <i>processed</i> "where" specification.
 * @param {object} [keyArgs] Keyword arguments object.
 * See {@link #groupBy} for additional available keyword arguments.
 * 
 * @param {string[]} [keyArgs.orderBySpec] An array of "order by" strings to be applied to each 
 * datum filter of <i>whereSpec</i>.
 * 
 * @returns {def.Query} A query object that enumerates the desired {@link pvc.data.Datum}.
 * @private
 */
function data_where(whereSpec, keyArgs) {
    
    var orderBys = def.array.as(def.get(keyArgs, 'orderBy')),
        datumKeyArgs = def.create(keyArgs || {}, {
            orderBy: null
        });
    
    var query = def.query(whereSpec)
                   .selectMany(function(datumFilter, index){
                      if(orderBys) {
                          datumKeyArgs.orderBy = orderBys[index];
                      }
                      
                      return data_whereDatumFilter.call(this, datumFilter, datumKeyArgs);
                   }, this);
    
    return query.distinct(function(datum){ return datum.id; });
    
    /*
    // NOTE: this is the brute force / unguided algorithm - no indexes are used
    function whereDatumFilter(datumFilter, index){
        // datumFilter = {dimName1: [atom1, OR atom2, OR ...], AND ...}
        
        return def.query(this._datums).where(datumPredicate, this);
        
        function datumPredicate(datum){
            if((selected === null || datum.isSelected === selected) && 
               (visible  === null || datum.isVisible  === visible)) {
                var atoms = datum.atoms;
                for(var dimName in datumFilter) {
                    if(datumFilter[dimName].indexOf(atoms[dimName]) >= 0) {
                        return true;
                    }
                }   
            }
        }
    }
    */    
}

/**
 * Obtains an enumerable of the datums satisfying <i>datumFilter</i>,
 * by constructing and traversing indexes.
 * 
 * @name pvc.data.Data#_whereDatumFilter
 * @function
 * 
 * @param {string} datumFilter A <i>processed</i> datum filter.
 * 
 * @param {Object} keyArgs Keyword arguments object.
 * See {@link #groupBy} for additional available keyword arguments.
 * 
 * @param {string} [keyArgs.orderBy] An "order by" string.
 * When not specified, one is determined to match the specified datum filter.
 * The "order by" string cannot contain multi-dimension levels (dimension names separated with "|").
 * 
 * @returns {def.Query} A query object that enumerates the desired {@link pvc.data.Datum}.
 * 
 * @private
 */
function data_whereDatumFilter(datumFilter, keyArgs) {
     var groupingSpecText = keyArgs.orderBy; // keyArgs is required
     if(!groupingSpecText) {
         // Choose the most convenient one.
         // A sort on dimension names can yield good cache reuse.
         groupingSpecText = Object.keys(datumFilter).sort().join(',');
     } else {
         if(groupingSpecText.indexOf("|") >= 0) {
             throw def.error.argumentInvalid('keyArgs.orderBy', "Multi-dimension order by is not supported.");
         }
         
         // TODO: not validating that groupingSpecText actually contains the same dimensions referred in datumFilter...
     }
     
     /*
        // NOTE:
        // All the code below is just a stack/state-based translation of 
        // the following recursive code (so that it can be used lazily with a def.query):
        
        recursive(rootData, 0);
        
        function recursive(parentData, h) {
            if(h >= H) {
                // Leaf
                parentData._datums.forEach(fun, ctx);
                return;
            }
            
            var dimName = parentData._groupLevelSpec.dimensions[0].name;
            datumFilter[dimName].forEach(function(atom){
                var childData = parentData._childrenByKey[atom.globalKey];
                if(childData) {
                    recursive(childData, h + 1);
                }
            }, this);
        }
     */
     
     var rootData = this.groupBy(groupingSpecText, keyArgs),
     H = rootData.treeHeight;
     
     var stateStack = [];
     
     // Ad-hoq query
     return def.query(function(/* nextIndex */){
         // Advance to next datum
         var state;

         // No current data means starting
         if(!this._data) {
             this._data = rootData;
             this._dimAtomsOrQuery = def.query(datumFilter[rootData._groupLevelSpec.dimensions[0].name]);
             
         // Are there still any datums of the current data to enumerate?
         } else if(this._datumsQuery) { 
             
             // <Debug>
             /*jshint expr:true */
             this._data || def.assert("Must have a current data");
             stateStack.length || def.assert("Must have a parent data"); // cause the root node is "dummy"
             !this._dimAtomsOrQuery || def.assert();
             // </Debug>
             
             if(this._datumsQuery.next()){
                 this.item = this._datumsQuery.item; 
                 return 1; // has next
             }
             
             // No more datums here
             // Advance to next leaf data node
             this._datumsQuery = null;
             
             // Pop parent data
             state = stateStack.pop();
             this._data = state.data;
             this._dimAtomsOrQuery = state.dimAtomsOrQuery;
         } 
         
         // <Debug>
         this._dimAtomsOrQuery || def.assert("Invalid programmer");
         this._data || def.assert("Must have a current data");
         // </Debug>
         
         // Are there still any OrAtom paths of the current data to traverse? 
         var depth = stateStack.length;
             
         // Any more atom paths to traverse, from the current data?
         do{
             while(this._dimAtomsOrQuery.next()) {
                 
                 var dimAtomOr = this._dimAtomsOrQuery.item,
                     childData = this._data._childrenByKey[dimAtomOr.key];
                 
                 // Also, advance the test of a leaf child data with no datums, to avoid backtracking
                 if(childData && (depth < H - 1 || childData._datums.length)) {
                     
                     stateStack.push({data: this._data, dimAtomsOrQuery: this._dimAtomsOrQuery});
                     
                     this._data = childData;
                     
                     if(depth < H - 1) {
                         // Keep going up, until a leaf datum is found. Then we stop.
                         this._dimAtomsOrQuery = def.query(datumFilter[childData._groupLevelSpec.dimensions[0].name]);
                         depth++;
                     } else {
                         // Leaf data!
                         // Set first datum and leave
                         this._dimAtomsOrQuery = null;
                         this._datumsQuery = def.query(childData._datums);
                         this._datumsQuery.next();
                         this.item = this._datumsQuery.item;
                         return 1; // has next
                     }
                 }
             } // while(atomsOrQuery)
             
             // No more OR atoms in this _data
             if(!depth){
                 return 0; // finished
             }
             
             // Pop parent data
             state = stateStack.pop();
             this._data = state.data;
             this._dimAtomsOrQuery = state.dimAtomsOrQuery;
             depth--;
         } while(true);
         
         // Never executes
         return 0; // finished
     });
}pvc.data.Data
.add(/** @lends pvc.data.Data# */{
    /**
     * Returns some information on the data points
     */
    getInfo: function(){

        var out = ["DATA TYPE SUMMARY", pvc.logSeparator];
        
        def.eachOwn(this.dimensions(), function(dimension, name){
            var count = dimension.count(),
                type = dimension.type,
                features = [];
            
            features.push('"' + type.label + '"');
            features.push(type.valueTypeName);
            
            if(type.isComparable){ features.push("comparable"); }
            if(!type.isDiscrete){ features.push("continuous"); }
            if(type.isHidden){ features.push("hidden"); }
            
            out.push(
                "  " + 
                name +
                " (" + features.join(', ') + ")" +
                " (" + count + ")\n\t" + 
                dimension.atoms().slice(0, 10).map(function(atom){ return atom.label; }).join(", ") + 
                (count > 10 ? "..." : ""));
        });
        
        out.push(pvc.logSeparator);

        return out.join("\n");
    },
    
    /**
     * Returns the values for the dataset
     * BoxPlot, DataTree, ParallelCoordinates
     * 
     * @deprecated
     */
    getValues: function(){
        /**
         * Values is the inner Vs matrix
         *  X | S1  | ... | S2  |
         * ----------------------
         * C1 | V11 | ... | VN1 |
         *  . |   .           .
         * CJ | V1J | ... | VNJ |
         */
        return pv.range(0, this.getCategoriesSize())
            .map(function(categIndex){
                return this._getValuesForCategoryIndex(categIndex);
            }, this);
    },
    
    /**
     * Returns the unique values of a given dimension.
     * 
     * @deprecated
     */
    _getDimensionValues: function(name){
        return this.dimensions(name).atoms().map(function(atom){ return atom.value; });
    },

    /**
     * Returns the unique visible values of a given dimension.
     * 
     * @deprecated
     */
    _getDimensionVisibleValues: function(name){
        return this.dimensions(name).atoms({visible: true}).map(function(atom){ return atom.value; });
    },
    
    /**
     * Returns the unique series values.
     * @deprecated
     */
    getSeries: function(){
        return this._getDimensionValues('series');
    },

    /**
     * Returns an array with the indexes of the visible series values.
     * @deprecated
     */
    getVisibleSeriesIndexes: function(){
        return this.dimensions('series').indexes({visible: true});
    },
    
    /**
     * Returns an array with the indexes of the visible category values.
     * @deprecated
     */
    getVisibleCategoriesIndexes: function(){
        return this.dimensions('category').indexes({visible: true});
    },

    /**
     * Returns an array with the visible series.
     * @deprecated
     */
    getVisibleSeries: function(){
        return this._getDimensionVisibleValues('series');
    },

    /**
     * Returns the categories on the underlying data
     * @deprecated
     */
    getCategories: function(){
        return this._getDimensionValues('category');
    },

    /**
     * Returns an array with the visible categories.
     * 
     * @deprecated
     */
    getVisibleCategories: function(){
        return this._getDimensionVisibleValues('category');
    },
    
    /**
     * Returns the values for a given category index
     * @deprecated
     */
    _getValuesForCategoryIndex: function(categIdx){
        var categAtom = this.dimensions('category').atoms()[categIdx];
        var datumsBySeriesKey = this.datums({category: categAtom})
                                    .uniqueIndex(function(datum){ return datum.atoms.series.key; });
        
        // Sorted series atoms
        return this.dimensions('series')
                   .atoms()
                   .map(function(atom){
                        var datum = def.getOwn(datumsBySeriesKey, atom.key);
                        return datum ? datum.atoms.value.value : null;
                    });
    },
    
    /**
     * Returns how many series we have
     * @deprecated
     */
    getSeriesSize: function(){
        var dim = this.dimensions('series', {assertExists: false});
        return dim ? dim.count() : 0;
    },

    /**
     * Returns how many categories, or data points, we have
     * @deprecated
     */
    getCategoriesSize: function(){
        var dim = this.dimensions('category', {assertExists: false});
        return dim ? dim.count() : 0;
    }
});
/**
 * Initializes a visual role.
 * 
 * @name pvc.visual.Role
 * 
 * @class Represents a role that is somehow played by a visualization.
 * 
 * @property {string} name The name of the role.
 *
 * @property {string} label
 * The label of this role.
 * The label <i>should</i> be unique on a visualization.
 *
 * @property {pvc.data.GroupingSpec} grouping The grouping specification currently bound to the visual role.
 * 
 * @property {boolean} isRequired Indicates that the role is required and must be satisfied.
 * 
 * @property {boolean} requireSingleDimension Indicates that the role can only be satisfied by a single dimension.
 * A {@link pvc.visual.Role} of this type must have an associated {@link pvc.data.GroupingSpec}
 * that has {@link pvc.data.GroupingSpec#isSingleDimension} equal to <tt>true</tt>.
 * 
 * @property {boolean} valueType When not nully, 
 * restricts the allowed value type of the single dimension of the 
 * associated {@link pvc.data.GroupingSpec} to this type.
 * 
 * @property {boolean|null} requireIsDiscrete
 * Indicates if 
 * only discrete, when <tt>true</tt>, 
 * continuous, when <tt>false</tt>, 
 * or any, when <tt>null</tt>,
 * groupings are accepted.
 * 
 * @property {string} defaultDimensionName The default dimension name.
 *
 * @property {boolean} autoCreateDimension Indicates if a dimension with the default name (the first level of, when a group name),
 * should be created when the role has not been read by a translator (required or not).
 *
 * @constructor
 * @param {string} name The name of the role.
 * @param {object} [keyArgs] Keyword arguments.
 * @param {string} [keyArgs.label] The label of this role.
 *
 * @param {boolean} [keyArgs.isRequired=false] Indicates a required role.
 * 
 * @param {boolean} [keyArgs.requireSingleDimension=false] Indicates that the role 
 * can only be satisfied by a single dimension. 
 * 
 * @param {boolean} [keyArgs.isMeasure=false] Indicates that <b>datums</b> that do not 
 * contain a non-null atom in any of the dimensions bound to measure roles should be readily excluded.
 * 
 * @param {boolean} [keyArgs.valueType] Restricts the allowed value type of dimensions.
 * 
 * @param {boolean|null} [keyArgs.requireIsDiscrete=null] Indicates if the grouping should be discrete, continuous or any.
 * 
 * @param {string} [keyArgs.defaultDimensionName] The default dimension name.
 * @param {boolean} [keyArgs.autoCreateDimension=false]
 * Indicates if a dimension with the default name (the first level of, when a group name),
 * should be created when the role is required and it has not been read by a translator.
 *
 * @param {string} [keyArgs.flatteningMode='singleLevel'] Indicates if the role presents
 * the leaf data nodes or all the nodes in the tree, in pre or post order.
 * Possible values are <tt>'singleLevel'</tt>, <tt>'tree-pre'</tt> and <tt>'tree-post'</tt>.
 */
def.type('pvc.visual.Role')
.init(function(name, keyArgs){
    this.name  = name;
    this.label = def.get(keyArgs, 'label') || pvc.buildTitleFromName(name);
    this.index = def.get(keyArgs, 'index') || 0;
    
    this.dimensionDefaults = def.get(keyArgs, 'dimensionDefaults') || {};
    
    if(def.get(keyArgs, 'isRequired', false)) {
        this.isRequired = true;
    }
    
    if(def.get(keyArgs, 'autoCreateDimension', false)) {
        this.autoCreateDimension = true;
    }
    
    var defaultSourceRoleName = def.get(keyArgs, 'defaultSourceRole');
    if(defaultSourceRoleName) {
        this.defaultSourceRoleName = defaultSourceRoleName;
    }
    
    var defaultDimensionName = def.get(keyArgs, 'defaultDimension');
    if(defaultDimensionName) {
        this.defaultDimensionName = defaultDimensionName;
    }

    if(!defaultDimensionName && this.autoCreateDimension){
        throw def.error.argumentRequired('defaultDimension');
    }
    
    var requireSingleDimension;
    var requireIsDiscrete = def.get(keyArgs, 'requireIsDiscrete'); // isSingleDiscrete
    if(requireIsDiscrete != null) {
        if(!requireIsDiscrete) {
            requireSingleDimension = true;
        }
    }
    
    if(requireSingleDimension != null) {
        requireSingleDimension = def.get(keyArgs, 'requireSingleDimension', false);
        if(requireSingleDimension) {
            if(def.get(keyArgs, 'isMeasure', false)) {
                this.isMeasure = true;
                
                if(def.get(keyArgs, 'isPercent', false)) {
                    this.isPercent = true;
                }
            }
            
            var valueType = def.get(keyArgs, 'valueType', null);
            if(valueType !== this.valueType) {
                this.valueType = valueType;
                this.dimensionDefaults.valueType = valueType;
            }
        }
    }
    
    if(requireSingleDimension !== this.requireSingleDimension) {
        this.requireSingleDimension = requireSingleDimension;
    }
    
    if(requireIsDiscrete != this.requireIsDiscrete) {
        this.requireIsDiscrete = !!requireIsDiscrete;
        this.dimensionDefaults.isDiscrete = this.requireIsDiscrete;
    }

    var flatteningMode = def.get(keyArgs, 'flatteningMode');
    if(flatteningMode && flatteningMode != this.flatteningMode) {
        this.flatteningMode = flatteningMode;
    }
})
.add(/** @lends pvc.visual.Role# */{
    isRequired: false,
    requireSingleDimension: false,
    valueType: null,
    requireIsDiscrete: null,
    isMeasure: false,
    isPercent: false,
    defaultSourceRoleName: null,
    defaultDimensionName:  null,
    grouping: null,
    flatteningMode: 'singleLevel',
    flattenRootLabel: '',
    autoCreateDimension: false,
    isReversed: false,
    label: null,
    sourceRole: null,
    
    /** 
     * Obtains the first dimension type that is bound to the role.
     * @type pvc.data.DimensionType
     */
    firstDimensionType: function(){
        var g = this.grouping;
        return g && g.firstDimensionType();
    },
    
    /** 
     * Obtains the name of the first dimension type that is bound to the role.
     * @type string 
     */
    firstDimensionName: function(){
        var g = this.grouping;
        return g && g.firstDimensionName();
    },
    
    /** 
     * Obtains the value type of the first dimension type that is bound to the role.
     * @type function
     */
    firstDimensionValueType: function(){
        var g = this.grouping;
        return g && g.firstDimensionValueType();
    },

    isDiscrete: function(){
        var g = this.grouping;
        return g && g.isDiscrete();
    },
    
    setSourceRole: function(sourceRole){
        this.sourceRole = sourceRole;
    },
    
    setIsReversed: function(isReversed){
        if(!isReversed){ // default value
            delete this.isReversed;
        } else {
            this.isReversed = true;
        }
    },
    
    setFlatteningMode: function(flatteningMode){
        if(!flatteningMode || flatteningMode === 'singleLevel'){ // default value
            delete this.flatteningMode;
        } else {
            this.flatteningMode = flatteningMode;
        }
    },

    setFlattenRootLabel: function(flattenRootLabel){
        if(!flattenRootLabel){ // default value
            delete this.flattenRootLabel;
        } else {
            this.flattenRootLabel = flattenRootLabel;
        }
    },

    /**
     * Applies this role's grouping to the specified data
     * after ensuring the grouping is of a certain type.
     *
     * @param {pvc.data.Data} data The data on which to apply the operation.
     * @param {object} [keyArgs] Keyword arguments.
     * ...
     * 
     * @type pvc.data.Data
     */
    flatten: function(data, keyArgs){
        if(this.grouping){
            return data.flattenBy(this, keyArgs);
        }
    },

    flattenedGrouping: function(keyArgs){
        var grouping = this.grouping;
        if(grouping){
            keyArgs = def.setDefaults(keyArgs,
                'flatteningMode', this.flatteningMode,
                'flattenRootLabel', this.flattenRootLabel);

            return grouping.ensure(keyArgs);
        }
    },

    select: function(data, keyArgs){
        var grouping = this.grouping;
        if(grouping){
            return data.groupBy(grouping.ensure(keyArgs), keyArgs);
        }
    },

    view: function(complex){
        var grouping = this.grouping;
        if(grouping){
            return grouping.view(complex);
        }
    },

    /**
     * Pre-binds a grouping specification to playing this role.
     * 
     * @param {pvc.data.GroupingSpec} groupingSpec The grouping specification of the visual role.
     */
    preBind: function(groupingSpec){
        this.__grouping = groupingSpec;

        return this;
    },

    isPreBound: function(){
        return !!this.__grouping;
    },
    
    preBoundGrouping: function(){
        return this.__grouping;
    },
    
    isBound: function(){
        return !!this.grouping;
    },
    
    /**
     * Finalizes a binding initiated with {@link #preBind}.
     *
     * @param {pvc.data.ComplexType} type The complex type with which
     * to bind the pre-bound grouping and then validate the
     * grouping and role binding.
     */
    postBind: function(type){
        var grouping = this.__grouping;
        if(grouping){
            delete this.__grouping;

            grouping.bind(type);

            this.bind(grouping);
        }
        
        return this;
    },

    /**
     * Binds a grouping specification to playing this role.
     * 
     * @param {pvc.data.GroupingSpec} groupingSpec The grouping specification of the visual role.
     */
    bind: function(groupingSpec){
        if(groupingSpec) {
            if(groupingSpec.isNull()){
                groupingSpec = null;
           } else {
                /* Validate grouping spec according to role */

                if(this.requireSingleDimension && !groupingSpec.isSingleDimension) {
                    throw def.error.operationInvalid(
                            "Role '{0}' only accepts a single dimension.",
                            [this.name]);
                }

                var valueType = this.valueType;
                var requireIsDiscrete = this.requireIsDiscrete;
                groupingSpec.dimensions().each(function(dimSpec){
                    var dimType = dimSpec.type;
                    if(valueType && dimType.valueType !== valueType) {
                        throw def.error.operationInvalid(
                                "Role '{0}' cannot be bound to dimension '{1}'. \nIt only accepts dimensions of type '{2}' and not of type '{3}'.",
                                [this.name, dimType.name, pvc.data.DimensionType.valueTypeName(valueType), dimType.valueTypeName]);
                    }

                    if(requireIsDiscrete != null &&
                       dimType.isDiscrete !== requireIsDiscrete) {
                        
                        if(requireIsDiscrete){
                            // A continuous dimension can be "coerced" to behave as discrete
                            dimType._toDiscrete();
                        } else {
                            throw def.error.operationInvalid(
                                "Role '{0}' cannot be bound to dimension '{1}'. \nIt only accepts {2} dimensions.",
                                [this.name, dimType.name, requireIsDiscrete ? 'discrete' : 'continuous']);
                        }
                    }
                }, this);
            }
        }
        
        // ----------
        
        if(this.grouping) {
            // unregister from current dimension types
            this.grouping.dimensions().each(function(dimSpec){
                if(dimSpec.type){
                    /*global dimType_removeVisualRole:true */
                    dimType_removeVisualRole.call(dimSpec.type, this);
                }
            }, this);
        }
        
        this.grouping = groupingSpec;
        
        if(this.grouping) {
            
            if(this.isReversed){
                this.grouping = this.grouping.reversed();
            }
            
            // register in current dimension types
            this.grouping.dimensions().each(function(dimSpec){
                /*global dimType_addVisualRole:true */
                dimType_addVisualRole.call(dimSpec.type, this);  
            }, this);
        }

        return this;
    }
});

/**
 * Initializes a scene.
 * 
 * @name pvc.visual.Scene
 * @class Scenes guide the rendering of protovis marks;
 * they are supplied to {@link pv.Mark} <tt>data</tt> property.
 * <p>
 * A scene may feed several marks and so is not specific to a given mark 
 * (contrast with protovis' instances/scenes).
 * </p>
 * <p>
 * Scenes provide a well defined interface to pvc's 
 * extension point functions.
 * </p>
 * <p>
 * Scenes hold precomputed data, that does not change with interaction,
 * and that is thus not recalculated in every protovis render caused by interaction.
 * </p>
 * <p>
 * Scenes bridge the gap between data and visual roles. 
 * Data can be accessed by one or the other view.
 * </p>
 * 
 * @borrows pv.Dom.Node#visitBefore as #visitBefore
 * @borrows pv.Dom.Node#visitAfter as #visitAfter
 * 
 * @borrows pv.Dom.Node#nodes as #nodes
 * @borrows pv.Dom.Node#firstChild as #firstChild
 * @borrows pv.Dom.Node#lastChild as #lastChild
 * @borrows pv.Dom.Node#previousSibling as #previousSibling
 * @borrows pv.Dom.Node#nextSibling as #nextSibling
 * 
 * 
 * @property {pvc.data.Data}  group The data group that's present in the scene, or <tt>null</tt>, if none.
 * @property {pvc.data.Datum} datum The datum that's present in the scene, or <tt>null</tt>, if none.
 * @property {object} atoms The map of atoms, by dimension name, that's present in the scene, or <tt>null</tt>, if none.
 * <p>
 * When there is a group, these are its atoms, 
 * otherwise, 
 * if there is a datum, 
 * these are its atoms.
 * </p>
 * <p>
 * Do <b>NOT</b> modify this object.
 * </p>
 * 
 * @constructor
 * @param {pvc.visual.Scene} [parent=null] The parent scene.
 * @param {object} [keyArgs] Keyword arguments.
 * @property {pvc.data.Data}  [keyArgs.group=null] The data group that's present in the scene.
 * Specify only one of the arguments <tt>group</tt> or <tt>datum</tt>.
 * @property {pvc.data.Datum} [keyArgs.datum=null] The single datum that's present in the scene.
 * Specify only one of the arguments <tt>group</tt> or <tt>datum</tt>.
 */
def.type('pvc.visual.Scene')
.init(function(parent, keyArgs){
    if(pvc.debug >= 4){
        this.id = def.nextId('scene');
    }
    
    this._renderId   = 0;
    this.renderState = {};
    
    pv.Dom.Node.call(this, /* nodeValue */null);
    
    this.parent = parent || null;
    this.root   = this;
    if(parent){
        // parent -> ((pv.Dom.Node#)this).parentNode
        // this   -> ((pv.Dom.Node#)parent).childNodes
        // ...
        var index = def.get(keyArgs, 'index', null);
        parent.insertAt(this, index);
        this.root = parent.root;
    } else {
        /* root scene */
        this._active = null;
        this._panel = def.get(keyArgs, 'panel') || 
            def.fail.argumentRequired('panel', "Argument is required on root scene.");
    }
    
    /* DATA */
    var group = def.get(keyArgs, 'group', null),
        datum;
    if(group){
        datum = group._datums[0]; // null on empty datas (just try hiding all series with the legend)
    } else {
        datum = def.get(keyArgs, 'datum');
    }
    
    this.datum = datum || null;
    this.group = group;

    var source = (datum || group);
    this.atoms = source ? source.atoms : null;
    
    /* VARS */
    this.vars = parent ? Object.create(parent.vars) : {};
})
.add(pv.Dom.Node)

.add(/** @lends pvc.visual.Scene# */{
    /**
     * Obtains an enumerable of the datums present in the scene.
     *
     * @type def.Query
     */
    datums: function(){
        return this.group ?
                    this.group.datums() :
                    (this.datum ? def.query(this.datum) : def.query());
    },
    
    /*
     * {value} -> <=> this.vars.value.label
     * {value.value} -> <=> this.vars.value.value
     * {#sales} -> <=> this.atoms.sales.label
     */
    format: function(mask){
        return def.format(mask, this._formatScope, this);
    },
    
    _formatScope: function(prop){
        if(prop.charAt(0) === '#'){
            // An atom name
            prop = prop.substr(1).split('.');
            if(prop.length > 2){
                throw def.error.operationInvalid("Scene format mask is invalid.");
            }
            
            var atom = this.atoms[prop[0]];
            if(atom){
                if(prop.length > 1) {
                    switch(prop[1]){
                        case 'value': return atom.value;
                        case 'label': break;
                        default:      throw def.error.operationInvalid("Scene format mask is invalid.");
                    }
                }
                
                // atom.toString() ends up returning atom.label
                return atom;
            }
            
            return null; // Atom does not exist --> ""
        }
        
        // A scene var name
        return def.getPath(this.vars, prop); // Scene vars' toString may end up being called
    },
    
    isRoot: function(){
        return this.root === this;   
    },
    
    panel: function(){
        return this.root._panel;
    },
    
    chart: function(){
        return this.root._panel.chart;
    },
    
    compatVersion: function(){
        return this.root._panel.compatVersion();
    },
    
    /**
     * Obtains an enumerable of the child scenes.
     * 
     * @type def.Query
     */
    children: function(){
        if(!this.childNodes) {
            return def.query();
        }
        
        return def.query(this.childNodes);
    },
    
    leafs: function(){
        function getFirstLeafFrom(leaf){
            // Find first leaf from current
            while(leaf.childNodes.length){
                leaf = leaf.childNodes[0];
            }
            
            return leaf;
        }
        
        var root = this;
        return def.query(function(nextIndex){
            if(!nextIndex){
                // Initialize
                var item = getFirstLeafFrom(root);
                if(item === root){
                    return 0;
                }
                
                this.item = item;
                return 1; // has next
            }
            
            // Has a next sibling?
            var next = this.item.nextSibling;
            if(next){
                this.item = next;
                return 1; // has next
            }
            
            // Go to closest ancestor that has a sibling
            var current = this.item;
            while((current !== root) && (current = current.parentNode)){
                if((next = current.nextSibling)){
                    // Take the first leaf from there
                    this.item = getFirstLeafFrom(next);
                    return 1;
                }
            }
            
            return 0;
        });
    },
    
    /* INTERACTION */
    anyInteraction: function(){
        return (!!this.root._active || this.anySelected());
    },

    /* ACTIVITY */
    isActive: false,
    
    setActive: function(isActive){
        isActive = !!isActive; // normalize
        if(this.isActive !== isActive){
            rootScene_setActive.call(this.root, this.isActive ? null : this);
        }
    },
    
    clearActive: function(){
        return rootScene_setActive.call(this.root, null);
    },
    
    anyActive: function(){
        return !!this.root._active;
    },
    
    active: function(){
        return this.root._active;
    },
    
    activeSeries: function(){
        var active = this.active();
        var seriesVar;
        return active && (seriesVar = active.vars.series) && seriesVar.value;
    },
    
    isActiveSeries: function(){
        if(this.isActive){
            return true;
        }
        
        var activeSeries;
        return (activeSeries = this.activeSeries()) != null &&
               (activeSeries === this.vars.series.value);
    },
    
    /* SELECTION */
    isSelected: function(){
        return this._selectedData().is;
    },
    
    anySelected: function(){
        return this._selectedData().any;
    },
    
    _selectedData: function(){
        return this.renderState._selectedData || 
               (this.renderState._selectedData = this._createSelectedData());
    },
    
    _createSelectedData: function(){
        var any = this.panel().chart.data.owner.selectedCount() > 0,
            isSelected = any && 
                         this.datums()
                             .any(function(datum){ return datum.isSelected; });
        
        return {
            any: any,
            is:  isSelected
        };
    }
});

/** 
 * Called on each sign's pvc.visual.Sign#buildInstance 
 * to ensure cached data per-render is cleared.
 * 
 *  @param {number} renderId The current render id.
 */
function scene_renderId(renderId){
    if(this._renderId !== renderId){
        if(pvc.debug >= 20){
            pvc.log({sceneId: this.id, oldRenderId: this._renderId, newRenderId: renderId});
        }
        
        this._renderId   = renderId;
        this.renderState = {};
    }
}

function rootScene_setActive(scene){
    var ownerScene;
    if(scene && (ownerScene = scene.ownerScene)){
        scene = ownerScene;
    }
    
    if(this._active !== scene){
        if(this._active){
            scene_setActive.call(this._active, false);
        }
        
        this._active = scene || null;
        
        if(this._active){
            scene_setActive.call(this._active, true);
        }
        return true;
    }
    return false;
}

function scene_setActive(isActive){
    isActive = !!isActive; // normalize
    if(this.isActive !== isActive){
        if(!isActive){
            delete this.isActive;
        } else {
            this.isActive = true;
        }
    }
}
/**
 * Initializes a scene variable.
 * 
 * @name pvc.visual.ValueLabelVar
 * @class A scene variable holds the concrete value that 
 * a {@link pvc.visual.Role} or other relevant piece of information 
 * has in a {@link pvc.visual.Scene}.
 * Usually, it also contains a label that describes it.
 * 
 * @constructor
 * @param {any} value The value of the variable.
 * @param {any} label The label of the variable.
 * @param {any} [rawValue] The raw value of the variable.
 */
pvc.visual.ValueLabelVar = function(value, label, rawValue){
    this.value = value;
    this.label = label;
    
    if(rawValue !== undefined){
        this.rawValue = rawValue;
    }
};

def.set(
    pvc.visual.ValueLabelVar.prototype, 
    'rawValue', undefined,
    'clone',    function(){
        return new pvc.visual.ValueLabelVar(this.value, this.label, this.rawValue);
    },
    'toString', function(){
        var label = this.label || this.value;
        return typeof label !== 'string' ? ('' + label) : label;
    });


def
.type('pvc.visual.ColorVarHelper')
.init(function(chart, colorRole){
    this.colorGrouping = colorRole.grouping;
    
    var colorFirstDimName = this.colorGrouping.firstDimensionName();
    
    this.rootColorDim = chart.data.owner.dimensions(colorFirstDimName);
    
    this.isDiscrete = this.colorGrouping.isDiscrete();
    
    this.colorSourceRoleName = colorRole.sourceRole && colorRole.sourceRole.name;
})
.add({
    onNewScene: function(scene, isLeaf){
        if(scene.vars.color){
            return;
        }
        
        var sourceName = this.colorSourceRoleName;
        if(sourceName){
            var colorSourceVar = def.getOwn(scene.vars, sourceName);
            if(colorSourceVar){
                scene.vars.color = colorSourceVar.clone();
                return;
            }
        }
        
        if(isLeaf){
            var group = scene.group;
            if(this.isDiscrete){
                // Not grouped, so there's no guarantee that
                // there's a single color value for all the datums of the group.
                // We choose the color of the first datum of the group...
                var firstDatum = (group ? group.firstDatum() : scene.datum);
                if(firstDatum && !firstDatum.isNull){
                    var view = this.colorGrouping.view(firstDatum);
                    scene.vars.color = new pvc.visual.ValueLabelVar(
                        view.value,
                        view.label,
                        view.rawValue);
                } else {
                    scene.vars.color = new pvc.visual.ValueLabelVar(null, "");
                }
            } else {
                var singleDatum = group ? group.singleDatum() : scene.datum;
                if(singleDatum){
                    scene.vars.color = Object.create(singleDatum.atoms[this.rootColorDim.name]);
                } else {
                    var value = group ? 
                         group
                         .dimensions(this.rootColorDim.name)
                         .sum({visible: true, zeroIfNone: false}) :
                        null;
                    
                    var label = this.rootColorDim.format(value);
                    
                    scene.vars.color = new pvc.visual.ValueLabelVar(value, label, value);
                }
            }
        }
    }
});

(function(){

    pv.Mark.prototype.getSign = function(){
        return this.sign || createBasic(this);
    };
    
    pv.Mark.prototype.getScene = function(){
        return this.getSign().scene;
    };
    
    function createBasic(pvMark){
        var as = getAncestorSign(pvMark) || 
                 def.assert("There must exist an ancestor sign");
        var bs = new pvc.visual.BasicSign(as.panel, pvMark);
        var i;
        var s = pvMark.scene;
        if(s && (i = pvMark.index) != null && i >= 0){
            // Mark is already rendering; build the current instance
            bs._buildInstance(pvMark, s[i], /*lateCall*/ true);
        }
        return bs;
    }
    
    // Obtains the first sign accessible from the argument mark.
    function getAncestorSign(pvMark){
        var sign;
        do{
            pvMark = pvMark.parent;
        } while(pvMark && !(sign = pvMark.sign) && (!pvMark.proto || !(sign = pvMark.proto.sign)));
        
        return sign;
    }
    
    // Used to wrap a mark, dynamically, 
    // with minimal impact and functionality.
    def.type('pvc.visual.BasicSign')
    .init(function(panel, pvMark){
        this.chart  = panel.chart;
        this.panel  = panel;
        this.pvMark = pvMark;
        
        /* Extend the pv mark */
        pvMark
            .localProperty('_scene', Object)
            .localProperty('group',  Object);
        
        this.lockMark('_scene', function(scene){ return scene; })
            /* TODO: remove these when possible and favor access through scene */
            .lockMark('group', function(scene){ return scene && scene.group; })
            .lockMark('datum', function(scene){ return scene && scene.datum; })
            ;
        
        pvMark.sign = this;
        
        /* Intercept the protovis mark's buildInstance */
        
        // Avoid doing a function bind, cause buildInstance is a very hot path
        pvMark.__buildInstance = pvMark.buildInstance;
        pvMark.buildInstance   = this._dispatchBuildInstance;
    })
    .add({
        // Defines a local property on the underlying protovis mark
        localProperty: function(name, type){
            this.pvMark.localProperty(name, type);
            return this;
        },
        
        lock: function(name, value){
            return this.lockMark(name, this._bindWhenFun(value));
        },
        
        optional: function(name, value, tag){
            return this.optionalMark(name, this._bindWhenFun(value), tag);
        },
        
        // -------------
        
        lockMark: function(name, value){
            this.pvMark.lock(name, value);
            return this;
        },
        
        optionalMark: function(name, value, tag){
            this.pvMark[name](value, tag);
            return this;
        },
        
        // --------------
        
        delegate: function(dv, tag){
            return this.pvMark.delegate(dv, tag);
        },
        
        delegateExtension: function(dv){
            return this.pvMark.delegate(dv, pvc.extensionTag);
        },
        
        hasDelegate: function(tag){
            return this.pvMark.hasDelegate(tag);
        },
        
        // Using it is a smell...
    //    hasExtension: function(){
    //        return this.pvMark.hasDelegate(pvc.extensionTag);
    //    },
        
        // -------------
        
        _bindWhenFun: function(value){
            if(typeof value === 'function'){
                /* return value.bind(this); */
                return function(){
                    var sign = this.getSign();
                    return value.apply(sign, arguments);
                };
            }
            
            return value;
        },
        
        _lockDynamic: function(name, method){
            /* def.methodCaller('' + method, this) */
            var me = this;
            return this.lockMark(
                        name,
                        function(){
                            var sign = this.getSign();
                            var m = sign[method] ||
                                    me  [method] ||
                                    def.assert("No method with name '" + method + "' is defined");
                            
                            return m.apply(sign, arguments);
                        });
        },
        
        // --------------
        
        /* SCENE MAINTENANCE */
        _dispatchBuildInstance: function(instance){
            // this: the mark
            this.sign._buildInstance(this, instance);
        },
        
        _buildInstance: function(mark, instance, lateCall){
            /* Reset scene/instance state */
            this.pvInstance = instance; // pv Scene
            
            var scene  = instance.data;
            this.scene = scene;
            
            var index = scene ? scene.childIndex() : 0;
            this.index = index < 0 ? 0 : index;
            
            /* 
             * Update the scene's render id, 
             * which possibly invalidates per-render
             * cached data.
             */
            /*global scene_renderId:true */
            scene_renderId.call(scene, mark.renderId());
    
            /* state per: sign & scene & render */
            this.state = {};
            
            if(!lateCall){
                mark.__buildInstance.call(mark, instance);
            }
        }
    });
}());
def.type('pvc.visual.Sign', pvc.visual.BasicSign)
.init(function(panel, pvMark, keyArgs){
    
    this.base(panel, pvMark, keyArgs);
    
    this.bits = 0;
    
    var extensionIds = def.get(keyArgs, 'extensionId');
    if(extensionIds != null){ // empty string is a valid extension id.
        this.extensionAbsIds = def.array.to(panel._makeExtensionAbsId(extensionIds));
    }
    
    this.isActiveSeriesAware = def.get(keyArgs, 'activeSeriesAware', true) && 
                               !!this.chart.visualRoles('series', {assertExists: false});
    
    /* Extend the pv mark */
    var wrapper = def.get(keyArgs, 'wrapper');
    if(!wrapper){
        wrapper = function(f){
            return function(scene){
                return f.call(panel._getContext(pvMark), scene);
            };
        };
    }
    pvMark.wrapper(wrapper);
    
    if(!def.get(keyArgs, 'freeColor', true)){
        this._bindProperty('fillStyle',   'fillColor',   'color')
            ._bindProperty('strokeStyle', 'strokeColor', 'color')
            ;
    }
})
.postInit(function(panel, pvMark, keyArgs){
    
    panel._addSign(this);
    
    this._addInteractive(keyArgs);
})
.add({
    // To be called on prototype
    property: function(name){
        var upperName  = def.firstUpperCase(name);
        var baseName   = 'base'        + upperName;
        var defName    = 'default'     + upperName;
        var normalName = 'normal'      + upperName;
        var interName  = 'interactive' + upperName;
        
        var methods = {};
        
        // color
        methods[name] = function(arg){
            delete this._finished;
            
            var value;
            this._arg = arg; // for use in calling default methods (see #_bindProperty)
            try{
                value = this[baseName](arg);
                if(value == null){ // undefined included
                    return null;
                }
                
                if(this.hasOwnProperty('_finished')){
                    return value;
                }
                
                if(this.showsInteraction() && this.scene.anyInteraction()) {
                    // interactiveColor
                    value = this[interName](value, arg);
                } else {
                    // normalColor
                    value = this[normalName](value, arg);
                }
            } finally{
                delete this._arg;
            }
            
            return value;
        };
        
        // baseColor
        methods[baseName] = function(arg){
            // Override this method if user extension
            // should not always be called.
            // It is possible to call the default method directly, if needed.
            
            // defName is installed as a user extension and 
            // is called if the user hasn't extended...
            return this.delegateExtension();
        };
        
        // defaultColor
        methods[defName] = function(arg){ return; };
        
        // normalColor
        methods[normalName] = function(value, arg){ return value; };
        
        // interactiveColor
        methods[interName]  = function(value, arg){ return value; };
        
        this.constructor.add(methods);
        
        return this;
    },
    
    // Call this function with a final property value
    // to ensure that it will not be processed anymore
    finished: function(value){
        this._finished = true;
        return value;
    },
    
    /* Extensibility */
    /**
     * Any protovis properties that have been specified 
     * before the call to this method
     * are either locked or are defaults.
     * 
     * This method applies user extensions to the protovis mark.
     * Default properties are replaced.
     * Locked properties are respected.
     * 
     * Any function properties that are specified 
     * after the call to this method
     * will have access to the user extension by 
     * calling {@link pv.Mark#delegate}.
     */
    applyExtensions: function(){
        if(!this._extended){
            this._extended = true;
            
            var extensionAbsIds = this.extensionAbsIds;
            if(extensionAbsIds){
                extensionAbsIds.forEach(function(extensionAbsId){
                    this.panel.extendAbs(this.pvMark, extensionAbsId);
                }, this);
            }
        }
        
        return this;
    },
    
    // -------------
    
    intercept: function(name, fun){
        return this._intercept(name, fun.bind(this));
    },
    
    // -------------
    
    lockDimensions: function(){
        this.pvMark
            .lock('left')
            .lock('right')
            .lock('top')
            .lock('bottom')
            .lock('width')
            .lock('height');
        
        return this;
    },
    
    // -------------
    _extensionKeyArgs: {tag: pvc.extensionTag},
    
    _bindProperty: function(pvName, prop, realProp){
        var me = this;
        
        if(!realProp){
            realProp = prop;
        }
        
        var defaultPropName = "default" + def.firstUpperCase(realProp);
        if(def.fun.is(this[defaultPropName])){
            // Intercept with default method first, before extensions,
            // so that extensions, when ?existent?, can delegate to the default.
            
            // Extensions will be applied next.
            
            // If there already exists an applied extension then
            // do not install the default (used by legend proto defaults,
            // that should act like user extensions, and not be shadowed by prop defaults).
            
            // Mark default as pvc.extensionTag, 
            // so that it is chosen when 
            // the user hasn't specified an extension point.

            if(!this.pvMark.hasDelegateValue(pvName, pvc.extensionTag)){
                var defaultMethodCaller = function(){
                    return me[defaultPropName](me._arg);
                };
                
                this.pvMark.intercept(
                        pvName, 
                        defaultMethodCaller, 
                        this._extensionKeyArgs);
            }
        }
        
        // Intercept with main property method
        // Do not pass arguments, cause property methods do not use them,
        // they use this.scene instead.
        // The "arg" argument can only be specified explicitly,
        // like in strokeColor -> color and fillColor -> color,
        // via "helper property methods" that ?fix? the argument.
        // In these cases, 'strokeColor' is the "prop", while
        // "color" is the "realProp".
        function mainMethodCaller(){
            return me[prop]();
        }
        
        return this._intercept(pvName, mainMethodCaller);
    },
    
    _intercept: function(name, fun){
        var mark = this.pvMark;
        
        // Apply all extensions, in order
        
        var extensionAbsIds = this.extensionAbsIds;
        if(extensionAbsIds){
            def
            .query(extensionAbsIds)
            .select(function(extensionAbsId){ 
                return this.panel._getExtensionAbs(extensionAbsId, name);
             }, this)
            .where(def.notUndef)
            .each(function(extValue){
                extValue = mark.wrap(extValue, name);
                
                // Gets set on the mark; We intercept it afterwards.
                // Mark with the pvc.extensionTag so that it is 
                // possible to filter extensions.
                mark.intercept(name, extValue, this._extensionKeyArgs);
            }, this);
        }
        
        // Intercept with specified function (may not be a property function)
        
        (mark._intercepted || (mark._intercepted = {}))[name] = true;
        
        mark.intercept(name, fun);
        
        return this;
    }
})
.prototype
.property('color')
.constructor
.add({
    _bitShowsInteraction:  4,
    _bitShowsTooltip:      8,
    _bitSelectable:       16,
    _bitHoverable:        32,
    _bitClickable:        64,
    _bitDoubleClickable: 128,
    
    showsInteraction:  function(){ return (this.bits & this._bitShowsInteraction) !== 0; },
    showsTooltip:      function(){ return (this.bits & this._bitShowsTooltip    ) !== 0; },
    isSelectable:      function(){ return (this.bits & this._bitSelectable      ) !== 0; },
    isHoverable:       function(){ return (this.bits & this._bitHoverable       ) !== 0; },
    isClickable:       function(){ return (this.bits & this._bitClickable       ) !== 0; },
    isDoubleClickable: function(){ return (this.bits & this._bitDoubleClickable ) !== 0; },
    
    extensionAbsIds: null,
    
    _addInteractive: function(keyArgs){
        var panel   = this.panel,
            pvMark  = this.pvMark,
            options = this.chart.options;
        
        var bits = this.bits;
        
        if(this.chart._tooltipEnabled && !def.get(keyArgs, 'noTooltip')){
            bits |= this._bitShowsTooltip;
            
            this.panel._addPropTooltip(pvMark, def.get(keyArgs, 'tooltipArgs'));
        }
        
        var selectable = false;
        var clickable  = false;
        
        if(options.selectable || options.hoverable){
            if(options.selectable && !def.get(keyArgs, 'noSelect')){
                bits |= (this._bitShowsInteraction | this._bitSelectable);
                selectable = true;
            }
            
            if(options.hoverable && !def.get(keyArgs, 'noHover')){
                bits |= (this._bitShowsInteraction | this._bitHoverable);
                
                panel._addPropHoverable(pvMark);
            }
        }
        
        // By default interaction is SHOWN if the sign
        // is sensitive to interactive events.
        
        // This must be after the previous options, that affect bits with _bitShowsInteraction
        var showsInteraction = def.get(keyArgs, 'showsInteraction');
        if(showsInteraction != null){
            if(showsInteraction){
                bits |=  this._bitShowsInteraction;
            } else {
                bits &= ~this._bitShowsInteraction;
            }
        }
        
        if(!def.get(keyArgs, 'noClick') && panel._isClickable()){
            bits |= this._bitClickable;
            clickable = true;
        }
        
        if(selectable || clickable){
            panel._addPropClick(pvMark);
        }
        
        if(!def.get(keyArgs, 'noDoubleClick') && panel._isDoubleClickable()){
            bits |= this._bitDoubleClickable;
            
            panel._addPropDoubleClick(pvMark);
        }
        
        this.bits = bits;
    },
    
    /* COLOR */
    fillColor: function(){ 
        return this.color('fill');
    },
    
    strokeColor: function(){ 
        return this.color('stroke');
    },

    defaultColor: function(type){
        return this.defaultColorSceneScale()(this.scene);
    },

    dimColor: function(color, type){
        return pvc.toGrayScale(color, -0.3, null, null); // ANALYZER requirements, so until there's no way to configure it...
    },
    
    _initDefaultColorSceneScale: function(){
        var colorAxis = this.panel.axes.color;
        return colorAxis ? 
               colorAxis.sceneScale({nullToZero: false}) :
               def.fun.constant(pvc.defaultColor)
               ;
    },
    
    defaultColorSceneScale: function(){
        return this._defaultColorSceneScale || 
               (this._defaultColorSceneScale = this._initDefaultColorSceneScale());
    }
});

def.type('pvc.visual.Panel', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){
    var pvPanel = def.get(keyArgs, 'panel');
    if(!pvPanel){
        var pvPanelType = def.get(keyArgs, 'panelType') || pv.Panel;
        
        pvPanel = protoMark.add(pvPanelType);
    }
    
    this.base(panel, pvPanel, keyArgs);
})
.add({
    _addInteractive: function(keyArgs){
        var t = true;
        keyArgs = def.setDefaults(keyArgs,
                        'noSelect',      t,
                        'noHover',       t,
                        'noTooltip',     t,
                        'noClick',       t,
                        'noDoubleClick', t);

        this.base(keyArgs);
    }
});
def.type('pvc.visual.Label', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){

    var pvMark = protoMark.add(pv.Label);

    this.base(panel, pvMark, keyArgs);
})
.add({
    _addInteractive: function(keyArgs){
        keyArgs = def.setDefaults(keyArgs,
                        'noSelect',      true,
                        'noHover',       true,
                        'noTooltip',    true,
                        'noClick',       true,
                        'noDoubleClick', true);

        this.base(keyArgs);
    },
    
    defaultColor: function(type){
        return pv.Color.names.black;
    }
});
def.type('pvc.visual.Dot', pvc.visual.Sign)
.init(function(panel, parentMark, keyArgs){
    
    var pvMark = parentMark.add(pv.Dot);
    
    var protoMark = def.get(keyArgs, 'proto');
    if(protoMark){
        pvMark.extend(protoMark);
    }
    
    keyArgs = def.setDefaults(keyArgs, 'freeColor', false);
    
    this.base(panel, pvMark, keyArgs);
    
    if(!def.get(keyArgs, 'freePosition', false)){
        var basePosProp  = panel.isOrientationVertical() ? "left" : "bottom",
            orthoPosProp = panel.anchorOrtho(basePosProp);
        
        this/* Positions */
            ._lockDynamic(orthoPosProp, 'y')
            ._lockDynamic(basePosProp,  'x');
    }
       
    this/* Shape & Size */
        ._bindProperty('shape',       'shape' )
        ._bindProperty('shapeRadius', 'radius')
        ._bindProperty('shapeSize',   'size'  )
        
        /* Colors & Line */
        .optional('strokeDasharray', undefined) // Break inheritance
        .optional('lineWidth',       1.5)       // Idem
        ;
})
.prototype
.property('size')
.constructor
.add({
    /* Sign Spatial Coordinate System
     *  -> Cartesian coordinates
     *  -> Grows Up, vertically, and Right, horizontally
     *  -> Independent of the chart's orientation
     *  -> X - horizontal axis
     *  -> Y - vertical axis
     *  
     *  y
     *  ^
     *  |
     *  |
     *  o-----> x
     */
    y: function(){ return 0; },
    x: function(){ return 0; },
    
    shape: function(){ 
        return this.delegateExtension(); 
    },
    
    radius: function(){
        // Store extended value, if any
        // See #sizeCore
        this.state.radius = this.delegateExtension();
    },
    
    /* SIZE */
    baseSize: function(){
        /* Radius was specified? */
        var radius = this.state.radius;
        if(radius != null) {
            return radius * radius;
        }
      
        return this.base();
    },

    defaultSize: function(){
        return 12;
    },
    
    interactiveSize: function(size){
        if(this.scene.isActive){
            return Math.max(size, 5) * 2.5;
        }
        
        return size;
    },
    
    /* COLOR */
    
    /**
     * @override
     */
    interactiveColor: function(color, type){
        var scene = this.scene;
        if(scene.isActive) {
            if(type === 'stroke') {
                return color.brighter(1);
            }
        } else if(scene.anySelected() && !scene.isSelected()) {
            
            if(this.isActiveSeriesAware && scene.isActiveSeries()) {
                //return color.darker(1.5);
                return color.alpha(0.8);
//                switch(type){
//                  case 'fill':   return pv.Color.names.darkgray.darker().darker();
//                  case 'stroke': return color;
//                }
            } else {
                switch(type) {
                    case 'fill':   return this.dimColor(color, type);
                    case 'stroke': return color.alpha(0.45);
                }
            }
        }

        return this.base(color, type);
    }
});

def.type('pvc.visual.Line', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){
    
    var pvMark = protoMark.add(pv.Line);
    
    this.base(panel, pvMark, keyArgs);
    
    this.lock('segmented', 'smart') // fixed
        .lock('antialias', true)
        ;

    if(!def.get(keyArgs, 'freePosition', false)){
        var basePosProp  = panel.isOrientationVertical() ? "left" : "bottom",
            orthoPosProp = panel.anchorOrtho(basePosProp);

        this/* Positions */
            ._lockDynamic(orthoPosProp, 'y')
            ._lockDynamic(basePosProp,  'x');
    }

    this/* Colors & Line */
        ._bindProperty('strokeStyle', 'strokeColor', 'color')
        ._bindProperty('lineWidth',   'strokeWidth')
        ;

    // Segmented lines use fill color instead of stroke...so this doesn't work.
    //this.pvMark.lineCap('square');
})
.prototype
.property('strokeWidth')
.constructor
.add({
    _addInteractive: function(keyArgs){
        keyArgs = def.setDefaults(keyArgs, 
                        'noTooltip',  true);
        
        this.base(keyArgs);
    },

    /* Sign Spatial Coordinate System
     *  -> Cartesian coordinates
     *  -> Grows Up, vertically, and Right, horizontally
     *  -> Independent of the chart's orientation
     *  -> X - horizontal axis
     *  -> Y - vertical axis
     *
     *  y
     *  ^
     *  |
     *  |
     *  o-----> x
     */
    y: function(){ return 0; },
    x: function(){ return 0; },

    /* STROKE WIDTH */
    defaultStrokeWidth: function(){
        return 1.5;
    },

    interactiveStrokeWidth: function(strokeWidth){
        if(this.isActiveSeriesAware && this.scene.isActiveSeries()){
            /* - Ensure a normal width of at least 1,
             * - Double and a half that
             */
            return Math.max(1, strokeWidth) * 2.5;
        }

        return strokeWidth;
    },
    
    /* STROKE COLOR */
    /**
     * @override
     */
    interactiveColor: function(color, type){
        var scene = this.scene;
        if(scene.anySelected() && !scene.isSelected()) {
            
            if(this.isActiveSeriesAware && scene.isActiveSeries()) {
                //return color.darker(1.5);
                return pv.Color.names.darkgray.darker().darker();
            }
            
            if(type === 'stroke'){
                return this.dimColor(color, type);
            }
        }

        return this.base(color, type);
    }
});

def.type('pvc.visual.Area', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){
    
    var pvMark = protoMark.add(pv.Area);
    
    if(!keyArgs) { keyArgs = {}; }
    
    keyArgs.freeColor = true;
    
    this.base(panel, pvMark, keyArgs);
    
    var antialias = def.get(keyArgs, 'antialias', true);
    
    this
        .lock('segmented', 'smart') // fixed, not inherited
        .lock('antialias', antialias)
        ;

    if(!def.get(keyArgs, 'freePosition', false)){
        var basePosProp  = panel.isOrientationVertical() ? "left" : "bottom",
            orthoPosProp = panel.anchorOrtho(basePosProp),
            orthoLenProp = panel.anchorOrthoLength(orthoPosProp);
        
        /* Positions */
        this
            ._lockDynamic(basePosProp,  'x')  // ex: left
            ._lockDynamic(orthoPosProp, 'y')  // ex: bottom
            ._lockDynamic(orthoLenProp, 'dy') // ex: height
            ;
    }
    
    /* Colors */
    this._bindProperty('fillStyle', 'fillColor', 'color');
    
    // These really have no real meaning in the area and should not be used.
    // If lines are desired, they should be created with linesVisible of LineChart
    this.lock('strokeStyle', null)
        .lock('lineWidth',   0)
        ;
})
.add({
    _addInteractive: function(keyArgs){
        keyArgs = def.setDefaults(keyArgs, 
                        'noTooltip',  true);

        this.base(keyArgs);
    },

    /* Sign Spatial Coordinate System
     *  -> Cartesian coordinates
     *  -> Grows Up, vertically, and Right, horizontally
     *  -> Independent of the chart's orientation
     *  -> X - horizontal axis
     *  -> Y - vertical axis
     *  
     *  y       ^
     *  ^    dY |
     *  |       - y
     *  |
     *  o-----> x
     */
    x:  function(){ return 0; },
    y:  function(){ return 0; },
    dy: function(){ return 0; },
    
    /* COLOR */
    /**
     * @override
     */
    interactiveColor: function(color, type){
        if(type === 'fill'){
            if(this.scene.anySelected() && !this.scene.isSelected()) {
                return this.dimColor(color, type);
            }
        }

        return this.base(color, type);
    }
});

def.type('pvc.visual.Bar', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){

    var pvMark = protoMark.add(pv.Bar);
    
    keyArgs = def.setDefaults(keyArgs, 'freeColor', false);
    
    this.base(panel, pvMark, keyArgs);

    this.normalStroke = def.get(keyArgs, 'normalStroke', false);

    this._bindProperty('lineWidth',  'strokeWidth');
})
.prototype
.property('strokeWidth')
.constructor
.add({
    /* COLOR */
    /**
     * @override
     */
    normalColor: function(color, type){
        if(type === 'stroke' && !this.normalStroke){
            return null;
        }

        return color;
    },

    /**
     * @override
     */
    interactiveColor: function(color, type){
        var scene = this.scene;
        
        if(type === 'stroke'){
            if(scene.isActive){
               return color.brighter(1.3).alpha(0.7);
            }
            
            if(!this.normalStroke){
                return null;
            }

            if(scene.anySelected() && !scene.isSelected()) {
                if(this.isActiveSeriesAware && scene.isActiveSeries()) {
                    return pv.Color.names.darkgray.darker().darker();
                }

                return this.dimColor(color, type);
            } else if(this.isActiveSeriesAware && scene.isActiveSeries()){
                return color.brighter(1).alpha(0.7);
            }

        } else if(type === 'fill'){
            if(scene.isActive) {
                return color.brighter(0.2).alpha(0.8);
            } 

            if(scene.anySelected() && !scene.isSelected()) {
                if(this.isActiveSeriesAware && scene.isActiveSeries()) {
                    return pv.Color.names.darkgray.darker(2).alpha(0.8);
                }

                return this.dimColor(color, type);
            } else if(this.isActiveSeriesAware && scene.isActiveSeries()){
                return color.brighter(0.2).alpha(0.8);
            }
        }

        return this.base(color, type);
    },

    /* STROKE WIDTH */    
    defaultStrokeWidth: function(){
        return 0.5;
    },

    interactiveStrokeWidth: function(strokeWidth){
        if(this.scene.isActive){
            return Math.max(1, strokeWidth) * 1.3;
        }

        return strokeWidth;
    }
});


pv.PieSlice = function(){
    pv.Wedge.call(this);
};

pv.PieSlice.prototype = pv.extend(pv.Wedge);

// There's already a Wedge#midAngle method
// but it doesn't work well when end-angle isn't explicitly set,
// so we override the method.
pv.PieSlice.prototype.midAngle = function(){
    var instance = this.instance();
    return instance.startAngle + (instance.angle / 2);
};
    

def.type('pvc.visual.PieSlice', pvc.visual.Sign)
.init(function(panel, protoMark, keyArgs){

    var pvMark = protoMark.add(pv.PieSlice);
    
    keyArgs = def.setDefaults(keyArgs, 'freeColor', false);
    
    this.base(panel, pvMark, keyArgs);
    
    this._activeOffsetRadius = def.get(keyArgs, 'activeOffsetRadius', 0);
    this._center = def.get(keyArgs, 'center');
    
    this/* Colors */
        .optional('lineWidth',  0.6)
        ._bindProperty('angle', 'angle')
        ._lockDynamic('bottom', 'y')
        ._lockDynamic('left',   'x')
        .lock('top',   null)
        .lock('right', null)
        ;
})
.prototype
.property('offsetRadius')
.constructor
.add({
    // Ensures that it is evaluated before x and y
    angle: function(){
        return 0;
    },
    
    x: function(){
        return this._center.x + this._offsetSlice('cos'); 
    },
    
    y: function(){ 
        return this._center.y - this._offsetSlice('sin'); 
    },
    
    // ~ midAngle -> (endAngle + startAngle) / 2
    _offsetSlice: function(fun) {
        var offset = this._getOffsetRadius();
        if(offset !== 0){
            offset = offset * Math[fun](this.pvMark.midAngle());
        }
            
        return offset;
    },
    
    // Get and cache offsetRadius 
    _getOffsetRadius: function(){
        var offset = this.state.offsetRadius;
        if(offset == null){
            offset = (this.state.offsetRadius = this.offsetRadius() || 0);
        }
        
        return offset;
    },
    
    /* COLOR */
    
    /**
     * @override
     */
    defaultColor: function(type){
        if(type === 'stroke'){
            return null;
        }
        
        return this.base(type);
    },
    
    /**
     * @override
     */
    interactiveColor: function(color, type){
        var scene = this.scene;
        if(scene.isActive) {
            switch(type) {
                // Like the bar chart
                case 'fill':   return color.brighter(0.2).alpha(0.8);
                case 'stroke': return color.brighter(1.3).alpha(0.7);
            }
        } else if(scene.anySelected() && !scene.isSelected()) {
            //case 'stroke': // ANALYZER requirements, so until there's no way to configure it...
            if(type === 'fill') {
                return this.dimColor(color, type);
            }
        }

        return this.base(color, type);
    },
    
    /* Offset */
    baseOffsetRadius: function(){
        // There's no extension point for this
        return 0;
    },

    interactiveOffsetRadius: function(offsetRadius){
        if(this.scene.isActive){
            return offsetRadius + this._activeOffsetRadius;
        }

        return offsetRadius;
    }
});

def.type('pvc.visual.Rule', pvc.visual.Sign)
.init(function(panel, parentMark, keyArgs){

    var pvMark = parentMark.add(pv.Rule);
    
    var protoMark = def.get(keyArgs, 'proto');
    if(protoMark){
        pvMark.extend(protoMark);
        //pvMark.duckExtension(protoMark, pvc.extensionTag);
    }
    
    this.base(panel, pvMark, keyArgs);
    
    if(!def.get(keyArgs, 'freeStyle')){
        this/* Colors & Line */
            ._bindProperty('strokeStyle', 'strokeColor', 'color')
            ._bindProperty('lineWidth',   'strokeWidth')
            ;
    }
})
.prototype
.property('strokeWidth')
.constructor
.add({
    _addInteractive: function(keyArgs){
        keyArgs = def.setDefaults(keyArgs,
                        'noHover',       true,
                        'noSelect',      true,
                        'noTooltip',     true,
                        'noClick',       true,
                        'noDoubleClick', true);

        this.base(keyArgs);
    },

    /* STROKE WIDTH */
    defaultStrokeWidth: function(){
        return 1;
    },

    interactiveStrokeWidth: function(strokeWidth){
        if(this.scene.isActive){
            return Math.max(1, strokeWidth) * 2.2;
        }

        return strokeWidth;
    },

    /* STROKE COLOR */
    interactiveColor: function(color, type){
        var scene = this.scene;
        
        if(!scene.isActive && scene.anySelected() && scene.datum && !scene.isSelected()) {
            return this.dimColor(color, type);
        }
        
        return this.base(color, type);
    }
});
/**
 * Initializes a visual context.
 * 
 * @name pvc.visual.Context
 * 
 * @class Represents a visualization context.  
 * The visualization context gives access to all relevant information
 * for rendering or interacting with a visualization.
 * <p>
 * A visualization context object <i>may</i> be reused
 * across extension points invocations and actions.
 * </p>
 * 
 * @property {pvc.BaseChart} chart The chart instance.
 * @property {pvc.BasePanel} panel The panel instance.
 * @property {number} index The render index.
 * @property {pvc.visual.Scene} scene The render scene.
 * @property {object} event An event object, present when a click or double-click action is being processed.
 * @property {pv.Mark} pvMark The protovis mark.
 * 
 * @constructor
 * @param {pvc.BasePanel} panel The panel instance.
 * @param {pv.Mark} mark The protovis mark.
 * @param {object} [event] An event object.
 */
def.type('pvc.visual.Context')
.init(function(panel, mark, event){
    this.chart = panel.chart;
    this.panel = panel;
    
    visualContext_update.call(this, mark, event);
})
.add(/** @lends pvc.visual.Context */{
    isPinned: false,
    
    pin: function(){
        this.isPinned = true;
        return this;
    },
    
    finished: function(v){
        /*jshint sub:true */
        return this.sign.finished(v);
    },
    
    delegate: function(dv){
        return this.sign.delegate(dv);
    },
    
    /* V1 DIMENSION ACCESSORS */
    getV1Series: function(){
        var s;
        var series = this.scene.atoms && (s = this.scene.atoms[this.panel._getV1DimName('series')]) && s.rawValue;
        if(series == null){
            series = 'Series';
        }
        
        return series;
    },
    
    getV1Category: function(){
        var c;
        return this.scene.atoms && (c = this.scene.atoms[this.panel._getV1DimName('category')]) && c.rawValue;
    },
               
    getV1Value: function(){
        var v;
        return this.scene.atoms && (v = this.scene.atoms[this.panel._getV1DimName('value')]) && v.value;
    },
    
    getV1Datum: function(){
        return this.panel._getV1Datum(this.scene);
    }
});

if(Object.defineProperty){
    try{
        Object.defineProperty(pvc.visual.Context.prototype, 'parent', {
            get: function(){
                throw def.error.operationInvalid("The 'this.parent.index' idiom has no equivalent in this version. Please try 'this.pvMark.parent.index'.");
            }
        });
    } catch(ex) {
        /* IE THROWS */
    }
}

/**
 * Used internally to update a visual context.
 * 
 * @name pvc.visual.Context#_update
 * @function
 * @param {pv.Mark} mark The protovis mark being rendered or targeted by an event.
 * @param {object} [event] An event object.
 * @type undefined
 * @private
 * @virtual
 * @internal
 */
function visualContext_update(mark, event){

    this.event  = event || null;
    this.pvMark = mark;
    
    var scene;
    if(mark){
        this.sign  = mark.sign || null;
        
        var instance = mark.instance();
        scene = instance._scene;
        if(!scene){
            this.index = null;
            
            var group = instance.group,
                datum = group ? null : instance.datum;
            
            scene = new pvc.visual.Scene(null, {
                panel: this.panel,
                group: group,
                datum: datum
            });
        } else {
            this.index = scene.childIndex();
        }
    } else {
        this.sign  = null;
        this.index = null;
        
        scene = new pvc.visual.Scene(null, {
            panel: this.panel,
            group: this.chart.root.data
        });
    }
    
    this.scene = scene;
}
/**
 * Initializes a chart object with options.
 * 
 * @name pvc.visual.OptionsBase
 * 
 * @class Represents a chart object that has options.
 * 
 * @property {pvc.BaseChart} chart The associated chart.
 * @property {string} type The type of object.
 * @property {number} index The index of the object within its type (0, 1, 2...).
 * @property {string} [name] The name of the object.
 * 
 * @constructor
 * @param {pvc.BaseChart} chart The associated chart.
 * @param {string} type The type of the object.
 * @param {number} [index=0] The index of the object within its type.
 * @param {object} [keyArgs] Keyword arguments.
 * @param {string} [keyArgs.name] The name of the object.
 */
def
.type('pvc.visual.OptionsBase')
.init(function(chart, type, index, keyArgs){
    this.chart = chart;
    this.type  = type;
    this.index = index == null ? 0 : index;
    this.name  = def.get(keyArgs, 'name');
    this.id    = this._buildId();
    this.optionId = this._buildOptionId();
    
    var rs = this._resolvers = [];
    
    this._registerResolversFull(rs, keyArgs);
    
    this.option = pvc.options(this._getOptionsDefinition(), this);
})
.add(/** @lends pvc.visual.OptionsBase# */{
    
    _buildId: function(){
        return pvc.buildIndexedId(this.type, this.index);
    },
    
    _buildOptionId: function(){
        return this.id;
    },
        
    _getOptionsDefinition: def.method({isAbstract: true}),
    
    _chartOption: function(name) {
        return this.chart.options[name];
    },
    
    _registerResolversFull: function(rs, keyArgs){
        // I - By Fixed values
        var fixed = def.get(keyArgs, 'fixed');
        if(fixed){
            this._fixed = fixed;
            rs.push(
                pvc.options.specify(function(optionInfo){
                    return fixed[optionInfo.name];
                }));
        }
        
        this._registerResolversNormal(rs, keyArgs);
        
        // VI - By Default Values
        var defaults = def.get(keyArgs, 'defaults');
        if(defaults){
            this._defaults = defaults;
        }
        
        rs.push(this._resolveDefault);
    },
    
    _registerResolversNormal: function(rs, keyArgs){
        // II - By V1 Only Logic
        if(this.chart.compatVersion() <= 1){
            rs.push(this._resolveByV1OnlyLogic);
        }
        
        // III - By Name (ex: plot2, trend)
        if(this.name){
            rs.push(
                pvc.options.specify(function(optionInfo){
                      return this._chartOption(this.name + def.firstUpperCase(optionInfo.name));
                }));
        }
        
        // IV - By OptionId
        rs.push(this._resolveByOptionId);
        
        // V - By Naked Id
        if(def.get(keyArgs, 'byNaked', !this.index)){
            rs.push(this._resolveByNaked);
        }
    },
    
    // -------------
    
    _resolveFull: function(optionInfo){
        var rs = this._resolvers;
        for(var i = 0, L = rs.length ; i < L ; i++){
            if(rs[i].call(this, optionInfo)){
                return true;
            }
        }
        return false;
    },
    
    _resolveFixed: pvc.options.specify(function(optionInfo){
        if(this._fixed){
            return this._fixed[optionInfo.name];
        }
    }),
    
    _resolveByV1OnlyLogic: function(optionInfo){
        var data = optionInfo.data;
        var resolverV1;
        if(data && (resolverV1 = data.resolveV1)){
            return resolverV1.call(this, optionInfo);
        }
    },
    
    _resolveByName: pvc.options.specify(function(optionInfo){
        if(this.name){ 
            return this._chartOption(this.name + def.firstUpperCase(optionInfo.name));
        }
    }),
    
    _resolveByOptionId: pvc.options.specify(function(optionInfo){
        return this._chartOption(this.optionId + def.firstUpperCase(optionInfo.name));
    }),
    
    _resolveByNaked: pvc.options.specify(function(optionInfo){
        // The first of the type receives options without any prefix.
        if(!this.index){
            return this._chartOption(def.firstLowerCase(optionInfo.name));
        }
    }),
    
    _resolveDefault: function(optionInfo){
        // Dynamic default value?
        var data = optionInfo.data;
        var resolverDefault;
        if(data && (resolverDefault = data.resolveDefault)){
            if(resolverDefault.call(this, optionInfo)){
                return true;
            }
        }
        
        if(this._defaults){
            var value = this._defaults[optionInfo.name];
            if(value !== undefined){
                optionInfo.defaultValue(value);
                return true;
            }
        }
    },
    
    _specifyChartOption: function(optionInfo, asName){
        var value = this._chartOption(asName);
        if(value != null){
            optionInfo.specify(value);
            return true;
        }
    }
});

// Sharing this globally allows other axes sub types to inherit
//  their own options defs from this one.
// A ccc-wide closure can hide this from global scope.
var axis_optionsDef;

def.scope(function(){

    /**
     * Initializes an axis.
     * 
     * @name pvc.visual.Axis
     * 
     * @class Represents an axis for a role in a chart.
     * 
     * @extends pvc.visual.OptionsBase
     * 
     * @property {pvc.visual.Role} role The associated visual role.
     * @property {pv.Scale} scale The associated scale.
     * 
     * @constructor
     * @param {pvc.BaseChart} chart The associated chart.
     * @param {string} type The type of the axis.
     * @param {number} [index=0] The index of the axis within its type.
     * @param {object} [keyArgs] Keyword arguments.
     */
    def
    .type('pvc.visual.Axis', pvc.visual.OptionsBase)
    .init(function(chart, type, index, keyArgs){
        
        this.base(chart, type, index, keyArgs);
        
        // Fills #axisIndex and #typeIndex
        chart._addAxis(this);
    })
    .add(/** @lends pvc.visual.Axis# */{
        isVisible: true,
        
        // should null values be converted to zero or to the minimum value in what scale is concerned?
        // 'null', 'zero', 'min', 'value'
        scaleTreatsNullAs: function(){
            return 'null';
        },
        
        scaleNullRangeValue: function(){
            return null;
        },
        
        scaleUsesAbs: function(){
            return false;
        },
        
        /**
         * Binds the axis to a set of data cells.
         * 
         * <p>
         * Only after this operation is performed will
         * options with a scale type prefix be found.
         * </p>
         * 
         * @param {object|object[]} dataCells The associated data cells.
         * @type pvc.visual.Axis
         */
        bind: function(dataCells){
            /*jshint expr:true */
            dataCells || def.fail.argumentRequired('dataCells');
            !this.dataCells || def.fail.operationInvalid('Axis is already bound.');
            
            this.dataCells = def.array.to(dataCells);
            this.dataCell  = this.dataCells[0];
            this.role = this.dataCell && this.dataCell.role;
            this.scaleType = groupingScaleType(this.role.grouping);
            
            this._checkRoleCompatibility();
            
            return this;
        },
        
        isDiscrete: function(){
            return this.role && this.role.isDsiscrete();
        },
        
        isBound: function(){
            return !!this.role;
        },
        
        setScale: function(scale){
            /*jshint expr:true */
            this.role || def.fail.operationInvalid('Axis is unbound.');
            
            this.scale = scale ? this._wrapScale(scale) : null;
    
            return this;
        },
        
        _wrapScale: function(scale){
            scale.type = this.scaleType;
            
            var by;
            
            // Applying scaleNullRangeValue to discrete scales
            // Caused problems in the discrete color scales
            // where we want it to catch the first color of the color scale,
            // in cases where there is only a null series...
            if(scale.type !== 'discrete' ){
                var useAbs = this.scaleUsesAbs();
                var nullAs = this.scaleTreatsNullAs();
                if(nullAs && nullAs !== 'null'){
                    var nullValue = nullAs === 'min' ? scale.domain()[0] : 0;
                    
                    if(useAbs){
                        by = function(v){
                            return scale(v == null ? nullValue : (v < 0 ? -v : v));
                        };
                    } else {
                        by = function(v){
                            return scale(v == null ? nullValue : v);
                        };
                    }
                } else {
                    var nullRangeValue = this.scaleNullRangeValue();
                    if(useAbs){
                        by = function(v){
                            return v == null ? nullRangeValue : scale(v < 0 ? -v : v);
                        };
                    } else {
                        by = function(v){
                            return v == null ? nullRangeValue : scale(v);
                        };
                    }
                }
            } else {
                // ensure null -> ""
                by = function(v){
                    return scale(v == null ? '' : v);
                };
            }
            
            // don't overwrite scale with by! it would cause infinite recursion...
            return def.copy(by, scale);
        },
        
        /**
         * Obtains a scene-scale function to compute values of this axis' main role.
         * 
         * @param {object} [keyArgs] Keyword arguments object.
         * @param {string} [keyArgs.sceneVarName] The local scene variable name by which this axis's role is known. Defaults to the role's name.
         * @param {boolean} [keyArgs.nullToZero=true] Indicates that null values should be converted to zero before applying the scale.
         * @type function
         */
        sceneScale: function(keyArgs){
            var varName  = def.get(keyArgs, 'sceneVarName') || this.role.name,
                grouping = this.role.grouping;
    
            if(grouping.isSingleDimension && grouping.firstDimensionValueType() === Number){
                var scale = this.scale,
                    nullToZero = def.get(keyArgs, 'nullToZero', true);
                
                var by = function(scene){
                    var value = scene.vars[varName].value;
                    if(value == null){
                        if(!nullToZero){
                            return value;
                        }
                        value = 0;
                    }
                    return scale(value);
                };
                def.copy(by, scale);
                
                return by;
            }
    
            return this.scale.by1(function(scene){
                return scene.vars[varName].value;
            });
        },
        
        _checkRoleCompatibility: function(){
            var L = this.dataCells.length;
            if(L > 1){
                var grouping = this.role.grouping, 
                    i;
                if(this.scaleType === 'discrete'){
                    for(i = 1; i < L ; i++){
                        if(grouping.id !== this.dataCells[i].role.grouping.id){
                            throw def.error.operationInvalid("Discrete roles on the same axis must have equal groupings.");
                        }
                    }
                } else {
                    if(!grouping.firstDimensionType().isComparable){
                        throw def.error.operationInvalid("Continuous roles on the same axis must have 'comparable' groupings.");
                    }
    
                    for(i = 1; i < L ; i++){
                        if(this.scaleType !== groupingScaleType(this.dataCells[i].role.grouping)){
                            throw def.error.operationInvalid("Continuous roles on the same axis must have scales of the same type.");
                        }
                    }
                }
            }
        },
        
        _getOptionsDefinition: function(){
            return axis_optionsDef;
        }
    });
    
    function groupingScaleType(grouping){
        return grouping.isDiscrete() ?
                    'discrete' :
                    (grouping.firstDimensionValueType() === Date ?
                    'timeSeries' :
                    'numeric');
    }
    
    axis_optionsDef = {
    // NOOP
    };
});def.scope(function(){

    var $VA = pvc.visual.Axis;
    /**
     * Initializes a cartesian axis.
     * 
     * @name pvc.visual.CartesianAxis
     * 
     * @class Represents an axis for a role in a cartesian chart.
     * <p>
     * The main properties of an axis: {@link #type}, {@link #orientation} and relevant chart's properties 
     * are related as follows:
     * </p>
     * <pre>
     * axisType={base, ortho} = f(axisOrientation={x,y})
     * 
     *          Vertical   Horizontal   (chart orientation)
     *         +---------+-----------+
     *       x | base    |   ortho   |
     *         +---------+-----------+
     *       y | ortho   |   base    |
     *         +---------+-----------+
     * (axis orientation)
     * </pre>
     * 
     * @extends pvc.visual.Axis
     * 
     * @property {pvc.CartesianAbstract} chart The associated cartesian chart.
     * @property {string} type The type of the axis. One of the values: 'base' or 'ortho'.
     * @property {string} orientation The orientation of the axis. 
     * One of the values: 'x' or 'y', for horizontal and vertical axis orientations, respectively.
     * @property {string} orientedId The id of the axis with respect to the orientation and the index of the axis ("").
     * 
     * @constructor
     * @param {pvc.CartesianAbstract} chart The associated cartesian chart.
     * @param {string} type The type of the axis. One of the values: 'base' or 'ortho'.
     * @param {number} [index=0] The index of the axis within its type.
     * @param {object} [keyArgs] Keyword arguments.
     * See {@link pvc.visual.Axis} for supported keyword arguments. 
     */
    def
    .type('pvc.visual.CartesianAxis', $VA)
    .init(function(chart, type, index, keyArgs){
        
        var options = chart.options;
        
        // x, y
        this.orientation = $VCA.getOrientation(type, options.orientation);
        
        // x, y, x2, y2, x3, y3, ...
        this.orientedId = $VCA.getOrientedId(this.orientation, index);
        
        // secondX, secondY
        if(chart._allowV1SecondAxis &&  index === 1){
            this.v1SecondOrientedId = 'second' + this.orientation.toUpperCase();
        }
        
        // id
        // base, ortho, base2, ortho2, ...
        
        // scaleType
        // discrete, continuous, numeric, timeSeries
        
        // common
        // axis
        
        this.base(chart, type, index, keyArgs);
        
        // For now scale type is left off, 
        // cause it is yet unknown.
        // In bind, prefixes are recalculated (see _syncExtensionPrefixes)
        var extensions = this.extensionPrefixes = [
            this.id + 'Axis', 
            this.orientedId + 'Axis'
        ];
        
        if(this.v1SecondOrientedId){
            extensions.push(this.v1SecondOrientedId + 'Axis');
        }
        
        this._extPrefAxisPosition = extensions.length;
        
        extensions.push('axis');
    })
    .add(/** @lends pvc.visual.CartesianAxis# */{
        
        bind: function(dataCells){
            
            this.base(dataCells);
            
            this._syncExtensionPrefixes();
            
            return this;
        },
        
        _syncExtensionPrefixes: function(){
            var extensions = this.extensionPrefixes;
            
            // remove until 'axis' (inclusive)
            extensions.length = this._extPrefAxisPosition;
            
            var st = this.scaleType;
            if(st){
                extensions.push(st + 'Axis'); // specific
                if(st !== 'discrete'){
                    extensions.push('continuousAxis'); // generic
                }
            }
            
            // Common
            extensions.push('axis');
        },
        
        setScale: function(scale){
            var oldScale = this.scale;
            
            this.base(scale);
            
            if(oldScale){
                // If any
                delete this.domain;
                delete this.ticks;
                delete this._roundingPaddings;
            }
            
            if(scale){
                if(!scale.isNull && this.scaleType !== 'discrete'){
                    // Original data domain, before nice or tick rounding
                    this.domain = scale.domain();
                    this.domain.minLocked = !!scale.minLocked;
                    this.domain.maxLocked = !!scale.maxLocked;
                    
                    if(this.scaleType === 'numeric'){
                        var roundMode = this.option('DomainRoundMode');
                        if(roundMode === 'nice'){
                            scale.nice();
                        }
                        
                        var tickFormatter = this.option('TickFormatter');
                        if(tickFormatter){
                            scale.tickFormatter(tickFormatter);
                        }
                    }
                }
            }
            
            return this;
        },
        
        setTicks: function(ticks){
            var scale = this.scale;
            
            /*jshint expr:true */
            (scale && !scale.isNull) || def.fail.operationInvalid("Scale must be set and non-null.");
            
            this.ticks = ticks;
            
            if(scale.type === 'numeric' && this.option('DomainRoundMode') === 'tick'){
                
                delete this._roundingPaddings;
                
                // Commit calculated ticks to scale's domain
                var tickCount = ticks && ticks.length;
                if(tickCount){
                    this.scale.domain(ticks[0], ticks[tickCount - 1]);
                } else {
                    // Reset scale domain
                    this.scale.domain(this.domain[0], this.domain[1]);
                }
            }
        },
        
        setScaleRange: function(size){
            var scale  = this.scale;
            scale.min  = 0;
            scale.max  = size;
            scale.size = size; // original size // TODO: remove this...
            
            // -------------
            
            if(scale.type === 'discrete'){
                if(scale.domain().length > 0){ // Has domain? At least one point is required to split.
                    var bandRatio = this.chart.options.panelSizeRatio || 0.8;
                    scale.splitBandedCenter(scale.min, scale.max, bandRatio);
                }
            } else {
                scale.range(scale.min, scale.max);
            }
            
            return scale;
        },
        
        getScaleRoundingPaddings: function(){
            var roundingPaddings = this._roundingPaddings;
            if(!roundingPaddings){
                roundingPaddings = {
                        begin: 0, 
                        end:   0, 
                        beginLocked: false, 
                        endLocked:   false
                };
                
                var scale = this.scale;
                if(scale && !scale.isNull && scale.type !== 'discrete'){
                    var originalDomain = this.domain;
                    
                    roundingPaddings.beginLocked = originalDomain.minLocked;
                    roundingPaddings.endLocked   = originalDomain.maxLocked;
                    
                    if(scale.type === 'numeric' && this.option('DomainRoundMode') !== 'none'){
                        var currDomain = scale.domain();
                        var origDomain = this.domain || def.assert("Original domain must be set");
                        var currLength = currDomain[1] - currDomain[0];
                        if(currLength){
                            // begin dif
                            var dif = origDomain[0] - currDomain[0];
                            if(dif > 0){
                                roundingPaddings.begin = dif / currLength;
                            }
                            
                            // end dif
                            dif = currDomain[1] - origDomain[1];
                            if(dif > 0){
                                roundingPaddings.end = dif / currLength;
                            }
                        }
                    }
                }
                
                this._roundingPaddings = roundingPaddings;
            }
            
            return roundingPaddings;
        },
        
        _getOptionsDefinition: function(){
            return cartAxis_optionsDef;
        },
        
        _buildOptionId: function(){
            return this.id + "Axis";
        },
        
        _registerResolversNormal: function(rs, keyArgs){
            // II - By V1 Only Logic
            if(this.chart.compatVersion() <= 1){
                rs.push(this._resolveByV1OnlyLogic);
            }
            
            // IV - By OptionId
            rs.push(
               this._resolveByOptionId,
               this._resolveByOrientedId);
            
            if(this.index === 1){
                rs.push(this._resolveByV1OptionId);
            }
            
            rs.push(
               this._resolveByScaleType,
               this._resolveByCommonId);
            
        },
        
        // xAxisOffset, yAxisOffset, x2AxisOffset
        _resolveByOrientedId: pvc.options.specify(function(optionInfo){
            return this._chartOption(this.orientedId + "Axis" + optionInfo.name);
        }),
        
        // secondAxisOffset
        _resolveByV1OptionId: pvc.options.specify(function(optionInfo){
            //if(this.index === 1){
            return this._chartOption('secondAxis' + optionInfo.name);
            //}
        }),
        
        // numericAxisLabelSpacingMin
        _resolveByScaleType: pvc.options.specify(function(optionInfo){
            // this.scaleType
            // * discrete
            // * numeric    | continuous
            // * timeSeries | continuous
            var st = this.scaleType;
            if(st){
                var name  = optionInfo.name;
                var value = this._chartOption(st + 'Axis' + name);
                if(value === undefined && st !== 'discrete'){
                    value = this._chartOption('continuousAxis' + name);
                }
                
                return value;
            }
        }),
        
        // axisOffset
        _resolveByCommonId: pvc.options.specify(function(optionInfo){
            return this._chartOption('axis' + optionInfo.name);
        })
    });
    
    var $VCA = pvc.visual.CartesianAxis;

    /**
     * Obtains the orientation of the axis given an axis type and a chart orientation.
     * 
     * @param {string} type The type of the axis. One of the values: 'base' or 'ortho'.
     * @param {string} chartOrientation The orientation of the chart. One of the values: 'horizontal' or 'vertical'.
     * 
     * @type string
     */
    $VCA.getOrientation = function(type, chartOrientation){
        return ((type === 'base') === (chartOrientation === 'vertical')) ? 'x' : 'y';  // NXOR
    };
    
    /**
     * Calculates the oriented id of an axis given its orientation and index.
     * @param {string} orientation The orientation of the axis.
     * @param {number} index The index of the axis within its type. 
     * @type string
     */
    $VCA.getOrientedId = function(orientation, index){
        if(index === 0) {
            return orientation; // x, y
        }
        
        return orientation + (index + 1); // x2, y3, x4,...
    };
    
    /* PRIVATE STUFF */
    var fixedMinMaxSpec = {
        resolve: '_resolveFull',
        data: {
            /* orthoFixedMin, orthoFixedMax */
            resolveV1: function(optionInfo){
                if(!this.index && this.type === 'ortho'){
                    // Bare Id (no "Axis")
                    this._specifyChartOption(optionInfo, this.id + optionInfo.name);
                }
                return true;
            }
        },
        cast: pvc.castNumber
    };
    
    function castDomainScope(scope, axis){
        return pvc.parseDomainScope(scope, axis.orientation);
    }
    
    function castAxisPosition(side){
        if(side){
            if(def.hasOwn(pvc.Sides.namesSet, side)){
                var mapAlign = pvc.BasePanel[this.orientation === 'y' ? 'horizontalAlign' : 'verticalAlign2'];
                return mapAlign[side];
            }
            
            if(pvc.debug >= 2){
                pvc.log(def.format("Invalid axis position value '{0}'.", [side]));
            }
        }
        
        // Ensure a proper value
        return this.orientation === 'x' ? 'bottom' : 'left';
    }
    
    var normalV1Data = {
        resolveV1: function(optionInfo){
            if(!this.index){
                if(this._resolveByOrientedId(optionInfo)){
                    return true;
                }
            } else if(this._resolveByV1OptionId(optionInfo)) { // secondAxis...
                return true;
            }
            
            this._resolveDefault(optionInfo);
            
            return true;
        }
    };
    
    var defaultPosition = pvc.options.defaultValue(function(optionInfo){
        if(!this.typeIndex){
            return this.orientation === 'x' ? 'bottom' : 'left';
        }
        
        // Use the position opposite to that of the first axis 
        // of same orientation (the same as type)
        var firstAxis = this.chart.axesByType[this.type].first;
        var position  = firstAxis.option('Position');
        
        return pvc.BasePanel.oppositeAnchor[position];
    });
    
    function castSize(value){
        var position = this.option('Position');
        return pvc.Size.toOrtho(value, position);
    }
    
    function castTitleSize(value){
        var position = this.option('Position');
        
        return pvc.Size.to(value, {singleProp: pvc.BasePanel.orthogonalLength[position]});
    }
    
    /*global axis_optionsDef:true*/
    var cartAxis_optionsDef = def.create(axis_optionsDef, {
        Visible: {
            resolve: '_resolveFull',
            data: {
                /* showXScale, showYScale, showSecondScale */
                resolveV1: function(optionInfo){
                    if(this.index <= 1){
                        var v1OptionId = this.index === 0 ? 
                            def.firstUpperCase(this.orientation) :
                            'Second';
                        
                        this._specifyChartOption(optionInfo, 'show' + v1OptionId + 'Scale');
                    }
                    return true;
                }
            },
            cast:    Boolean,
            value:   true
        },
        
        /*
         * 1     <- useCompositeAxis
         * >= 2  <- false
         */
        Composite: {
            resolve: function(optionInfo){
                // Only first axis can be composite?
                if(this.index > 0) {
                    optionInfo.specify(false);
                    return true;
                }
                
                return this._resolveFull(optionInfo);
            },
            data: {
                resolveV1: function(optionInfo){
                    this._specifyChartOption(optionInfo, 'useCompositeAxis');
                    return true;
                }
            },
            cast:  Boolean,
            value: false
        },
        
        /* xAxisSize,
         * secondAxisSize || xAxisSize 
         */
        Size: {
            resolve: '_resolveFull',
            data:    normalV1Data,
            cast:    castSize
        },
        
        SizeMax: {
            resolve: '_resolveFull',
            cast:    castSize
        },
        
        /* xAxisPosition,
         * secondAxisPosition <- opposite(xAxisPosition) 
         */
        Position: {
            resolve: '_resolveFull',
            data: {
                resolveV1: normalV1Data.resolveV1,
                resolveDefault: defaultPosition
            },
            cast: castAxisPosition
        },
        
        FixedMin: fixedMinMaxSpec,
        FixedMax: fixedMinMaxSpec,
        
        /* 1 <- originIsZero (v1)
         * 2 <- secondAxisOriginIsZero (v1 && bar)
         */
        OriginIsZero: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    switch(this.index){
                        case 0: 
                            this._specifyChartOption(optionInfo, 'originIsZero');
                            break;
                        case 1:
                            if(this.chart._allowV1SecondAxis){
                                this._specifyChartOption(optionInfo, 'secondAxisOriginIsZero');
                            }
                            break;
                    }
                    
                    return true;
                } 
            },
            cast:  Boolean,
            value: true 
        }, 
        
        DomainScope: {
            resolve: '_resolveFull',
            cast:    castDomainScope,
            value:   'global'
        },
        
        /* 1 <- axisOffset, 
         * 2 <- secondAxisOffset (V1 && bar)
         */
        Offset: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    switch(this.index) {
                        case 0: 
                            this._specifyChartOption(optionInfo, 'axisOffset');
                            break;
                            
                        case 1:
                            if(this.chart._allowV1SecondAxis){
                                this._specifyChartOption(optionInfo, 'secondAxisOffset');
                                break;
                            }
                            break;
                    }
                    
                    return true;
                }
            },
            cast: pvc.castNumber
        },
        
        // em
        LabelSpacingMin: {
            resolve: '_resolveFull',
            cast:    pvc.castNumber
        },
        
        OverlappedLabelsMode: {
            resolve: '_resolveFull',
            cast:    pvc.parseOverlappedLabelsMode,
            value:   'hide'
        },
        
        /* RULES */
        Grid: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    if(!this.index){
                        this._specifyChartOption(optionInfo, this.orientation + 'AxisFullGrid');
                    }
                    return true;
                }
            },
            cast:    Boolean,
            value:   false
        },
        
        GridCrossesMargin: { // experimental
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   true
        },
        
        EndLine:  { // deprecated
            resolve: '_resolveFull',
            cast:    Boolean
        },
        
        ZeroLine: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   true 
        },
        RuleCrossesMargin: { // experimental
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   true
        },
        
        /* TICKS */
        Ticks: {
            resolve: '_resolveFull',
            cast:    Boolean
        },
        DesiredTickCount: { // secondAxisDesiredTickCount (v1 && bar)
            resolve: '_resolveFull',
            data: {
                resolveV1: normalV1Data.resolveV1,
                resolveDefault: function(optionInfo){
                    if(this.chart.compatVersion() <= 1){
                        optionInfo.defaultValue(5);
                        return true;
                    }
                }
            },
            cast: pvc.castNumber
        },
        MinorTicks: {
            resolve: '_resolveFull',
            data:    normalV1Data,
            cast:    Boolean,
            value:   true 
        },
        TickFormatter: {
            resolve: '_resolveFull',
            cast:    def.fun.as
        },
        DomainRoundMode: { // secondAxisRoundDomain (bug && v1 && bar), secondAxisDomainRoundMode (v1 && bar)
            resolve: '_resolveFull',
            data: {
                resolveV1: normalV1Data.resolveV1,
                resolveDefault: function(optionInfo){
                    if(this.chart.compatVersion() <= 1){
                        optionInfo.defaultValue('none');
                        return true;
                    }
                }
            },
            
            cast:    pvc.parseDomainRoundingMode,
            value:   'tick'
        },
        TickExponentMin: {
            resolve: '_resolveFull',
            cast:    pvc.castNumber  
        },
        TickExponentMax: {
            resolve: '_resolveFull',
            cast:    pvc.castNumber 
        },
        
        /* TITLE */
        Title: {
            resolve: '_resolveFull',
            cast:    String
        },
        TitleSize: {
            resolve: '_resolveFull',
            cast:    castTitleSize
        },
        TitleSizeMax: {
            resolve: '_resolveFull',
            cast:    castTitleSize
        }, 
        TitleFont: {
            resolve: '_resolveFull',
            cast:    String 
        },
        TitleMargins:  {
            resolve: '_resolveFull',
            cast:    pvc.Sides.as 
        },
        TitlePaddings: {
            resolve: '_resolveFull',
            cast:    pvc.Sides.as 
        },
        TitleAlign: {
            resolve: '_resolveFull',
            cast: function castAlign(align){
                var position = this.option('Position');
                return pvc.parseAlign(position, align);
            }
        },
        
        Font: { // axisLabelFont (v1 && index == 0 && HeatGrid)
            resolve: '_resolveFull',
            cast:    String
        },
        
        ClickAction: { 
            resolve: '_resolveFull',
            data: normalV1Data
        }, // (v1 && index === 0) 
        DoubleClickAction: { 
            resolve: '_resolveFull',
            data: normalV1Data
        } // idem
    });
});
/**
 * Initializes an axis root scene.
 * 
 * @name pvc.visual.CartesianAxisRootScene
 * 
 * @extends pvc.visual.Scene
 * 
 * @constructor
 * @param {pvc.visual.Scene} [parent] The parent scene, if any.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for supported keyword arguments.
 */
def
.type('pvc.visual.CartesianAxisRootScene', pvc.visual.Scene);
/**
 * Initializes an axis tick scene.
 * 
 * @name pvc.visual.CartesianAxisTickScene
 * 
 * @extends pvc.visual.Scene
 * 
 * @constructor
 * @param {pvc.visual.CartesianAxisRootScene} [parent] The parent scene, if any.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for supported keyword arguments.
 */
def
.type('pvc.visual.CartesianAxisTickScene', pvc.visual.Scene)
.init(function(parent, keyArgs){
    
    this.base(parent, keyArgs);
    
    this.vars.tick = new pvc.visual.ValueLabelVar(
            def.get(keyArgs, 'tick'),
            def.get(keyArgs, 'tickLabel'),
            def.get(keyArgs, 'tickRaw'));
});def.scope(function(){

    /**
     * Initializes a color axis.
     * 
     * @name pvc.visual.ColorAxis
     * 
     * @class Represents an axis that maps colors to the values of a role.
     * 
     * @extends pvc.visual.Axis
     */
    def
    .type('pvc.visual.ColorAxis', pvc.visual.Axis)
    .add(/** @lends pvc.visual.ColorAxis# */{
        
        scaleNullRangeValue: function(){
            return this.option('Missing') || null;
        },
        
        scaleUsesAbs: function(){
            return this.option('UseAbs');
        },
        
        bind: function(dataCells){
            this.base(dataCells);
            
            // -- collect distinct plots
            // Transform depends on this
            // Colors depends on Transform
            this._plotList = 
                def
                .query(dataCells)
                .select(function(dataCell){ return dataCell.plot; })
                .distinct(function(plot){ return plot && plot.id; })
                .array()
                ;
            
            return this;
        },
        
        calculateScale: function(){
            /*jshint expr:true */
            var scale;
            var dataCells = this.dataCells;
            if(dataCells){
                var chart = this.chart;
                if(this.scaleType === 'discrete'){
                    var domainValues = 
                        def
                        .query(dataCells)
                        .selectMany(function(dataCell){
                            var role = dataCell.role;
                            if(role && role.isBound()){
                                // Visible and not visible!
                                var partData = chart.partData(dataCell.dataPartValue);
                                var domainData = partData && partData.flattenBy(role);
                                
                                dataCell.data = domainData;
                                
                                return domainData && domainData.children();
                            }
                        })
                        .distinct(function(child){ return child.key; })
                        .select(function(child){ return def.nullyTo(child.value, ''); })
                        .array()
                        ;
                    
                    this.domainValues = domainValues;
                    
                    // Call the transformed color scheme with the domain values
                    //  to obtain a final scale object
                    scale = this.option('Colors').call(null, domainValues);
                } else {
                    if(dataCells.length === 1){
                        // Local scope: 
                        // Visible only!
//                        var visibleDomainData = 
//                            chart
//                            .partData(this.dataCell.dataPartValue)
//                            .flattenBy(this.role, {visible: true})
//                            ;
                        
                        var visibleDomainData;
                        if(chart._getVisibleData){ // only cartesian charts have
                            visibleDomainData = chart.root._getVisibleData(this.dataCell.dataPartValue);
                        } else {
                            visibleDomainData = chart.data.owner.where(null, {visible: true});
                        }
                        
                        var normByCateg = this.option('NormByCategory');
                        
                        var scaleOptions = {
                            type:        this.option('ScaleType'),
                            colors:      this.option('Colors')().range(), // obtain the underlying colors array
                            colorDomain: this.option('Domain'), 
                            colorMin:    this.option('Min'),
                            colorMax:    this.option('Max'),
                            colorNull:   this.option('Missing'), // TODO: already handled by the axis wrapping
                            data:        visibleDomainData,
                            colorDimension: this.role.firstDimensionName(),
                            normPerBaseCategory:normByCateg
                        };
                        
                        if(normByCateg){
                            this.scalesByCateg = pvc.color.scales(scaleOptions);
                        } else {
                            scale = pvc.color.scale(scaleOptions);
                        }
                    }
                }
            }
            
            this.setScale(scale);
            
            return this;
        },
        
        _wrapScale: function(scale){
            // Check if there is a color transform set
            // and if so, transform the color scheme
            // If the user specified the colors,
            // do not apply default color transforms...
            var applyTransf;
            if(this.scaleType === 'discrete'){
                applyTransf = this.option.isSpecified('Transform') || !this.option.isSpecified('Colors');
            } else {
                applyTransf = true;
            }
            
            if(applyTransf){
                var colorTransf = this.option('Transform');
                if(colorTransf){
                    scale = scale.transform(colorTransf);
                }
            }
            
            return this.base(scale);
        },
        
        sceneScale: function(keyArgs){
            var varName = def.get(keyArgs, 'sceneVarName') || this.role.name;
            
            return this.scale.by1(function(scene){
                return scene.vars[varName].value;
            });
        },
        
        _buildOptionId: function(){
            return this.id + "Axis";
        },
        
        _getOptionsDefinition: function(){
            return colorAxis_optionsDef;
        },
        
        _resolveByNaked: pvc.options.specify(function(optionInfo){
            // The first of the type receives options without the "Axis" suffix.
            if(!this.index){
                return this._chartOption(this.id + def.firstUpperCase(optionInfo.name));
            }
        }),
        
        _specifyV1ChartOption: function(optionInfo, asName){
            if(!this.index &&
                this.chart.compatVersion() <= 1 && 
                this._specifyChartOption(optionInfo, asName)){
                return true;
            }
        }
    });
    
    /* PRIVATE STUFF */
    function castSize(size){
        // Single size or sizeMax (a number or a string)
        // should be interpreted as meaning the orthogonal length.
        
        if(!def.object.is(size)){
            var position = this.option('Position');
            size = new pvc.Size()
                .setSize(size, {
                    singleProp: pvc.BasePanel.orthogonalLength[position]
                });
        }
        
        return size;
    }
    
    function castAlign(align){
        var position = this.option('Position');
        return pvc.parseAlign(position, align);
    }
    
    var legendData = {
        resolveDefault: function(optionInfo){
            // Naked
            if(!this.index && 
               this._specifyChartOption(optionInfo, def.firstLowerCase(optionInfo.name))){
                return true;
            }
        }
    };
    
    function getDefaultColor(optionInfo){
        var colors;
        if(this.scaleType === 'discrete'){
            if(this.index === 0){
                // Assumes default pvc scale
                colors = pvc.createColorScheme();
            } else { 
                // Use colors of axes with own colors.
                // Use a color scheme that always returns 
                // the global color scale of the role
                var me = this;
                colors = function(){ // ignore domain values
                    return me.chart._getRoleColorScale(me.role.name);
                };
            }
        } else {
            colors = ['red', 'yellow','green']
                     .map(function(name){ return pv.Color.names[name]; });
        }
        
        return colors;
    }
    
    
    /*global axis_optionsDef:true*/
    var colorAxis_optionsDef = def.create(axis_optionsDef, {
        /*
         * colors (special case)
         * colorAxisColors
         * color2AxisColors
         * color3AxisColors
         * 
         * -----
         * secondAxisColor (V1 compatibility)
         */
        Colors: {
            resolve:    '_resolveFull',
            getDefault: getDefaultColor,
            data: {
                resolveV1: function(optionInfo){
                    if(this.scaleType === 'discrete'){
                        if(this.index === 0){ 
                            this._specifyChartOption(optionInfo, 'colors');
                        } else if(this.index === 1 && this.chart._allowV1SecondAxis) {
                            this._specifyChartOption(optionInfo, 'secondAxisColor');
                        }
                    } else {
                        this._specifyChartOption(optionInfo, 'colorRange');
                    }
                    
                    return true;
                },
                resolveDefault: function(optionInfo){ // after normal resolution
                    // Handle naming exceptions
                    if(this.index === 0){ 
                       this._specifyChartOption(optionInfo, 'colors');
                    }
                }
            },
            cast: pvc.colorScheme
        },
        
        /*
         * A function that transforms the colors
         * of the color scheme:
         * pv.Color -> pv.Color
         */
        Transform: {
            resolve: '_resolveFull',
            data: {
                resolveDefault: function(optionInfo){
                    var plotList = this._plotList;
                    if(plotList.length <= 2){
                        var onlyTrendAndPlot2 = 
                            def
                            .query(plotList)
                            .all(function(plot){
                                var name = plot.name;
                                return (name === 'plot2' || name === 'trend');
                            });
                        
                        if(onlyTrendAndPlot2){
                            optionInfo.defaultValue(pvc.brighterColorTransform);
                            return true;
                        }
                    }
                }
            },
            cast: def.fun.to
        },
        
        NormByCategory: {
            resolve: function(optionInfo){
                if(!this.chart._allowColorPerCategory){
                    optionInfo.specify(false);
                    return true;
                }
                
                return this._resolveFull(optionInfo);
            },
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'normPerBaseCategory');
                    return true;
                }
            },
            cast:    Boolean,
            value:   false
        },
        
        // ------------
        // Continuous color scale
        ScaleType: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'scalingType');
                    return true;
                }
            },
            cast:    pvc.parseContinuousColorScaleType,
            value:   'linear'
        },
        
        UseAbs: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   false
        },
        
        Domain: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'colorRangeInterval');
                    return true;
                }
            },
            cast: def.array.to
        },
        
        Min: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'minColor');
                    return true;
                }
            },
            cast: pv.color
        },
        
        Max: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'maxColor');
                    return true;
                }
            },
            cast: pv.color
        },
        
        Missing: { // Null, in lower case is reserved in JS...
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    this._specifyV1ChartOption(optionInfo, 'nullColor');
                    return true;
                }
            },
            cast: pv.color,
            value: pv.color("#efc5ad")
        },
        
        // ------------
        
        /* 
         * LegendVisible 
         */
        LegendVisible: {
            resolve: '_resolveFull',
            data:    legendData,
            cast:    Boolean,
            value:   true
        },
        
        LegendClickMode: {
            resolve: '_resolveFull',
            data:    legendData,
            cast:    pvc.parseLegendClickMode,
            value:   'toggleVisible'
        },
        
        LegendDrawLine: {
            resolve: '_resolveFull',
            data:    legendData,
            cast:    Boolean,
            value:   false
        },
        
        LegendDrawMarker: {
            resolve: '_resolveFull',
            data:    legendData,
            cast:    Boolean,
            value:   true
        },
        
        LegendShape: {
            resolve: '_resolveFull',
            data:    legendData,
            cast:    pvc.parseShape
        }
    });
});var sizeAxis_optionsDef;

def.scope(function(){
    /**
     * Initializes a size axis.
     * 
     * @name pvc.visual.SizeAxis
     * 
     * @class Represents an axis that maps sizes to the values of a role.
     * 
     * @extends pvc.visual.Axis
     */
    def
    .type('pvc.visual.SizeAxis', pvc.visual.Axis)
    .init(function(chart, type, index, keyArgs){
        
        // prevent naked resolution of size axis
        keyArgs = def.set(keyArgs, 'byNaked', false);
        
        this.base(chart, type, index, keyArgs);
    })
    .add(/** @lends pvc.visual.SizeAxis# */{
        
        scaleTreatsNullAs: function(){
            return 'min';
        },
        
        scaleUsesAbs: function(){
            return this.option('UseAbs');
        },
        
        setScaleRange: function(range){
            var scale = this.scale;
            scale.min  = range.min;
            scale.max  = range.max;
            scale.size = range.max - range.min;
            
            scale.range(scale.min, scale.max);
            
            if(pvc.debug >= 4){
                pvc.log("Scale: " + pvc.stringify(def.copyOwn(scale)));
            }
            
            return this;
        },
        
        _getOptionsDefinition: function(){
            return sizeAxis_optionsDef;
        }
    });
    
    /*global axis_optionsDef:true */
    sizeAxis_optionsDef = def.create(axis_optionsDef, {
        /* sizeAxisOriginIsZero
         * Force zero to be part of the domain of the scale to make
         * the scale "proportionally" comparable.
         */
        OriginIsZero: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   false
        },
        
        FixedMin: {
            resolve: '_resolveFull',
            cast:    pvc.castNumber
        },
        
        FixedMax: {
            resolve: '_resolveFull',
            cast:    pvc.castNumber
        },
        
        UseAbs: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   false
        }
    });
    
});def.scope(function(){

    /**
     * Initializes a legend.
     * 
     * @name pvc.visual.Legend
     * 
     * @class Manages the options of a chart legend.
     * @extends pvc.visual.OptionsBase
     */
    def
    .type('pvc.visual.Legend', pvc.visual.OptionsBase)
    .init(function(chart, type, index, keyArgs){
        // prevent naked resolution of legend
        keyArgs = def.set(keyArgs, 'byNaked', false);
        
        this.base(chart, type, index, keyArgs);
    })
    .add(/** @lends Legend# */{
        _getOptionsDefinition: function(){
            return legend_optionsDef;
        }
    });
    
    /* PRIVATE STUFF */
    function castSize(size){
        // Single size or sizeMax (a number or a string)
        // should be interpreted as meaning the orthogonal length.
        
        if(!def.object.is(size)){
            var position = this.option('Position');
            size = new pvc.Size()
                .setSize(size, {
                    singleProp: pvc.BasePanel.orthogonalLength[position]
                });
        }
        
        return size;
    }
    
    function castAlign(align){
        var position = this.option('Position');
        return pvc.parseAlign(position, align);
    }
    
    /*global axis_optionsDef:true*/
    var legend_optionsDef = {
        /* legendPosition */
        Position: {
            resolve: '_resolveFull',
            cast:    pvc.parsePosition,
            value:   'bottom'
        },
        
        /* legendSize,
         * legend2Size 
         */
        Size: {
            resolve: '_resolveFull',
            cast:    castSize
        },
        
        SizeMax: {
            resolve: '_resolveFull',
            cast:    castSize
        },
        
        Align: {
            resolve: '_resolveFull',
            data: {
                resolveDefault: function(optionInfo){
                    // Default value of align depends on position
                    var position = this.option('Position');
                    var align;
                    if(position !== 'top' && position !== 'bottom'){
                        align = 'top';
                    } else if(this.chart.compatVersion() <= 1) { // centered is better
                        align = 'left';
                    }
                    
                    optionInfo.defaultValue(align);
                    return true;
                }
            },
            cast: castAlign
        },
        
        Margins:  {
            resolve: '_resolveFull',
            data: {
                resolveDefault: function(optionInfo){
                    // Default value of align depends on position
                    // Default value of margins depends on position
                    if(this.chart.compatVersion() > 1){
                        var position = this.option('Position');
                        
                        // Set default margins
                        var margins = def.set({}, pvc.BasePanel.oppositeAnchor[position], 5);
                        
                        optionInfo.defaultValue(margins);
                    }
                    
                    return true;
                }
            },
            cast: pvc.Sides.as
        },
        
        Paddings: {
            resolve: '_resolveFull',
            cast:    pvc.Sides.as,
            value:   5
        },
        
        Font: {
            resolve: '_resolveFull',
            cast:    String,
            value:   '10px sans-serif'
        }
    };
});
/**
 * Initializes a legend bullet root scene.
 * 
 * @name pvc.visual.legend.BulletRootScene
 * 
 * @extends pvc.visual.Scene
 * 
 * @constructor
 * @param {pvc.visual.Scene} [parent] The parent scene, if any.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for supported keyword arguments.
 */
def
.type('pvc.visual.legend.BulletRootScene', pvc.visual.Scene)
.init(function(parent, keyArgs){
    
    this.base(parent, keyArgs);
    
    var markerDiam = def.get(keyArgs, 'markerSize', 15);
    var itemPadding    = new pvc.Sides(def.get(keyArgs, 'itemPadding', 5))
                        .resolve(markerDiam, markerDiam);
    def.set(this.vars,
        'horizontal', def.get(keyArgs, 'horizontal', false),
        'font',       def.get(keyArgs, 'font'),
        'markerSize', markerDiam, // Diameter of bullet/marker zone
        'textMargin', def.get(keyArgs, 'textMargin', 6),  // Space between marker and text 
        'itemPadding',    itemPadding);
})
.add(/** @lends pvc.visual.legend.BulletRootScene# */{
    layout: function(layoutInfo){
        // Any size available?
        var clientSize = layoutInfo.clientSize;
        if(!(clientSize.width > 0 && clientSize.height > 0)){
            return new pvc.Size(0,0);
        }
        
        var desiredClientSize = layoutInfo.desiredClientSize;
        
        // The size of the biggest cell
        var markerDiam  = this.vars.markerSize;
        var textLeft    = markerDiam + this.vars.textMargin;
        var itemPadding = this.vars.itemPadding;
        
        // Names are for legend items when laid out in rows
        var a_width  = this.vars.horizontal ? 'width' : 'height';
        var a_height = pvc.BasePanel.oppositeLength[a_width]; // height or width
        
        var maxRowWidth = desiredClientSize[a_width];
        if(!maxRowWidth || maxRowWidth < 0){
            maxRowWidth = clientSize[a_width]; // row or col
        }
        
        var row;
        var rows = [];
        var contentSize = {width: 0, height: 0};
        
        this.childNodes.forEach(function(groupScene){
            groupScene.childNodes.forEach(layoutItem, this);
        }, this);
        
        // If there's no pending row to commit, there are no rows...
        // No items or just items with no text -> hide
        if(!row){
            return new pvc.Size(0,0);
        }
        
        commitRow(/* isLast */ true);
        
        // In logical "row" naming 
        def.set(this.vars, 
            'rows',     rows,
            'rowCount', row,
            'size',     contentSize);
        
        var isV1Compat = this.compatVersion() <= 1;
        
        // Request used width / all available width (V1)
        var w = isV1Compat ? maxRowWidth : contentSize.width;
        var h = desiredClientSize[a_height];
        if(!h || h < 0){
            h = contentSize.height;
        }
        
        // requestSize
        return def.set({},
            a_width,  Math.min(w, clientSize[a_width]),
            a_height, Math.min(h, clientSize[a_height]));
        
        function layoutItem(itemScene){
            // The names of props  of textSize and itemClientSize 
            // are to be taken literally.
            // This is because items, themselves, are always laid out horizontally...
            var textSize = itemScene.labelTextSize();
            
            var hidden = !textSize || !textSize.width || !textSize.height;
            itemScene.isHidden = hidden;
            if(hidden){
                return;
            }  
            
            // Add small margin to the end of the text eq to 0.5em
            var widthMargin = 0;// (textSize.height / 2);
            
            // not padded size
            var itemClientSize = {
                width:  textLeft + textSize.width + widthMargin,
                height: Math.max(textSize.height, markerDiam)
            };
            
            // -------------
            
            var isFirstInRow;
            if(!row){
                row = new pvc.visual.legend.BulletItemSceneRow(0);
                isFirstInRow = true;
            } else {
                isFirstInRow = !row.items.length;
            }
            
            var newRowWidth = row.size.width + itemClientSize[a_width]; // or bottom
            if(!isFirstInRow){
                newRowWidth += itemPadding[a_width]; // separate from previous item
            }
            
            // If not the first column of a row and the item does not fit
            if(!isFirstInRow && (newRowWidth > maxRowWidth)){
                commitRow(/* isLast */ false);
                
                newRowWidth = itemClientSize[a_width];
            }
            
            // Add item to row
            var rowSize = row.size;
            rowSize.width  = newRowWidth;
            rowSize.height = Math.max(rowSize.height, itemClientSize[a_height]);
            
            var rowItemIndex = row.items.length;
            row.items.push(itemScene);
            
            def.set(itemScene.vars,
                    'row', row, // In logical "row" naming
                    'rowIndex', rowItemIndex, // idem
                    'clientSize', itemClientSize);
        }
        
        function commitRow(isLast){
            var rowSize = row.size;
            contentSize.height += rowSize.height;
            if(rows.length){
                // Separate rows
                contentSize.height += itemPadding[a_height];
            }
            
            contentSize.width = Math.max(contentSize.width, rowSize.width);
            rows.push(row);
            
            // New row
            if(!isLast){
                row = new pvc.visual.legend.BulletItemSceneRow(rows.length);
            }
        }
    },
    
    defaultGroupSceneType: function(){
        var GroupType = this._bulletGroupType;
        if(!GroupType){
            GroupType = def.type(pvc.visual.legend.BulletGroupScene);
            
            // Apply legend group scene extensions
            //this.panel()._extendSceneType('group', GroupType, ['...']);
            
            this._bulletGroupType = GroupType;
        }
        
        return GroupType;
    },
    
    createGroup: function(keyArgs){
        var GroupType = this.defaultGroupSceneType();
        return new GroupType(this, keyArgs);
    }
});

def
.type('pvc.visual.legend.BulletItemSceneRow')
.init(function(index){
    this.index = index;
    this.items = [];
    this.size  = {width: 0, height: 0};
});
/**
 * Initializes a legend bullet group scene.
 * 
 * @name pvc.visual.legend.BulletGroupScene

 * @extends pvc.visual.Scene
 * 
 * @constructor
 * @param {pvc.visual.legend.BulletRootScene} parent The parent bullet root scene.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for additional keyword arguments.
 * @param {pv.visual.legend.renderer} [keyArgs.renderer] Keyword arguments.
 */
def
.type('pvc.visual.legend.BulletGroupScene', pvc.visual.Scene)
.init(function(rootScene, keyArgs){
    
    this.base(rootScene, keyArgs);
    
    this.extensionPrefix =  def.get(keyArgs, 'extensionPrefix') || 'legend';
    this._renderer = def.get(keyArgs, 'renderer');
    
    this.colorAxis = def.get(keyArgs, 'colorAxis');
    this.clickMode = def.get(keyArgs, 'clickMode');
    
    if(this.colorAxis && !this.clickMode){
        this.clickMode = this.colorAxis.option('LegendClickMode');
    }
})
.add(/** @lends pvc.visual.legend.BulletGroupScene# */{
    hasRenderer: function(){
        return this._renderer;
    },
    
    renderer: function(renderer){
        if(renderer != null){
            this._renderer = renderer;
        } else {
            renderer = this._renderer;
            if(!renderer){
                var keyArgs;
                var colorAxis = this.colorAxis;
                if(colorAxis){
                    keyArgs = {
                        drawRule:    colorAxis.option('LegendDrawLine'  ),
                        drawMarker:  colorAxis.option('LegendDrawMarker'),
                        markerShape: colorAxis.option('LegendShape')
                    };
                }
                
                renderer = new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs);
                this._renderer = renderer;
            }
        }
        
        return renderer;
    },
    
    itemSceneType: function(){
        var ItemType = this._itemSceneType;
        if(!ItemType){
            ItemType = def.type(pvc.visual.legend.BulletItemScene);
            
            // Mixin behavior depending on click mode
            var clickMode = this.clickMode;
            switch(clickMode){
                case 'toggleSelected':
                    ItemType.add(pvc.visual.legend.BulletItemSceneSelection);
                    break;
                
                case 'toggleVisible':
                    ItemType.add(pvc.visual.legend.BulletItemSceneVisibility);
                    break;
            }
            
            // Apply legend item scene extensions
            this.panel()._extendSceneType('item', ItemType, ['isOn', 'isClickable', 'click']);
            
            this._itemSceneType = ItemType;
        }
        
        return ItemType;
    },
    
    createItem: function(keyArgs){
        var ItemType = this.itemSceneType();
        return new ItemType(this, keyArgs);
    }
});
/**
 * Initializes a legend bullet item scene.
 * 
 * @name pvc.visual.legend.BulletItemScene
 * 
 * @extends pvc.visual.legend.Scene
 * 
 * @constructor
 * @param {pvc.visual.legend.BulletGroupScene} bulletGroup The parent legend bullet group scene.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for supported keyword arguments.
 */
def
.type('pvc.visual.legend.BulletItemScene', pvc.visual.Scene)
.init(function(bulletGroup, keyArgs){
    
    this.base(bulletGroup, keyArgs);
    
    var value, rawValue, label;
    if(keyArgs){
        value    = keyArgs.value;
        rawValue = keyArgs.rawValue;
        label    = keyArgs.label;
    }
    
    if(value === undefined){
        var source = this.group || this.datum;
        if(source){
            value    = source.value;
            rawValue = source.rawValue;
            label    = source.ensureLabel();
            
            // This is to catch trend lines...
            // Standard data source data parts are numbers, 
            // so this shows the non-standard data part label
            // after the item's label:
            // 'Lisbon (Linear trend)'  
            var dataPartDim = this.chart()._getDataPartDimName();
            if(dataPartDim){
                var dataPartAtom = source.atoms[dataPartDim];
                if(isNaN(+dataPartAtom.value)){
                    label += " (" + dataPartAtom.label + ")";
                }
            }
        }
    }
    
    this.vars.value = new pvc.visual.ValueLabelVar(value || null, label || "", rawValue);
})
.add(/** @lends pvc.visual.legend.BulletItemScene# */{
    /**
     * Called during legend render (full or interactive) 
     * to determine if the item is in the "on" state.
     * <p>
     * An item in the "off" state is shown with brighter struck-through text, by default.
     * </p>
     * 
     * <p>
     * The default implementation returns <c>true</c>.
     * </p>
     * 
     * @type boolean
     */
    isOn:  function(){
        return true;
    },
    
    /**
     * Called during legend render (full or interactive) 
     * to determine if the item can be clicked.
     * <p>
     * A clickable item shows a hand mouse cursor when the mouse is over it.
     * </p>
     * <p>
     * The default implementation returns <c>false</c>.
     * </p>
     * 
     * @type boolean
     */
    isClickable: function(){
        return false;
    },
    
    /**
     * Called when the user clicks the legend item.
     * <p>
     * The default implementation does nothing.
     * </p>
     */
    click: function(){
        // NOOP
    },
    
    /**
     * Measures the item label's text and returns an object
     * with 'width' and 'height' properties, in pixels.
     * <p>A nully value may be returned to indicate that there is no text.</p>
     * 
     * @type object
     */
    labelTextSize: function(){
        var valueVar = this.vars.value;
        return valueVar && pv.Text.measure(valueVar.label, this.vars.font);
    }
});
/**
 * @name pvc.visual.legend.BulletItemSceneSelection
 * @class A selection behavior mixin for the legend bullet item scene. 
 * Represents and controls the selected state of its datums.
 * 
 * @extends pvc.visual.legend.BulletItemScene
 */
def
.type('pvc.visual.legend.BulletItemSceneSelection')
.add(/** @lends pvc.visual.legend.BulletItemSceneSelection# */{
    /**
     * Returns <c>true</c> if there are no selected datums in the owner data, 
     * or if at least one non-null datum of the scene's {@link #datums} is selected.
     * @type boolean
     */
    isOn: function(){
        var owner = (this.group || this.datum).owner;
        return !owner.selectedCount() || 
               this.datums().any(function(datum){
                   return !datum.isNull && datum.isSelected; 
               });
        
        // Cannot use #isSelected() cause it includes null datums.
        //return this.isSelected();
    },
    
    /**
     * Returns the value of the chart option "selectable". 
     * @type boolean
     */
    isClickable: function(){
        return this.chart().options.selectable;
    },
    
    /**
     * Toggles the selected state of the datums present in this scene
     * and updates the chart if necessary.
     */
    click: function(){
        var datums = this.datums().array();
        if(datums.length){
            var chart = this.chart();
            chart._updatingSelections(function(){
                datums = chart._onUserSelection(datums);
                if(datums){
                    var on = def.query(datums).any(function(datum){ return datum.isSelected; });
                    pvc.data.Data.setSelected(datums, !on);
                }
            });
        }
    }
});

/**
 * @name pvc.visual.legend.BulletItemSceneVisibility
 * 
 * @class A visibility behavior mixin for a legend bullet item scene. 
 * Represents and controls the visible state of its datums.
 * 
 * @extends pvc.visual.legend.BulletItemScene
 */
def
.type('pvc.visual.legend.BulletItemSceneVisibility')
.add(/** @lends pvc.visual.legend.BulletItemSceneVisibility# */{
    /**
     * Returns <c>true</c> if at least one non-null datum of the scene's {@link #datums} is visible.
     * @type boolean
     */
    isOn: function(){
        return this.datums().any(function(datum){ 
                   return !datum.isNull && datum.isVisible; 
               });
    },
    
    /**
     * Returns <c>true</c>.
     * @type boolean
     */
    isClickable: function(){
        return true;
    },
    
    /**
     * Toggles the visible state of the datums present in this scene
     * and forces a re-render of the chart (without reloading data).
     */
    click: function(){
        if(pvc.data.Data.toggleVisible(this.datums())){
            // Re-render chart
            this.chart().render(true, true, false);
        }
    }
});

/**
 * @name pvc.visual.legend.BulletItemRenderer
 * @class Renders bullet items' bullets, i.e. marker, rule, etc.
 */
def.type('pvc.visual.legend.BulletItemRenderer');

/**
 * Creates the marks that render appropriate bullets
 * as children of a given parent bullet panel.
 * <p>
 * The dimensions of this panel, upon each render, 
 * provide bounds for drawing each bullet.
 * </p>
 * <p>
 * The properties of marks created as children of this panel will 
 * receive a corresponding {@link pvc.visual.legend.BulletItemScene} 
 * as first argument. 
 * </p>
 * 
 * @name pvc.visual.legend.BulletItemRenderer#create
 * @function
 * @param {pvc.LegendPanel} legendPanel the legend panel
 * @param {pv.Panel} pvBulletPanel the protovis panel on which bullets are rendered.
 * @param {string} extensionPrefix The extension prefix to be used to build extension keys, without underscore.
 * @param {function} [wrapper] extension wrapper function to apply to created marks.
 * 
 * @type undefined 
 */
/**
 * Initializes a default legend bullet renderer.
 * 
 * @name pvc.visual.legend.BulletItemDefaultRenderer
 * @class The default bullet renderer.
 * @extends pvc.visual.legend.BulletItemRenderer
 * 
 * @constructor
 * @param {pvc.visual.legend.BulletGroupScene} bulletGroup The parent legend bullet group scene.
 * @param {object} [keyArgs] Optional keyword arguments.
 * @param {string} [keyArgs.drawRule=false] Whether a rule should be drawn.
 * @param {string} [keyArgs.drawMarker=true] Whether a marker should be drawn.
 * When {@link keyArgs.drawRule} is false, then this argument is ignored,
 * because a marker is necessarily drawn.
 * @param {pv.Mark} [keyArgs.markerPvProto] The marker's protovis prototype mark.
 * @param {pv.Mark} [keyArgs.rulePvProto  ] The rule's protovis prototype mark.
 */
def
.type('pvc.visual.legend.BulletItemDefaultRenderer', pvc.visual.legend.BulletItemRenderer)
.init(function(keyArgs){
    this.noSelect = def.get(keyArgs, 'noSelect', false);
    this.noHover  = def.get(keyArgs, 'noHover',  false);
    
    this.drawRule = def.get(keyArgs, 'drawRule', false);
    if(this.drawRule){
        this.rulePvProto = def.get(keyArgs, 'rulePvProto');
    }
    
    this.drawMarker = !this.drawRule || def.get(keyArgs, 'drawMarker', true);
    if(this.drawMarker){
        this.markerShape = def.get(keyArgs, 'markerShape', 'square');
        this.markerPvProto = def.get(keyArgs, 'markerPvProto');
    }
})
.add(/** @lends pvc.visual.legend.BulletItemDefaultRenderer# */{
    drawRule: false,
    drawMarker: true,
    markerShape: null,
    rulePvProto: null,
    markerPvProto: null,
    
    create: function(legendPanel, pvBulletPanel, extensionPrefix, wrapper){
        var renderInfo = {};
        var drawRule = this.drawRule;
        var sceneColorProp = function(scene){ return scene.color; };
        
        if(drawRule){
            var rulePvBaseProto = new pv.Mark()
                .left (0)
                .top  (function(){ return this.parent.height() / 2; })
                .width(function(){ return this.parent.width();      })
                .lineWidth(1, pvc.extensionTag) // act as if it were a user extension
                .strokeStyle(sceneColorProp, pvc.extensionTag) // idem
                ;
            
            if(this.rulePvProto){
                rulePvBaseProto = this.rulePvProto.extend(rulePvBaseProto);
            }
            
            renderInfo.pvRule = new pvc.visual.Rule(legendPanel, pvBulletPanel, {
                    proto: rulePvBaseProto,
                    noSelect:    this.noSelect,
                    noHover:     this.noHover,
                    activeSeriesAware: false,// no guarantee that series exist in the scene
                    extensionId: extensionPrefix + "Rule",
                    wrapper:     wrapper
                })
                .pvMark;
        }
        
        if(this.drawMarker){
            var markerPvBaseProto = new pv.Mark()
                // Center the marker in the panel
                .left(function(){ 
                    return this.parent.width () / 2; 
                })
                .top (function(){ 
                    return this.parent.height() / 2; 
                })
                // If order of properties is changed, by extension, 
                // dependent properties will not work...
                .shapeSize(function(){ return this.parent.width(); }, pvc.extensionTag) // width <= height
                .lineWidth(2, pvc.extensionTag)
                .fillStyle(sceneColorProp, pvc.extensionTag)
                .strokeStyle(sceneColorProp, pvc.extensionTag)
                .shape(this.markerShape, pvc.extensionTag)
                .angle(drawRule ? 0 : Math.PI/2, pvc.extensionTag) // So that 'bar' gets drawn vertically
                .antialias( function(){
                    var cos = Math.abs(Math.cos(this.angle()));
                    if(cos !== 0 && cos !== 1){
                        switch(this.shape()){
                            case 'square':
                            case 'bar':
                                return false;
                        }
                    }
                    
                    return true;
                }, pvc.extensionTag)
                ;
            
            if(this.markerPvProto){
                markerPvBaseProto = this.markerPvProto.extend(markerPvBaseProto);
            }
            
            renderInfo.pvDot = new pvc.visual.Dot(legendPanel, pvBulletPanel, {
                    proto:        markerPvBaseProto,
                    freePosition: true,
                    activeSeriesAware: false, // no guarantee that series exist in the scene
                    noTooltip:   true,
                    noSelect:     this.noSelect,
                    noHover:      this.noHover,
                    extensionId:  extensionPrefix + "Dot",
                    wrapper:      wrapper
                })
                .pvMark;
        }
        
        return renderInfo;
    }
});
def.scope(function(){

    /**
     * Initializes a plot.
     * 
     * @name pvc.visual.Plot
     * @class Represents a plot.
     * @extends pvc.visual.OptionsBase
     */
    def
    .type('pvc.visual.Plot', pvc.visual.OptionsBase)
    .init(function(chart, keyArgs){
        // Peek plot type-index
        var typePlots = def.getPath(chart, ['plotsByType', this.type]);
        var index = typePlots ? typePlots.length : 0;
        
        // Elements of the first plot (of any type)
        // can be accessed without prefix.
        // Peek chart's plotList (globalIndex is only set afterwards in addPlot)
        var globalIndex = chart.plotList.length;
        keyArgs = def.set(keyArgs, 'byNaked', !globalIndex);
        
        this.base(chart, this.type, index, keyArgs);
        
        // fills globalIndex
        chart._addPlot(this);
        
        // -------------
        
        // Last prefix has more precedence.
        
        // The plot id is always a valid prefix (type+index)
        var prefixes = this.extensionPrefixes = [this.id];
        
        if(!this.globalIndex){
            // Elements of the first plot (of any type)
            // can be accessed without prefix
            prefixes.push('');
        }
        
        // The plot name, if any is always a valid prefix (name)
        if(this.name){
            prefixes.push(this.name);
        }
    })
    .add({
        // Override
        _getOptionsDefinition: function(){
            return pvc.visual.Plot.optionsDef;
        },
        
        // Override
        _resolveByNaked: pvc.options.specify(function(optionInfo){
            if(!this.globalIndex){
                return this._chartOption(def.firstLowerCase(optionInfo.name));
            }
        })
    });
    
    pvc.visual.Plot.optionsDef = {
        // Box model options?
            
        Orientation: {
            resolve: function(optionInfo){
                optionInfo.specify(this._chartOption('orientation') || 'vertical');
                return true;
            },
            cast: String
        },
        
        ValuesVisible: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    if(this.globalIndex === 0){
                        var show = this._chartOption('showValues');
                        if(show !== undefined){
                            optionInfo.specify(show);
                        } else {
                            show = this.type !== 'point';
                            optionInfo.defaultValue(show);
                        }
                        
                        return true;
                    }
                }
            },
            cast:  Boolean,
            value: false
        },
        
        ValuesAnchor: {
            resolve: '_resolveFull',
            cast:    pvc.parseAnchor
        },
        
        ValuesFont: {
            resolve: '_resolveFull',
            cast:    String,
            value:   '10px sans-serif'
        },
        
        // Each plot type must provide an appropriate default mask
        // depending on its scene variable names
        ValuesMask: {
            resolve: '_resolveFull',
            cast:    String,
            value:   "{value}"
        },
        
        DataPart: {
            resolve: '_resolveFixed',
            cast: String,
            value:   '0'
        },
        
        // ---------------
        
        ColorRole: {
            resolve: '_resolveFixed',
            cast:    String,
            value:   'color'
        },
        
        ColorAxis: {
            resolve: pvc.options.resolvers([
                function(optionInfo){
                    if(this.globalIndex === 0){
                        // plot0 must use color axis 0!
                        // This also ensures that the color axis 0 is created...
                        optionInfo.specify(1);
                        return true;
                    }
                },
                '_resolveFull'
            ]),
            cast:  function(value){
                value = pvc.castNumber(value);
                if(value != null){
                    value = def.between(value, 1, 10);
                } else {
                    value = 1;
                }
                
                return value;
            },
            value: 1
        }
    };
});def.scope(function(){

    /**
     * Initializes an abstract cartesian plot.
     * 
     * @name pvc.visual.CartesianPlot
     * @class Represents an abstract cartesian plot.
     * @extends pvc.visual.Plot
     */
    def
    .type('pvc.visual.CartesianPlot', pvc.visual.Plot)
    .add({
        _getOptionsDefinition: function(){
            return pvc.visual.CartesianPlot.optionsDef;
        }
    });
    
    function castTrend(trend){
        // The trend plot itself does not have trends...
        if(this.name === 'trend'){
            return null;
        }
        
        var type = this.option('TrendType');
        if(!type && trend){
            type = trend.type;
        }
        
        if(!type || type === 'none'){
            return null;
        }
        
        if(!trend){
            trend = {};
        } else {
            trend = Object.create(trend);
        }
        
        trend.type = type;
       
        var label = this.option('TrendLabel');
        if(label !== undefined){
            trend.label = label;
        }
        
        return trend;
    }
    
    pvc.visual.CartesianPlot.optionsDef = def.create(
        pvc.visual.Plot.optionsDef, {
            BaseAxis: {
                value: 1
            },
            
            BaseRole: {
                resolve: '_resolveFixed',
                cast:    String
            },
            
            OrthoAxis: {
                resolve: function(optionInfo){
                    if(this.globalIndex === 0){
                        // plot0 must use ortho axis 0!
                        // This also ensures that the ortho axis 0 is created...
                        optionInfo.specify(1);
                        return true;
                    }
                    
                    return this._resolveFull(optionInfo);
                },
                data: {
                    resolveV1: function(optionInfo){
                        if(this.name === 'plot2' &&
                            this.chart._allowV1SecondAxis &&
                            this._chartOption('secondAxisIndependentScale')){
                             optionInfo.specify(2);
                        }
                        return true;
                    }
                },
                cast: function(value){
                    value = pvc.castNumber(value);
                    if(value != null){
                        value = def.between(value, 1, 10);
                    } else {
                        value = 1;
                    }
                    
                    return value;
                },
                value: 1
            },
            
            OrthoRole: {
                resolve: pvc.options.resolvers([
                      '_resolveFixed',
                      '_resolveDefault'
                    ])
                // String or string array
            },
            
            Trend: {
                resolve: '_resolveFull',
                data: {
                    resolveDefault: function(optionInfo){
                        var type = this.option('TrendType');
                        if(type){
                            // Cast handles the rest
                            optionInfo.defaultValue({
                                type: type
                            });
                            return true;
                        }
                    }
                },
                cast: castTrend
            },
            
            TrendType: {
                resolve: '_resolveFull',
                cast:    pvc.parseTrendType
                //value:   'none'
            },
            
            TrendLabel: {
                resolve: '_resolveFull',
                cast:    String
            },
            
            NullInterpolationMode: {
                resolve: '_resolveFull',
                cast:    pvc.parseNullInterpolationMode,
                value:   'none' 
            }
        });
});def.scope(function(){

    /**
     * Initializes an abstract categorical plot.
     * 
     * @name pvc.visual.CategoricalPlot
     * @class Represents an abstract categorical plot.
     * @extends pvc.visual.CartesianPlot
     */
    def
    .type('pvc.visual.CategoricalPlot', pvc.visual.CartesianPlot)
    .add({
        _getOptionsDefinition: function(){
            return pvc.visual.CategoricalPlot.optionsDef;
        }
    });
    
    pvc.visual.CategoricalPlot.optionsDef = def.create(
        pvc.visual.CartesianPlot.optionsDef, {
        
        Stacked: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   false
        },
        
        BaseRole: {
            value: 'category'
        },
        
        OrthoRole: { // override 
            value: 'value'
        }
    });
});def.scope(function(){

    /**
     * Initializes an abstract bar plot.
     * 
     * @name pvc.visual.BarPlotAbstract
     * @class Represents an abstract bar plot.
     * @extends pvc.visual.CategoricalPlot
     */
    def
    .type('pvc.visual.BarPlotAbstract', pvc.visual.CategoricalPlot)
    .add({
        _getOptionsDefinition: function(){
            return pvc.visual.BarPlotAbstract.optionsDef;
        }
    });
    
    pvc.visual.BarPlotAbstract.optionsDef = def.create(
        pvc.visual.CategoricalPlot.optionsDef, {
        
        BarSizeRatio: { // for grouped bars
            resolve: '_resolveFull',
            cast: function(value){
                value = pvc.castNumber(value);
                if(value == null){
                    value = 1;
                } else if(value < 0.05){
                    value = 0.05;
                } else if(value > 1){
                    value = 1;
                }
                
                return value;
            },
            value: 0.9
        },
        
        BarSizeMax: {
            resolve: '_resolveFull',
            data: {
                resolveV1: function(optionInfo){
                    // default to v1 option
                    this._specifyChartOption(optionInfo, 'maxBarSize');
                    return true;
                }
            },
            cast: function(value){
                value = pvc.castNumber(value);
                if(value == null){
                    value = Infinity;
                } else if(value < 1){
                    value = 1;
                }
                
                return value;
            },
            value: 2000
        },
        
        BarStackedMargin: { // for stacked bars
            resolve: '_resolveFull',
            cast: function(value){
                value = pvc.castNumber(value);
                if(value != null && value < 0){
                    value = 0;
                }
                
                return value;
            },
            value:   0
        },
        
        OverflowMarkersVisible: {
            resolve: '_resolveFull',
            cast:    Boolean,
            value:   true
        },
        
        ValuesAnchor: { // override default value only
            value: 'center'
        }
        
        /* TODO valuesMask...  showValuePercentage
        ValuePercentage: {
            value: false
        }
        */
    });
});
/**
 * Initializes a bar plot.
 * 
 * @name pvc.visual.BarPlot
 * @class Represents a bar plot.
 * @extends pvc.visual.BarPlotAbstract
 */
def
.type('pvc.visual.BarPlot', pvc.visual.BarPlotAbstract)
.add({
    type: 'bar'
});def.scope(function(){

    /**
     * Initializes a normalized bar plot.
     * 
     * @name pvc.visual.NormalizedBarPlot
     * @class Represents a normalized bar plot.
     * @extends pvc.visual.BarPlotAbstract
     */
    def
    .type('pvc.visual.NormalizedBarPlot', pvc.visual.BarPlotAbstract)
    .add({
        type: 'bar',
        _getOptionsDefinition: function(){
            return pvc.visual.NormalizedBarPlot.optionsDef;
        }
    });
    
    pvc.visual.NormalizedBarPlot.optionsDef = def.create(
        pvc.visual.BarPlotAbstract.optionsDef, 
        {
            Stacked: {
                resolve: null, 
                value: true
            }
        });
});def.scope(function(){

    /**
     * Initializes a waterfall plot.
     * 
     * @name pvc.visual.WaterfallPlot
     * @class Represents a waterfall plot.
     * @extends pvc.visual.BarPlotAbstract
     */
    def
    .type('pvc.visual.WaterfallPlot', pvc.visual.BarPlotAbstract)
    .add({
        type: 'water',
        _getOptionsDefinition: function(){
            return pvc.visual.WaterfallPlot.optionsDef;
        }
    });
    
    pvc.visual.WaterfallPlot.optionsDef = def.create(
        pvc.visual.BarPlotAbstract.optionsDef, 
        {
            Stacked: { // override
                resolve: null, 
                value:   true
            },
            
            TotalLineLabel: {
                resolve: '_resolveFull',
                cast:    String,
                value:   "Accumulated"
            },
            
            TotalValuesVisible: { 
                resolve: '_resolveFull',
                data: {
                    // Dynamic default
                    resolveDefault: function(optionInfo){
                        optionInfo.defaultValue(this.option('ValuesVisible'));
                        return true;
                    }
                },
                cast:    Boolean
            },
            
            Direction: { // up/down
                resolve: '_resolveFull',
                cast:    pvc.parseWaterDirection,
                value:   'down'
            },
            
            AreasVisible: {
                resolve: '_resolveFull',
                cast:    Boolean,
                value:   true
            },
            
            AllCategoryLabel: {
                resolve: '_resolveFull',
                cast:    String,
                value:   "All"
            }
        });
});def.scope(function(){
    /**
     * Initializes a point plot.
     * 
     * @name pvc.visual.PointPlot
     * @class Represents a Point plot.
     * @extends pvc.visual.CategoricalPlot
     */
    def
    .type('pvc.visual.PointPlot', pvc.visual.CategoricalPlot)
    .add({
        type: 'point',
        _getOptionsDefinition: function(){
            return pvc.visual.PointPlot.optionsDef;
        }
    });
    
    function visibleData(type, dv){
        return {
            resolveV1: function(optionInfo){
                if(this.globalIndex === 0){
                    if(!this._specifyChartOption(optionInfo, 'show' + type)){
                        optionInfo.defaultValue(dv);
                    }
                    return true;
                }
            }
        };
    }
    
    pvc.visual.PointPlot.optionsDef = def.create(
        pvc.visual.CategoricalPlot.optionsDef, {
            DotsVisible: {
                resolve: '_resolveFull',
                data:    visibleData('Dots', true),
                cast:    Boolean,
                value:   false
            },
            
            LinesVisible: {
                resolve: '_resolveFull',
                data:    visibleData('Lines', true),
                cast:    Boolean,
                value:   false
            },
            
            AreasVisible: {
                resolve: '_resolveFull',
                data:    visibleData('Areas', false),
                cast:    Boolean,
                value:   false
            },
            
            ValuesAnchor: { // override
                value: 'right'
            }
        });
});def.scope(function(){

    /**
     * Initializes an abstract metric XY plot.
     * 
     * @name pvc.visual.MetricXYPlot
     * @class Represents an abstract metric XY plot.
     * @extends pvc.visual.CartesianPlot
     */
    def
    .type('pvc.visual.MetricXYPlot', pvc.visual.CartesianPlot)
    .add({
        _getOptionsDefinition: function(){
            return pvc.visual.MetricXYPlot.optionsDef;
        }
    });
    
    pvc.visual.MetricXYPlot.optionsDef = def.create(
        pvc.visual.CartesianPlot.optionsDef, {
            BaseRole: { // override
                value:   'x'
            },
            
            OrthoAxis: { // override -> value 1
                resolve: null
            },
            
            OrthoRole: {
                value: 'y'
            }
        });
});def.scope(function(){

    /**
     * Initializes a metric XY plot.
     * 
     * @name pvc.visual.MetricPointPlot
     * @class Represents a metric point plot.
     * @extends pvc.visual.MetricXYPlot
     */
    def
    .type('pvc.visual.MetricPointPlot', pvc.visual.MetricXYPlot)
    .add({
        type: 'scatter',
        _getOptionsDefinition: function(){
            return pvc.visual.MetricPointPlot.optionsDef;
        }
    });
    
    function visibleData(type){
        return {
            resolveV1: function(optionInfo){
                this._specifyChartOption(optionInfo, 'show' + type);
                return true;
            }
        };
    }
    
    pvc.visual.MetricPointPlot.optionsDef = def.create(
        pvc.visual.MetricXYPlot.optionsDef, {
            SizeRole: {
                resolve: '_resolveFixed',
                value: 'size'
            },
            
            SizeAxis: {
                resolve: '_resolveFixed',
                value: 1
            },
            
            Shape: {
                resolve: '_resolveFull',
                cast:    pvc.parseShape,
                value:   'circle'
            },
            
            DotsVisible: {
                resolve: '_resolveFull',
                data:    visibleData('Dots'),
                cast:    Boolean,
                value:   false
            },
            
            LinesVisible: {
                resolve: '_resolveFull',
                data:    visibleData('Lines'),
                cast:    Boolean,
                value:   false
            },
            
            ValuesAnchor: { // override
                value: 'right'
            }
        });
});def.scope(function(){

    /**
     * Initializes a pie plot.
     * 
     * @name pvc.visual.PiePlot
     * @class Represents a pie plot.
     * @extends pvc.visual.Plot
     */
    def
    .type('pvc.visual.PiePlot', pvc.visual.Plot)
    .add({
        type: 'pie',
        
        _getOptionsDefinition: function(){
            return pvc.visual.PiePlot.optionsDef;
        }
    });
    
    pvc.visual.PiePlot.optionsDef = def.create(
        pvc.visual.Plot.optionsDef, {
            ActiveSliceRadius: {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   new pvc.PercentValue(0.05)
            },
            
            ExplodedSliceRadius: {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   0
            },
            
            ExplodedSliceIndex:  {
                resolve: '_resolveFull',
                cast:    pvc.castNumber,
                value:   null // all exploded when radius > 0
            },
            
            ValuesAnchor: { // override
                cast:  pvc.parseAnchorWedge,
                value: 'outer'
            },
            
            ValuesVisible: { // override
                value: true
            },
            
            ValuesLabelStyle: {
                resolve: function(optionInfo){
                    var isV1Compat = this.chart.compatVersion() <= 1;
                    if(isV1Compat){
                        optionInfo.specify('inside');
                        return true;
                    }
                    
                    return this._resolveFull(optionInfo);
                },
                cast: function(value) {
                    switch(value){
                        case 'inside':
                        case 'linked': return value;
                    }
                    
                    if(pvc.debug >= 2){
                        pvc.log("[Warning] Invalid 'ValuesLabelStyle' value: '" + value + "'.");
                    }
                    
                    return 'linked';
                },
                value: 'linked'
            },
            
            // Depends on being linked or not
            // Examples:
            // "{value} ({value.percent}) {category}"
            // "{value}"
            // "{value} ({value.percent})"
            // "{#productId}" // Atom name
            ValuesMask: { // OVERRIDE
                resolve: '_resolveFull',
                data: {
                    resolveDefault: function(optionInfo){
                        optionInfo.defaultValue(
                                this.option('ValuesLabelStyle') === 'linked' ? 
                                "{value} ({value.percent})" : 
                                "{value}");
                        return true;
                    }
                }
            },
            
            /* Linked Label Style
             *                                         
             *     (| elbowX)                         (| anchorX)
             *      +----------------------------------+          (<-- baseY)
             *      |                                    \
             *      |   (link outset)                      \ (targetX,Y)
             *      |                                        +----+ label
             *    -----  <-- current outer radius      |<-------->|<------------>            
             *      |   (link inset)                     (margin)   (label size)
             *      
             */
            
            /**
             * Percentage of the client radius that the 
             * link is inset in a slice.
             */
            LinkInsetRadius:  {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   new pvc.PercentValue(0.05)
            },
            
            /**
             * Percentage of the client radius that the 
             * link extends outwards from the slice, 
             * until it reaches the link "elbow".
             */
            LinkOutsetRadius: {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   new pvc.PercentValue(0.025)
            },
            
            /**
             * Percentage of the client width that separates 
             * a link label from the link's anchor point.
             * <p>
             * Determines the width of the link segment that 
             * connects the "anchor" point with the "target" point.
             * Includes the space for the small handle at the end.
             * </p>
             */
            LinkMargin: {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   new pvc.PercentValue(0.025)
            },
            
            /**
             * Link handle width, in em units.
             */
            LinkHandleWidth: {
                resolve: '_resolveFull',
                cast:    pvc.castNumber,
                value:   0.5
            },
            
            /**
             * Percentage of the client width that is reserved 
             * for labels on each of the sides.
             */
            LinkLabelSize: {
                resolve: '_resolveFull',
                cast:    pvc.PercentValue.parse,
                value:   new pvc.PercentValue(0.15)
            },
            
            /**
             * Minimum vertical space that separates consecutive link labels, 
             * in em units.
             */
            LinkLabelSpacingMin: {
                resolve: '_resolveFull',
                cast:    pvc.castNumber,
                value:   0.5
            }
        });
});def.scope(function(){

    /**
     * Initializes a heat grid plot.
     * 
     * @name pvc.visual.HeatGridPlot
     * @class Represents a heat grid plot.
     * @extends pvc.visual.CategoricalPlot
     */
    def
    .type('pvc.visual.HeatGridPlot', pvc.visual.CategoricalPlot)
    .add({
        type: 'heatGrid',
        _getOptionsDefinition: function(){
            return pvc.visual.HeatGridPlot.optionsDef;
        }
    });
    
    pvc.visual.HeatGridPlot.optionsDef = def.create(
        pvc.visual.CategoricalPlot.optionsDef, 
        {
            SizeRole: {
                value: 'size'
            },
            
            SizeAxis: {
                value: 1
            },
            
            UseShapes: {
                resolve: '_resolveFull',
                cast:    Boolean,
                value:   false
            },
            
            Shape: {
                resolve: '_resolveFull',
                cast:    pvc.parseShape,
                value:   'square'
            },
            
            NullShape: {
                resolve: '_resolveFull',
                cast:    pvc.parseShape,
                value:   'cross'
            },
            
            ValuesVisible: { // override
                value: true
            },
            
            OrthoRole: { // override
                value: 'series'
            },
            
            OrthoAxis: { // override
                resolve: null
            },
            
            // Not supported
            NullInterpolationMode: {
                resolve: null,
                value: 'none'
            },
            
            // Not supported
            Stacked: { // override
                resolve: null, 
                value: false
            }
        });
});def.scope(function(){

    /**
     * Initializes a box plot.
     * 
     * @name pvc.visual.BoxPlot
     * @class Represents a box plot.
     * @extends pvc.visual.CategoricalPlot
     */
    def
    .type('pvc.visual.BoxPlot', pvc.visual.CategoricalPlot)
    .add({
        type: 'box',
        
        _getOptionsDefinition: function(){
            return pvc.visual.BoxPlot.optionsDef;
        }
    });
    
    pvc.visual.BoxPlot.optionsDef = def.create(
        pvc.visual.CategoricalPlot.optionsDef, 
        {
            // NO Values Label!
            
            Stacked: {
                resolve: null,
                value:   false
            },
            
            OrthoRole: {
                value:   ['median', 'lowerQuartil', 'upperQuartil', 'minimum', 'maximum'] // content of pvc.BoxplotChart.measureRolesNames
            },
            
            BoxSizeRatio: {
                resolve: '_resolveFull',
                cast: function(value){
                    value = pvc.castNumber(value);
                    if(value == null){
                        value = 1;
                    } else if(value < 0.05){
                        value = 0.05;
                    } else if(value > 1){
                        value = 1;
                    }
                    
                    return value;
                },
                value: 1/3
            },
            
            BoxSizeMax: {
                resolve: '_resolveFull',
                data: {
                    resolveV1: function(optionInfo){
                        // default to v1 option
                        this._specifyChartOption(optionInfo, 'maxBoxSize');
                        return true;
                    }
                },
                cast: function(value){
                    value = pvc.castNumber(value);
                    if(value == null){
                        value = Infinity;
                    } else if(value < 1){
                        value = 1;
                    }
                    
                    return value;
                },
                value: Infinity
            }
        });
});/**
 * Initializes a bullet plot.
 * 
 * @name pvc.visual.BulletPlot
 * @class Represents a bullet plot.
 * @extends pvc.visual.Plot
 */
def
.type('pvc.visual.BulletPlot', pvc.visual.Plot)
.add({
    type: 'bullet',
    
    _getOptionsDefinition: function(){
        return pvc.visual.BulletPlot.optionsDef;
    }
});

pvc.visual.BulletPlot.optionsDef = def.create(
    pvc.visual.Plot.optionsDef, {
        ValuesVisible: { // override
            value: true
        },
        
        ColorRole: {
            value: null
        }
    });def
.type('pvc.Abstract')
.add({
    invisibleLineWidth: 0.001,
    defaultLineWidth:   1.5,
    
    _logInstanceId: null,
    
    _getLogInstanceId: function(){
        return this._logInstanceId || 
               (this._logInstanceId = this._processLogInstanceId(this._createLogInstanceId()));
    },
    
    _createLogInstanceId: function(){
        return '' + this.constructor;
    },
    
    _processLogInstanceId: function(logInstanceId){
        var L = 30;
        var s = logInstanceId.substr(0, L);
        if(s.length < L){
            s += def.array.create(L - s.length, ' ').join('');
        }
        
        return "[" + s + "]";
    },
    
    _log: function(m){
        if (pvc.debug && typeof console !== "undefined"){
            /*global console:true*/
            console.log(
               this._getLogInstanceId() + ": " +  
              (typeof m === 'string' ? m : pvc.stringify(m)));
        }
    }
});
/**
 * The main chart component
 */
def
.type('pvc.BaseChart', pvc.Abstract)
.init(function(options) {
    var parent = this.parent = def.get(options, 'parent') || null;
    
    this._initialOptions = options;
    
    /* DEBUG options */
    if(pvc.debug >= 3 && !parent && options){
        try {
            this._log("OPTIONS:\n" + pvc.logSeparator + "\n" + pvc.stringify(options, {ownOnly: false, funs: true}));
        } catch(ex) {
            /* SWALLOW usually a circular JSON structure */
        }
    }
    
    if(parent) {
        // options != null
        this.root = parent.root;
        this.smallColIndex = options.smallColIndex;
        this.smallRowIndex = options.smallRowIndex;
        
        this._tooltipEnabled = parent._tooltipEnabled;
        this._tooltipOptions = parent._tooltipOptions;
        
        parent._addChild(this);
    } else {
        this.root  = this;
    }

    this._constructData(options);
    this._constructVisualRoles(options);
    
    this.options = def.mixin({}, this.defaults, options);
})
.add({
    /**
     * Indicates if the chart has been disposed.
     */
    _disposed: false,
    
    /**
     * The chart's parent chart.
     * 
     * <p>
     * The root chart has null as the value of its parent property.
     * </p>
     * 
     * @type pvc.BaseChart
     */
    parent: null,
    
    /**
     * The chart's child charts.
     * 
     * @type pvc.BaseChart[]
     */
    children: null,
    
    /**
     * The chart's root chart.
     * 
     * <p>
     * The root chart has itself as the value of the root property.
     * </p>
     * 
     * @type pvc.BaseChart
     */
    root: null,

    /**
     * Indicates if the chart has been pre-rendered.
     * <p>
     * This field is set to <tt>false</tt>
     * at the beginning of the {@link #_preRender} method
     * and set to <tt>true</tt> at the end.
     * </p>
     * <p>
     * When a chart is re-rendered it can, 
     * optionally, also repeat the pre-render phase. 
     * </p>
     * 
     * @type boolean
     */
    isPreRendered: false,

    /**
     * The version value of the current/last creation.
     * 
     * <p>
     * This value is changed on each pre-render of the chart.
     * It can be useful to invalidate cached information that 
     * is only valid for each creation.
     * </p>
     * <p>
     * Version values can be compared using the identity operator <tt>===</tt>.
     * </p>
     * 
     * @type any
     */
    _createVersion: 0,
    
    /**
     * A callback function that is called 
     * when the protovis' panel render is about to start.
     * 
     * <p>
     * Note that this is <i>after</i> the pre-render phase.
     * </p>
     * 
     * <p>
     * The callback is called with no arguments, 
     * but having the chart instance as its context (<tt>this</tt> value). 
     * </p>
     * 
     * @function
     */
    renderCallback: undefined,

    /**
     * Contains the number of pages that a multi-chart contains
     * when rendered with the previous render options.
     * <p>
     * This property is updated after a render of a chart
     * where the visual role "multiChart" is assigned and
     * the option "multiChartPageIndex" has been specified. 
     * </p>
     * 
     * @type number|null
     */
    multiChartPageCount: null,
    
    /**
     * Contains the currently rendered multi-chart page index, 
     * relative to the previous render options.
     * <p>
     * This property is updated after a render of a chart
     * where the visual role "multiChart" is assigned and
     * the <i>option</i> "multiChartPageIndex" has been specified. 
     * </p>
     * 
     * @type number|null
     */
    multiChartPageIndex: null,
    
    /**
     * The options object specified by the user,
     * before any processing.
     */
    _initialOptions: null,
    
    left: 0,
    top:  0,
    
    width: null,
    height: null,
    margins:  null,
    paddings: null,
    
    _allowV1SecondAxis: false, 
        
    //------------------
    compatVersion: function(options){
        return (options || this.options).compatVersion;
    },
    
    _createLogInstanceId: function(){
        return "" + 
            this.constructor + this._createLogChildSuffix();
    },
    
    _createLogChildSuffix: function(){
        return this.parent ? 
               (" (" + (this.smallRowIndex + 1) + "," + 
                       (this.smallColIndex + 1) + ")") : 
               "";
    },
    
    _addChild: function(childChart){
        /*jshint expr:true */
        (childChart.parent === this) || def.assert("Not a child of this chart.");
        
        this.children.push(childChart);
    },
    
    /**
     * Building the visualization is made in 2 stages:
     * First, the {@link #_preRender} method prepares and builds 
     * every object that will be used.
     * 
     * Later the {@link #render} method effectively renders.
     */
    _preRender: function(keyArgs) {
        this._preRenderPhase1(keyArgs);
        this._preRenderPhase2(keyArgs);
    },
    
    _preRenderPhase1: function(keyArgs) {
        var options = this.options;
        
        /* Increment pre-render version to allow for cache invalidation  */
        this._createVersion++;
        
        this.isPreRendered = false;
        
        if(pvc.debug >= 3){
            this._log("Prerendering");
        }
        
        this.children = [];
        
        if (!this.parent) {
            // Now's as good a time as any to completely clear out all
            //  tipsy tooltips
            pvc.removeTipsyLegends();
        }
        
        /* Options may be changed between renders */
        this._processOptions();
        
        /* Any data exists or throws
         * (must be done AFTER processing options
         *  because of width, height properties and noData extension point...) 
         */
        this._checkNoDataI();
        
        /* Initialize root visual roles */
        if(!this.parent && this._createVersion === 1) {
            this._initVisualRoles();
            
            this._bindVisualRolesPreI();
            
            this._complexTypeProj = this._createComplexTypeProject();
            
            this._bindVisualRolesPreII();
        }
        
        /* Initialize the data (and _bindVisualRolesPost) */
        this._initData(keyArgs);

        /* When data is excluded, there may be no data after all */
        this._checkNoDataII();
        
        var hasMultiRole = this._isRoleAssigned('multiChart');
        
        /* Initialize plots */
        this._initPlots(hasMultiRole);
        
        /* Initialize axes */
        this._initAxes(hasMultiRole);
        this._bindAxes(hasMultiRole);
        
        /* Trends and Interpolation */
        if(this.parent || !hasMultiRole){
            // Interpolated data affects generated trends
            this._interpolate(hasMultiRole);
            
            this._generateTrends(hasMultiRole);
        }
        
        /* Set axes scales */
        this._setAxesScales(hasMultiRole);
    },
    
    _preRenderPhase2: function(keyArgs){
        var hasMultiRole = this._isRoleAssigned('multiChart');
        
        /* Initialize chart panels */
        this._initChartPanels(hasMultiRole);
        
        this.isPreRendered = true;
    },

    // --------------
    
    _setSmallLayout: function(keyArgs){
        if(keyArgs){
            var basePanel = this.basePanel;
            
            if(this._setProp('left', keyArgs) | this._setProp('top', keyArgs)){
                if(basePanel) {
                    def.set(
                       basePanel.position,
                       'left', this.left, 
                       'top',  this.top);
                }
            }
            
            if(this._setProp('width', keyArgs) | this._setProp('height', keyArgs)){
                if(basePanel){
                    basePanel.size = new pvc.Size (this.width, this.height);
                }
            }
            
            if(this._setProp('margins', keyArgs) && basePanel){
                basePanel.margins = new pvc.Sides(this.margins);
            }
            
            if(this._setProp('paddings', keyArgs) && basePanel){
                basePanel.paddings = new pvc.Sides(this.paddings);
            }
        }
    },
    
    _setProp: function(p, keyArgs){
        var v = keyArgs[p];
        if(v != null){
            this[p] = v;
            return true;
        }
    },
    
    // --------------
    
    /**
     * Processes options after user options and defaults have been merged.
     * Applies restrictions,
     * performs validations and
     * options values implications.
     */
    _processOptions: function(){
        
        var options = this.options;
        if(!this.parent){
            this.width    = options.width; 
            this.height   = options.height;
            this.margins  = options.margins;
            this.paddings = options.paddings;
        }
        
        if(this.compatVersion() <= 1){
            options.plot2 = this._allowV1SecondAxis && !!options.secondAxis;
        }
        
        this._processOptionsCore(options);
        
        this._processExtensionPoints();
        
        return options;
    },

    /**
     * Processes options after user options and default options have been merged.
     * Override to apply restrictions, perform validation or
     * options values implications.
     * When overriden, the base implementation should be called.
     * The implementation must be idempotent -
     * its successive application should yield the same results.
     * @virtual
     */
    _processOptionsCore: function(options){
        // Disable animation if environment doesn't support it
        if(!this.parent){
            if (!$.support.svg || pv.renderer() === 'batik') {
                options.animate = false;
            }
            
            this._processTooltipOptions(options);
        }
    },
    
    _tooltipDefaults: {
        gravity:     's',
        delayIn:      200,
        delayOut:     80, // smoother moving between marks with tooltips, possibly slightly separated
        offset:       2,
        opacity:      0.9,
        html:         true,
        fade:         true,
        useCorners:   false,
        arrowVisible: true,
        followMouse:  false,
        format:       undefined
    },
    
    _processTooltipOptions: function(options){
        var isV1Compat = this.compatVersion() <= 1;
        
        var tipOptions = options.tooltip;
        var tipEnabled = options.tooltipEnabled;
        if(tipEnabled == null){
            if(tipOptions){
                tipEnabled = tipOptions.enabled;
            }
            
            if(tipEnabled == null){
                if(isV1Compat){
                    tipEnabled = options.showTooltips;
                }
                
                if(tipEnabled == null){
                    tipEnabled = true;
                }
            }
        }
        
        if(tipEnabled){
            if(!tipOptions){
                tipOptions = {};
            }
            
            if(isV1Compat){
                this._importV1TooltipOptions(tipOptions, options);
            }
            
            def.eachOwn(this._tooltipDefaults, function(dv, p){
                var value = options['tooltip' + def.firstUpperCase(p)];
                if(value !== undefined){
                    tipOptions[p] = value;
                } else if(tipOptions[p] === undefined){
                    tipOptions[p] = dv;
                }
            });
        } else {
            tipOptions = {};
        }
        
        this._tooltipEnabled = tipEnabled;
        this._tooltipOptions = tipOptions;
    },
    
    _importV1TooltipOptions: function(tipOptions, options){
        var v1TipOptions = options.tipsySettings;
        if(v1TipOptions){
            this.extend(v1TipOptions, "tooltip");
            
            for(var p in v1TipOptions){
                if(tipOptions[p] === undefined){
                    tipOptions[p] = v1TipOptions[p];
                }
            }
            
            // Force V1 html default
            if(tipOptions.html == null){
                tipOptions.html = false;
            }
        }
    },
    
    // --------------
    
    /**
     * Render the visualization.
     * If not pre-rendered, do it now.
     */
    render: function(bypassAnimation, recreate, reloadData){
        this.useTextMeasureCache(function(){
            try{
                if (!this.isPreRendered || recreate) {
                    this._preRender({reloadData: reloadData});
                } else if(!this.parent && this.isPreRendered) {
                    pvc.removeTipsyLegends();
                }
    
                this.basePanel.render({
                    bypassAnimation: bypassAnimation, 
                    recreate: recreate
                 });
                
            } catch (e) {
                /*global NoDataException:true*/
                if (e instanceof NoDataException) {
                    if(pvc.debug > 1){
                        this._log("No data found.");
                    }
    
                    this._addErrorPanelMessage("No data found", true);
                } else {
                    // We don't know how to handle this
                    pvc.logError(e.message);
                    
                    if(pvc.debug > 0){
                        this._addErrorPanelMessage("Error: " + e.message, false);
                    }
                    //throw e;
                }
            }
        });
        
        return this;
    },

    _addErrorPanelMessage: function(text, isNoData){
        var options = this.options,
            pvPanel = new pv.Panel()
                        .canvas(options.canvas)
                        .width(this.width)
                        .height(this.height),
            pvMsg = pvPanel.anchor("center").add(pv.Label)
                        .text(text);

        if(isNoData){
            this.extend(pvMsg, "noDataMessage");
        }
        
        pvPanel.render();
    },
    
    useTextMeasureCache: function(fun, ctx){
        var root = this.root;
        var textMeasureCache = root._textMeasureCache || 
                               (root._textMeasureCache = pv.Text.createCache());
        
        return pv.Text.usingCache(textMeasureCache, fun, ctx || this);
    },
    
    /**
     * Animation
     */
    animate: function(start, end) {
        return this.basePanel.animate(start, end);
    },
    
    /**
     * Indicates if the chart is currently 
     * rendering the animation start phase.
     * <p>
     * Prefer using this function instead of {@link #animate} 
     * whenever its <tt>start</tt> or <tt>end</tt> arguments
     * involve a non-trivial calculation. 
     * </p>
     * 
     * @type boolean
     */
    isAnimatingStart: function() {
        return this.basePanel.isAnimatingStart();
    },
    
    isOrientationVertical: function(orientation) {
        return (orientation || this.options.orientation) === pvc.orientation.vertical;
    },

    isOrientationHorizontal: function(orientation) {
        return (orientation || this.options.orientation) === pvc.orientation.horizontal;
    },
    
    /**
     * Disposes the chart, any of its panels and child charts.
     */
    dispose: function(){
        if(!this._disposed){
            
            // TODO: 
            
            this._disposed = true;
        }
    },
    
    defaults: {
//        canvas: null,

        width:  400,
        height: 300,

//      margins:  undefined,
//      paddings: undefined,
//      contentMargins:  undefined,
//      contentPaddings: undefined,
//      leafContentOverflow: 'auto',
//      multiChartMax: undefined,
//      multiChartColumnsMax: undefined,
//      multiChartSingleRowFillsHeight: undefined,
//      multiChartSingleColFillsHeight: undefined,
        
//      smallWidth:       undefined,
//      smallHeight:      undefined,
//      smallAspectRatio: undefined,
//      smallMargins:     undefined,
//      smallPaddings:    undefined,
        
//      smallContentMargins:  undefined,
//      smallContentPaddings: undefined,
//      smallTitlePosition: undefined,
//      smallTitleAlign:    undefined,
//      smallTitleAlignTo:  undefined,
//      smallTitleOffset:   undefined,
//      smallTitleKeepInBounds: undefined,
//      smallTitleSize:     undefined,
//      smallTitleSizeMax:  undefined,
//      smallTitleMargins:  undefined,
//      smallTitlePaddings: undefined,
//      smallTitleFont:     undefined,
        
        orientation: 'vertical',
        
//        extensionPoints:   undefined,
//        
//        visualRoles:       undefined,
//        dimensions:        undefined,
//        dimensionGroups:   undefined,
//        calculations:      undefined,
//        readers:           undefined,
        
        ignoreNulls:       true, // whether to ignore or keep "null"-measure datums upon loading
        crosstabMode:      true,
//        multiChartIndexes: undefined,
        isMultiValued:     false,
        seriesInRows:      false,
        groupedLabelSep:   undefined,
//        measuresIndexes:   undefined,
//        dataOptions:       undefined,
//        dataSeparator
//        dataMeasuresInColumns
//        dataCategoriesCount
        
//        timeSeries:        undefined,
//        timeSeriesFormat:  undefined,

        animate: true,

//        title:         null,
        
        titlePosition: "top", // options: bottom || left || right
        titleAlign:    "center", // left / right / center
//        titleAlignTo:  undefined,
//        titleOffset:   undefined,
//        titleKeepInBounds: undefined,
//        titleSize:     undefined,
//        titleSizeMax:  undefined,
//        titleMargins:  undefined,
//        titlePaddings: undefined,
//        titleFont:     undefined,
        
        legend:           false, // Show Legends
        legendPosition:   "bottom",
//        legendFont:       undefined,
//        legendSize:       undefined,
//        legendSizeMax:    undefined,
//        legendAlign:      undefined,
//        legendAlignTo:    undefined,
//        legendOffset:     undefined,
//        legendKeepInBounds:   undefined,
//        legendMargins:    undefined,
//        legendPaddings:   undefined,
//        legendTextMargin: undefined,
//        legendItemPadding:    undefined, // ATTENTION: this is different from legendPaddings
//        legendMarkerSize: undefined,
        
//        colors: null,

        v1StyleTooltipFormat: function(s, c, v, datum) {
            return s + ", " + c + ":  " + this.chart.options.valueFormat(v) +
                   (datum && datum.percent ? ( " (" + datum.percent.label + ")") : "");
        },
        
        valueFormat: def.scope(function(){
            var pvFormat = pv.Format.number().fractionDigits(0, 2);
            
            return function(d) {
                return pvFormat.format(d);
                // pv.Format.number().fractionDigits(0, 10).parse(d));
            };
        }),
        
        /* For numeric values in percentage */
        percentValueFormat: def.scope(function(){
            var pvFormat = pv.Format.number().fractionDigits(0, 1);
            
            return function(d){
                return pvFormat.format(d * 100) + "%";
            };
        }),
        
        // Content/Plot area clicking
        clickable:  false,
//        clickAction: null,
//        doubleClickAction: null,
        doubleClickMaxDelay: 300, //ms
//      
        hoverable:  false,
        selectable: false,
        
//        selectionChangedAction: null,
//        userSelectionAction: null, 
            
        // Use CTRL key to make fine-grained selections
        ctrlSelectMode: true,
        clearSelectionMode: 'emptySpaceClick', // or null <=> 'manual' (i.e., by code)
        
//        renderCallback: undefined,

        compatVersion: Infinity // numeric, 1 currently recognized
    }
});


pvc.BaseChart
.add({
    /**
     * A map of {@link pvc.visual.Role} by name.
     * 
     * @type object
     */
    _visualRoles: null,
    _visualRoleList: null,
    
    _serRole: null,
    _dataPartRole: null,
    
    /**
     * An array of the {@link pvc.visual.Role} that are measures.
     * 
     * @type pvc.visual.Role[]
     */
    _measureVisualRoles: null,
    
    _constructVisualRoles: function(options) {
        var parent = this.parent;
        if(parent) {
            this._visualRoles = parent._visualRoles;
            this._visualRoleList = parent._visualRoleList;
            this._measureVisualRoles = parent._measureVisualRoles;
            
            if(parent._multiChartRole) {
                this._multiChartRole = parent._multiChartRole;
            }
            
            if(parent._serRole) {
                this._serRole = parent._serRole;
            }
            
            if(parent._colorRole) {
                this._colorRole = parent._colorRole;
            }

            if(parent._dataPartRole) {
                this._dataPartRole = parent._dataPartRole;
            }
        } else {
            this._visualRoles = {};
            this._visualRoleList = [];
            this._measureVisualRoles = [];
        }
    },

    _hasDataPartRole: function(){
        return false;
    },

    _getSeriesRoleSpec: function(){
        return null;
    },
    
    _getColorRoleSpec: function(){
        return null;
    },
    
    _addVisualRole: function(name, keyArgs){
        keyArgs = def.set(keyArgs, 'index', this._visualRoleList.length);
        
        var visualRole = new pvc.visual.Role(name, keyArgs);
        
        this._visualRoleList.push(visualRole);
        this._visualRoles[name] = visualRole;
        if(visualRole.isMeasure){
            this._measureVisualRoles.push(visualRole);
        }
        return visualRole;
    },
    
    /**
     * Initializes each chart's specific roles.
     * @virtual
     */
    _initVisualRoles: function(){
        this._multiChartRole = this._addVisualRole(
            'multiChart', 
            {
                defaultDimension: 'multiChart*', 
                requireIsDiscrete: true
            });

        if(this._hasDataPartRole()){
            this._dataPartRole = this._addVisualRole(
                'dataPart', 
                {
                    defaultDimension: 'dataPart',
                    requireSingleDimension: true,
                    requireIsDiscrete: true,
                    dimensionDefaults: {
                        isHidden: true,
                        comparer: def.compare
                    }
                });
        }

        var serRoleSpec = this._getSeriesRoleSpec();
        if(serRoleSpec){
            this._serRole = this._addVisualRole('series', serRoleSpec);
        }
        
        var colorRoleSpec = this._getColorRoleSpec();
        if(colorRoleSpec){
            this._colorRole = this._addVisualRole('color', colorRoleSpec);
        }
    },

    /**
     * Binds visual roles to grouping specifications
     * that have not yet been bound to and validated against a complex type.
     *
     * This allows inferring proper defaults to
     * dimensions bound to roles, 
     * by taking them from the roles requirements.
     */
    _bindVisualRolesPreI: function(){
        // Clear reversed status of visual roles
        def.eachOwn(this._visualRoles, function(role){
            role.setIsReversed(false);
        });
        
        var sourcedRoles = [];
        
        // Process the visual roles with options
        // It is important to process them in visual role definition order
        // cause the processing that is done generally 
        // depends on the processing order;
        // A chart definition must behave the same 
        // in every environment, independently of the order in which
        // object properties are enumerated.
        var options = this.options;
        var roleOptions = options.visualRoles;
        
        // Accept visual roles directly in the options
        // as <roleName>Role: 
        this._visualRoleList.forEach(function(visualRole){
            var name = visualRole.name;
            var roleSpec = options[name + 'Role'];
            if(roleSpec !== undefined){
                if(!roleOptions){
                    roleOptions = options.visualRoles = {};
                }
                
                if(roleOptions[name] === undefined){
                    roleOptions[name] = roleSpec;
                }
            }
        });
        
        var dimsBoundToSingleRole;
        if(roleOptions){
            dimsBoundToSingleRole = {};
            
            var rolesWithOptions = 
                def
                .query(def.keys(roleOptions))
                .select(function(name){
                    return this._visualRoles[name] ||
                           def.fail.operationInvalid("Role '{0}' is not supported by the chart type.", [name]);
                }, this)
                .array();
            
            rolesWithOptions.sort(function(a, b){ return a.index - b.index; });
                
            /* Process options.visualRoles */
            rolesWithOptions.forEach(function(visualRole){
                var name     = visualRole.name;
                var roleSpec = roleOptions[name];
                
                // Process the visual role specification
                // * a string with the grouping dimensions, or
                // * {dimensions: "product", isReversed:true, from: "series" }
                var groupingSpec, sourceRoleName;
                if(def.object.is(roleSpec)){
                    if(def.nullyTo(roleSpec.isReversed, false)){
                        visualRole.setIsReversed(true);
                    }
                    
                    sourceRoleName = roleSpec.from;
                    if(sourceRoleName && (sourceRoleName !== name)){
                        var sourceRole = this._visualRoles[sourceRoleName] ||
                            def.fail.operationInvalid("Source role '{0}' is not supported by the chart type.", [sourceRoleName]);
                        
                        visualRole.setSourceRole(sourceRole);
                        sourcedRoles.push(visualRole);
                    } else {
                        groupingSpec = roleSpec.dimensions;
                    }
                } else {
                    // Assumed to be a string
                    groupingSpec = roleSpec;
                }
                
                // !groupingSpec (null or "") results in a null grouping being preBound
                // A pre bound null grouping is later discarded in the post bind,
                // but, in between, prevents translators from 
                // reading to dimensions that would bind into those roles...
                if(groupingSpec !== undefined){
                    var grouping = pvc.data.GroupingSpec.parse(groupingSpec);
    
                    visualRole.preBind(grouping);
    
                    /* Collect dimension names bound to a *single* role */
                    grouping.dimensions().each(function(groupDimSpec){
                        if(def.hasOwn(dimsBoundToSingleRole, groupDimSpec.name)){
                            // two roles => no defaults at all
                            delete dimsBoundToSingleRole[groupDimSpec.name];
                        } else {
                            dimsBoundToSingleRole[groupDimSpec.name] = visualRole;
                        }
                    });
                }
            }, this);
    
        }

        this._sourcedRoles = sourcedRoles;
        this._dimsBoundToSingleRole = dimsBoundToSingleRole;
    },
    
    _bindVisualRolesPreII: function(){
        /* Provide defaults to dimensions bound to a single role
         * by using the role's requirements 
         */
        var dimsBoundToSingleRole = this._dimsBoundToSingleRole;
        if(dimsBoundToSingleRole){
            delete this._dimsBoundToSingleRole; // free memory
            
            def.eachOwn(
                dimsBoundToSingleRole, 
                this._setRoleBoundDimensionDefaults, 
                this);
        }
        
        var sourcedRoles = this._sourcedRoles;
        delete this._sourcedRoles; // free memory
        
        /* Apply defaultSourceRole to roles not pre-bound */
        def
        .query(this._visualRoleList)
        .where(function(role){ return role.defaultSourceRoleName && !role.sourceRole && !role.isPreBound(); })
        .each (function(role){
            var sourceRole = this._visualRoles[role.defaultSourceRoleName];
            if(sourceRole){
                role.setSourceRole(sourceRole);
                sourcedRoles.push(role);
            }
        }, this)
        ;
        
        /* Pre-bind sourced roles whose source role is itself pre-bound */
        // Only if the role has no default dimension, cause otherwise, 
        // it would prevent binding to it, if it comes to exist.
        // In those cases, sourcing only effectively happens in the post phase.
        sourcedRoles.forEach(function(role){
            var sourceRole = role.sourceRole;
            if(sourceRole.isReversed){
                role.setIsReversed(!role.isReversed);
            }
            
            if(!role.defaultDimensionName && sourceRole.isPreBound()){
                role.preBind(sourceRole.preBoundGrouping());
            }
        });
    },
    
    _setRoleBoundDimensionDefaults: function(role, dimName){
        //var splitId = pvc.splitIndexedId(dimName);
        
        this._complexTypeProj
            .setDimDefaults(dimName, role.dimensionDefaults)
            ;
//            .setDimDefaults(dimName, {
//                label: pvc.buildIndexedId(role.label, splitId[1])
//            });
    },
    
    _bindVisualRolesPostI: function(){
        
        var complexTypeProj = this._complexTypeProj;
        
        // Dimension names to roles bound to it
        var boundDimTypes = {};
        
        var unboundSourcedRoles = [];
        
        def
        .query(this._visualRoleList)
        .where(function(role) { return role.isPreBound(); })
        .each (markPreBoundRoleDims, this);
        
        /* (Try to) Automatically bind **unbound** roles:
         * -> to their default dimensions, if they exist and are not yet bound to
         * -> if the default dimension does not exist and the 
         *    role allows auto dimension creation, 
         *    creates 1 *hidden* dimension (that will receive only null data)
         * 
         * Validates role required'ness.
         */
        def
        .query(this._visualRoleList)
        .where(function(role) { return !role.isPreBound(); })
        .each (autoBindUnboundRole, this);
        
        /* Sourced roles that could not be normally bound
         * are now finally sourced 
         */
        unboundSourcedRoles.forEach(tryPreBindSourcedRole, this);
        
        /* Apply defaults to single-bound-to dimensions
         * TODO: this is being repeated for !pre-bound! dimensions
         */
        def
        .query(def.ownKeys(boundDimTypes))
        .where(function(dimName) { return boundDimTypes[dimName].length === 1; })
        .each (function(dimName){
            var singleRole = boundDimTypes[dimName][0];
            this._setRoleBoundDimensionDefaults(singleRole, dimName);
        }, this);

        // ----------------
        
        function markDimBoundTo(dimName, role){
            def.array.lazy(boundDimTypes, dimName).push(role);
        }
        
        function dimIsDefined(dimName){
            return complexTypeProj.hasDim(dimName);
        }
        
        function preBindRoleTo(role, dimNames){
            if(def.array.is(dimNames)){
                dimNames.forEach(function(dimName){ 
                    markDimBoundTo(dimName, role);
                });
            } else {
                markDimBoundTo(dimNames, role);
            }
            
            role.setSourceRole(null); // if any
            role.preBind(pvc.data.GroupingSpec.parse(dimNames));
        }
        
        function preBindRoleToGroupDims(role, groupDimNames){
            if(groupDimNames.length){
                if(role.requireSingleDimension){
                    preBindRoleTo(role, groupDimNames[0]);
                } else {
                    preBindRoleTo(role, groupDimNames);
                }
            }
        }
        
        function preBindRoleToNewDim(role, dimName){
            /* Create a hidden dimension and bind the role and the dimension */
            complexTypeProj.setDim(dimName, {isHidden: true});
            
            preBindRoleTo(role, dimName);
        }
        
        function roleIsUnbound(role){
            if(role.isRequired) {
                throw def.error.operationInvalid("Chart type requires unassigned role '{0}'.", [role.name]);
            }
            
            // Unbind role from any previous binding
            role.bind(null);
            role.setSourceRole(null); // if any
        }
        
        function markPreBoundRoleDims(role){
            role.preBoundGrouping()
                .dimensionNames()
                .forEach(markDimBoundTo);
        }
        
        function autoBindUnboundRole(role){
            var name = role.name;
            
            // !role.isPreBound()
            
            /* Try to bind automatically, to defaultDimensionName */
            var dimName = role.defaultDimensionName;
            if(!dimName) {
                if(role.sourceRole){
                    unboundSourcedRoles.push(role);
                } else {
                    roleIsUnbound(role);
                }
                return;
            }
                
            /* An asterisk at the end of the name indicates
             * that any dimension of that group is allowed.
             * If the role allows multiple dimensions,
             * then the meaning is greedy - use them all.
             * Otherwise, use only one.
             * 
             *   "product*"
             */
            var match = dimName.match(/^(.*?)(\*)?$/) ||
                        def.fail.argumentInvalid('defaultDimensionName');
            
            var defaultName =  match[1];
            var greedy = /*!!*/match[2];
            if(greedy) {
                // TODO: does not respect any index explicitly specified
                // before the *. Could mean >=...
                var groupDimNames = complexTypeProj.groupDimensionsNames(defaultName);
                if(groupDimNames){
                    // Default dimension(s) is defined
                    preBindRoleToGroupDims(role, groupDimNames);
                    return;
                }
                // Follow to auto create dimension
                
            } else if(dimIsDefined(defaultName)){ // defaultName === dimName
                preBindRoleTo(role, defaultName);
                return;
            }

            if(role.autoCreateDimension){
                preBindRoleToNewDim(role, defaultName);
                return;
            }
            
            if(role.sourceRole){
                unboundSourcedRoles.push(role);
            } else {
                roleIsUnbound(role);
            }
        }
    
        function tryPreBindSourcedRole(role){
            var sourceRole = role.sourceRole;
            if(sourceRole.isPreBound()){
                role.preBind(sourceRole.preBoundGrouping());
            } else {
                roleIsUnbound(role);
            }
        }
    },
    
    _bindVisualRolesPostII: function(complexType){
        
        def
        .query(this._visualRoleList)
        .where(function(role) { return role.isPreBound(); })
        .each (commitRolePreBinding, this);

        function commitRolePreBinding(role){
            // Commits and validates the grouping specification.
            // Null groupings are discarded.
            // Sourced roles that were also pre-bound are here normally bound.
            role.postBind(complexType);
        }
    },

    _logVisualRoles: function(){
        var out = ["VISUAL ROLES SUMMARY", pvc.logSeparator];
        
        def.eachOwn(this._visualRoles, function(role, name){
            out.push("  " + name + def.array.create(18 - name.length, " ").join("") +
                    (role.grouping ? (" <-- " + role.grouping) : ''));
        });
        
        out.push(pvc.logSeparator);

        this._log(out.join("\n"));
    },

    /**
     * Obtains a roles array or a specific role, given its name.
     * 
     * @param {string} roleName The role name.
     * @param {object} keyArgs Keyword arguments.
     * @param {boolean} assertExists Indicates if an error should be thrown if the specified role name is undefined.
     * 
     * @type pvc.data.VisualRole[]|pvc.data.VisualRole 
     */
    visualRoles: function(roleName, keyArgs){
        if(roleName == null) {
            return def.own(this._visualRoles);
        }
        
        var role = def.getOwn(this._visualRoles, roleName) || null;
        if(!role && def.get(keyArgs, 'assertExists', true)) {
            throw def.error.argumentInvalid('roleName', "Undefined role name '{0}'.", [roleName]);
        }
        
        return role;
    },

    measureVisualRoles: function(){
        return this._measureVisualRoles;
    },

    measureDimensionsNames: function(){
        return def.query(this._measureVisualRoles)
                   .select(function(visualRole){ return visualRole.firstDimensionName(); })
                   .where(def.notNully)
                   .array();
    },
    
    /**
     * Indicates if a role is assigned, given its name. 
     * 
     * @param {string} roleName The role name.
     * @type boolean
     */
    _isRoleAssigned: function(roleName){
        return !!this._visualRoles[roleName].grouping;
    },
    
    _getDataPartDimName: function(){
        var role = this._dataPartRole;
        if(role){
            if(role.isBound()){
                return role.firstDimensionName();
            } 
            
            var preGrouping = role.preBoundGrouping();
            if(preGrouping) {
                return preGrouping.firstDimensionName();
            }
            
            return role.defaultDimensionName;
        }
    }
});

pvc.BaseChart
.add({
    
    /**
     * The data that the chart is to show.
     * @type pvc.data.Data
     * @deprecated
     */
    dataEngine: null,
    
    /**
     * The data that the chart is to show.
     * @type pvc.data.Data
     */
    data: null,
    
    /**
     * The resulting data of 
     * grouping {@link #data} by the data part role, 
     * when bound.
     * 
     * @type pvc.data.Data
     */
    _partData: null,

    /**
     * The data source of the chart.
     * <p>
     * The {@link #data} of a root chart 
     * is loaded with the data in this array.
     * </p>
     * @type any[]
     */
    resultset: [],
    
    /**
     * The meta-data that describes each 
     * of the data components of {@link #resultset}.
     * @type any[]
     */
    metadata: [],
    
    _constructData: function(options) {
        var parent = this.parent;
        if(parent) {
            this.dataEngine =
            this.data = options.data ||
                        def.fail.argumentRequired('options.data');            
        }
    },
    
    _checkNoDataI: function(){
        // Child charts are created to consume *existing* data
        if (!this.parent) {
            
            // If we don't have data, we just need to set a "no data" message
            // and go on with life.
            if(!this.allowNoData && this.resultset.length === 0) {
                /*global NoDataException:true */
                throw new NoDataException();
            }
        }
    },
    
    _checkNoDataII: function(){
        // Child charts are created to consume *existing* data
        if (!this.parent) {
            
            // If we don't have data, we just need to set a "no data" message
            // and go on with life.
            if(!this.allowNoData && (!this.data || !this.data.count())) {
                /*global NoDataException:true */
                throw new NoDataException();
            }
        }
    },
    
    /**
     * Initializes the data engine and roles
     */
    _initData: function(keyArgs) {
        if(!this.parent) {
            var data = this.data;
            if(!data || def.get(keyArgs, 'reloadData', true)) {
               this._onLoadData();
            } else {
                data.clearVirtuals();
                data.disposeChildren();
            }
        }

        delete this._partData;
        
        if(pvc.debug >= 3){
            this._log(this.data.getInfo());
        }
    },

    _onLoadData: function(){
        var data = this.data;
        var options = this.options;
        var dataPartDimName = this._getDataPartDimName();
        var complexTypeProj = this._complexTypeProj;
        var translOptions   = this._createTranslationOptions(dataPartDimName);
        var translation     = this._createTranslation(translOptions);
        
        if(pvc.debug >= 3){
            translation.logSource();
        }
        
        if(!data){
            // Now the translation can also configure the type
            translation.configureType();
            
            // If the the dataPart dimension isn't being read or calculated
            // its value must be defaulted to 0.
            if(dataPartDimName && !complexTypeProj.isReadOrCalc(dataPartDimName)){
                this._addDefaultDataPartCalculation(dataPartDimName);
            }
        }
        
        // ----------
        // Roles are bound before actually loading data.
        // i) roles add default properties to dimensions bound to them
        // ii) in order to be able to filter datums
        //     whose "every dimension in a measure role is null".
        //
        // TODO: check why PRE is done only on createVersion 1 and this one 
        // is done on every create version
        this._bindVisualRolesPostI();
        
        // Setup the complex type from complexTypeProj;
        var complexType;
        if(!data){
            complexType = new pvc.data.ComplexType();
            complexTypeProj.configureComplexType(complexType, translOptions);
        } else {
            complexType = data.type;
        }

        this._bindVisualRolesPostII(complexType);
        
        if(pvc.debug >= 3){
            this._log(complexType.describe());
        }
        
        if(pvc.debug >= 3){
            this._logVisualRoles();
        }

        // ----------

        if(!data) {
            data =
                this.dataEngine = // V1 property
                this.data = new pvc.data.Data({
                    type:     complexType,
                    labelSep: options.groupedLabelSep
                });
        } // else TODO: assert complexType has not changed...
        
        // ----------

        var loadKeyArgs = {
            where:  this._getLoadFilter(),
            isNull: this._getIsNullDatum()
        };
        
        var resultQuery = translation.execute(data);
        
        data.load(resultQuery, loadKeyArgs);
    },
    
    _createComplexTypeProject: function(){
        var options = this.options;
        var complexTypeProj = new pvc.data.ComplexTypeProject(options.dimensionGroups);
        
        // Add specified dimensions
        var userDimsSpec = options.dimensions;
        for(var dimName in userDimsSpec) { // userDimsSpec can be null; 'for' accepts null!
            complexTypeProj.setDim(dimName, userDimsSpec[dimName]);
        }
        
        // Add data part dimension and
        // dataPart calculation from series values
        var dataPartDimName = this._getDataPartDimName();
        if(dataPartDimName){
            complexTypeProj.setDim(dataPartDimName);
            
            this._addPlot2SeriesDataPartCalculation(complexTypeProj, dataPartDimName);
        }
        
        // Add specified calculations
        var calcSpecs = options.calculations;
        if(calcSpecs){
            calcSpecs.forEach(function(calcSpec){
                complexTypeProj.setCalc(calcSpec);
            });
        }
        
        return complexTypeProj;
    },
    
    _getLoadFilter: function(){
        if(this.options.ignoreNulls) {
            var me = this;
            return function(datum){
                var isNull = datum.isNull;
                
                if(isNull && pvc.debug >= 4){
                    me._log("Datum excluded.");
                }
                
                return !isNull;
            };
        }
    },
    
    _getIsNullDatum: function(){
        var measureDimNames = this.measureDimensionsNames(),
            M = measureDimNames.length;
        if(M) {
            // Must have at least one measure role dimension not-null
            return function(datum){
                var atoms = datum.atoms;
                for(var i = 0 ; i < M ; i++){
                    if(atoms[measureDimNames[i]].value != null){
                        return false;
                    }
                }

                return true;
            };
        }
    },
    
    _createTranslation: function(translOptions){
        var TranslationClass = this._getTranslationClass(translOptions);
        
        return new TranslationClass(this, this._complexTypeProj, this.resultset, this.metadata, translOptions);
    },
    
    _getTranslationClass: function(translOptions){
        return translOptions.crosstabMode ? 
                pvc.data.CrosstabTranslationOper : 
                pvc.data.RelationalTranslationOper;
    },
    
    _createTranslationOptions: function(dataPartDimName){
        var options = this.options;
        
        var dataOptions = options.dataOptions || {};
        
        var dataSeparator = options.dataSeparator;
        if(dataSeparator === undefined){
            dataSeparator = dataOptions.separator;
        }
        
        var dataMeasuresInColumns = options.dataMeasuresInColumns;
        if(dataMeasuresInColumns === undefined){
            dataMeasuresInColumns = dataOptions.measuresInColumns;
        }
        
        var dataCategoriesCount = options.dataCategoriesCount;
        if(dataCategoriesCount === undefined){
            dataCategoriesCount = dataOptions.categoriesCount;
        }
        
        var plot2 = options.plot2;
        
        var valueFormat = options.valueFormat,
            valueFormatter;
        if(valueFormat && valueFormat !== this.defaults.valueFormat){
            valueFormatter = function(v) {
                return v != null ? valueFormat(v) : "";
            };
        }
        
        var secondAxisIdx;
        if(plot2 && this._allowV1SecondAxis && (this.compatVersion() <= 1)){
            secondAxisIdx = pvc.parseDistinctIndexArray(options.secondAxisIdx) || -1;
        }
        
        return {
            compatVersion:     this.compatVersion(),
            plot2SeriesIndexes: secondAxisIdx,
            seriesInRows:      options.seriesInRows,
            crosstabMode:      options.crosstabMode,
            isMultiValued:     options.isMultiValued,
            dataPartDimName:   dataPartDimName,
            dimensionGroups:   options.dimensionGroups,
            dimensions:        options.dimensions,
            readers:           options.readers,

            measuresIndexes:   options.measuresIndexes, // relational multi-valued

            multiChartIndexes: options.multiChartIndexes,

            // crosstab
            separator:         dataSeparator,
            measuresInColumns: dataMeasuresInColumns,
            categoriesCount:   dataCategoriesCount,
            
            // TODO: currently measuresInRows is not implemented...
            measuresIndex:     dataOptions.measuresIndex || dataOptions.measuresIdx, // measuresInRows
            measuresCount:     dataOptions.measuresCount || dataOptions.numMeasures, // measuresInRows

            // Timeseries *parse* format
            isCategoryTimeSeries: options.timeSeries,

            timeSeriesFormat:     options.timeSeriesFormat,
            valueNumberFormatter: valueFormatter
        };
    },
    
    _addPlot2SeriesDataPartCalculation: function(complexTypeProj, dataPartDimName){
        if(this.compatVersion() <= 1){
            return;
        }
        
        var options = this.options;
        var serRole = this._serRole;
        
        var plot2Series = (serRole != null) && 
                          options.plot2 && 
                          options.plot2Series && 
                          def.array.as(options.plot2Series);
        if(!plot2Series || !plot2Series.length){
            return;
        }
        
        var inited = false;
        var plot2SeriesSet = def.query(plot2Series).uniqueIndex();
        var dimNames, dataPartDim, part1Atom, part2Atom;
        
        complexTypeProj.setCalc({
            names: dataPartDimName,
            
            calculation: function(datum, atoms){
                if(!inited){
                    // LAZY init
                    if(serRole.isBound()){
                        dimNames    = serRole.grouping.dimensionNames();
                        dataPartDim = datum.owner.dimensions(dataPartDimName);
                    }
                    inited = true;
                }
                
                if(dataPartDim){
                    var seriesKey = pvc.data.Complex.values(datum, dimNames).join(',');
                    
                    atoms[dataPartDimName] = 
                        def.hasOwnProp.call(plot2SeriesSet, seriesKey) ?
                           (part2Atom || (part2Atom = dataPartDim.intern("1"))) :
                           (part1Atom || (part1Atom = dataPartDim.intern("0")));
                }
            }
        });
    },
    
    _addDefaultDataPartCalculation: function(dataPartDimName){
        var dataPartDim, part1Atom;
        
        this._complexTypeProj.setCalc({
            names: dataPartDimName,
            
            calculation: function(datum, atoms){
                if(!dataPartDim){
                    dataPartDim = datum.owner.dimensions(dataPartDimName);
                }
                
                atoms[dataPartDimName] = part1Atom || 
                    (part1Atom = dataPartDim.intern("0"));
            }
        });
    },
    
    partData: function(dataPartValues){
        if(!this._partData){
            if(!this._dataPartRole || !this._dataPartRole.grouping){
                /* Undefined or unbound */
                return this._partData = this.data;
            }
            
            // Visible and not
            this._partData = this.data.flattenBy(this._dataPartRole);
        }
        
        if(!dataPartValues || !this._dataPartRole || !this._dataPartRole.grouping){
            return this._partData;
        }
        
        var dataPartDimName = this._dataPartRole.firstDimensionName();
        
        if(def.array.is(dataPartValues)){
            if(dataPartValues.length > 1){
                return this._partData.where([
                             def.set({}, dataPartDimName, dataPartValues)
                         ]);
            }
            
            dataPartValues = dataPartValues[0];
        }
        
        // TODO: should, at least, call some static method of Atom to build a global key
        var child = this._partData._childrenByKey[/*dataPartDimName + ':' +*/ dataPartValues + ''];
        if(!child){
            // NOTE: 
            // This helps, at least, the ColorAxis.dataCells setting
            // the .data property, in a time where there aren't yet any datums of
            // the 'trend' data part value.
            // So we create a dummy empty place-holder child here,
            // so that when the trend datums are added they end up here,
            // and not in another new Data...
            var dataPartCell = {
                v: dataPartValues
            };
            
            // TODO: HACK: To make trend label fixing work in multi-chart scenarios... 
            if(dataPartValues === 'trend'){
                var firstTrendAtom = this._firstTrendAtomProto;
                if(firstTrendAtom){
                    dataPartCell.f = firstTrendAtom.f;
                }
            }
            
            child = new pvc.data.Data({
                parent:   this._partData,
                atoms:    def.set({}, dataPartDimName, dataPartCell), 
                dimNames: [dataPartDimName],
                datums:   []
                // TODO: index
            });
        }
        return child;
    },

    // --------------------
    
    _generateTrends: function(){
        if(this._dataPartRole){
            
            def
            .query(def.own(this.axes))
            .selectMany(function(axis){ return axis.dataCells; })
            .where(function(dataCell){ return !!dataCell.trend; })
             .distinct(function(dataCell){
                 return dataCell.role.name  + '|' +
                       (dataCell.dataPartValue || '');
             })
             .each(this._generateTrendsDataCell, this);
        }
    },
    
    _interpolate: function(){
        def
        .query(def.own(this.axes))
        .selectMany(function(axis){ return axis.dataCells; })
        .where(function(dataCell){
            var nim = dataCell.nullInterpolationMode;
            return !!nim && nim !== 'none'; 
         })
         .distinct(function(dataCell){
             return dataCell.role.name  + '|' +
                   (dataCell.dataPartValue || '');
         })
         .each(this._interpolateDataCell, this);
    },
    
    _interpolateDataCell: function(dataCell){
    },
    
    _generateTrendsDataCell: function(dataCell){
    },
    
    // ---------------
        
    /**
     * Method to set the data to the chart.
     * Expected object is the same as what comes from the CDA: 
     * {metadata: [], resultset: []}
     */
    setData: function(data, options) {
        this.setResultset(data.resultset);
        this.setMetadata(data.metadata);

        // TODO: Danger!
        $.extend(this.options, options);
        
        return this;
    },
    
    /**
     * Sets the resultset that will be used to build the chart.
     */
    setResultset: function(resultset) {
        /*jshint expr:true */
        !this.parent || def.fail.operationInvalid("Can only set resultset on root chart.");
        
        this.resultset = resultset;
        if (!resultset.length) {
            this._log("Warning: Resultset is empty");
        }
        
        return this;
    },

    /**
     * Sets the metadata that, optionally, 
     * will give more information for building the chart.
     */
    setMetadata: function(metadata) {
        /*jshint expr:true */
        !this.parent || def.fail.operationInvalid("Can only set resultset on root chart.");
        
        this.metadata = metadata;
        if (!metadata.length) {
            this._log("Warning: Metadata is empty");
        }
        
        return this;
    }
});

pvc.BaseChart
.add({
    _initPlots: function(hasMultiRole){
        // reset plots
        if(!this.parent){
            this.plots = {};
            this.plotList = [];
            this.plotsByType = {};
            
            this._initPlotsCore(hasMultiRole);
        } else {
            var root = this.root;
            
            this.plots = root.plots;
            this.plotList = root.plotList;
            this.plotsByType = root.plotsByType;
        }
    },
    
    _initPlotsCore: function(hasMultiRole){
        // NOOP
    },

    _addPlot: function(plot){
        var plotsByType = this.plotsByType;
        var plots = this.plots;
        
        var plotType  = plot.type;
        var plotIndex = plot.index;
        var plotName  = plot.name;
        var plotId    = plot.id;
        
        if(plotName && def.hasOwn(plots, plotName)){
            throw def.error.operationInvalid("Plot name '{0}' already taken.", [plotName]);
        }
        
        if(def.hasOwn(plots, plotId)){
            throw def.error.operationInvalid("Plot id '{0}' already taken.", [plotId]);
        }
        
        var typePlots = def.array.lazy(plotsByType, plotType);
        if(def.hasOwn(typePlots, plotIndex)){
            throw def.error.operationInvalid("Plot index '{0}' of type '{1}' already taken.", [plotIndex, plotType]);
        }
        
        plot.globalIndex = this.plotList.length;
        typePlots[plotIndex] = plot;
        this.plotList.push(plot);
        plots[plotId] = plot;
        if(plotName){
            plots[plotName] = plot;
        }
    },
    
    _collectPlotAxesDataCells: function(plot, dataCellsByAxisTypeThenIndex){
        /* Configure Color Axis Data Cell */
        var colorRoleName = plot.option('ColorRole');
        if(colorRoleName){
            var colorRole = this.visualRoles(colorRoleName);
            if(colorRole.isBound()){
                var colorDataCellsByAxisIndex = 
                    def
                    .array
                    .lazy(dataCellsByAxisTypeThenIndex, 'color');
                    
                def
                .array
                .lazy(colorDataCellsByAxisIndex, plot.option('ColorAxis') - 1)
                .push({
                    plot: plot,
                    role: colorRole,
                    dataPartValue: plot.option('DataPart')
                });
            }
        }
    },
    
    // Called by the pvc.PlotPnel class
    _addPlotPanel: function(plotPanel){
        def.lazy(this, 'plotPanels')[plotPanel.plot.id] = plotPanel;
        def.array.lazy(this, 'plotPanelList').push(plotPanel);
    },
    
    /* @abstract */
    _createPlotPanels: function(parentPanel, baseOptions){
        throw def.error.notImplemented();
    }
});

pvc.BaseChart
.add({
    /**
     * An array of colors, represented as names, codes or {@link pv.Color} objects
     * that is associated to each distinct value of the "color" visual role.
     * 
     * <p>
     * The legend panel associates each distinct dimension value to a color of {@link #colors},
     * following the dimension's natural order.
     * </p>
     * <p>
     * The default dimension is the 'series' dimension.
     * </p>
     * 
     * @type (string|pv.Color)[]
     */
    colors: null,

    /**
     * A map of {@link pvc.visual.Axis} by axis id.
     */
    axes: null,
    axesList: null,
    axesByType: null,

    _axisClassByType: {
        'color': pvc.visual.ColorAxis,
        'size':  pvc.visual.SizeAxis,
        'base':  pvc.visual.CartesianAxis,
        'ortho': pvc.visual.CartesianAxis
    },
    
    // 1 = root, 2 = leaf, 1|2=3 = everywhere
    _axisCreateWhere: {
        'color': 1,
        'size':  2,
        'base':  3,
        'ortho': 3
    },
    
    _axisCreationOrder: ['color', 'size', 'base', 'ortho'],
    
    _initAxes: function(hasMultiRole){
        this.axes = {};
        this.axesList = [];
        this.axesByType = {};
        
        // Clear any previous global color scales
        delete this._rolesColorScale;
        
        // type -> index -> [datacell array]
        // Used by sub classes.
        var dataCellsByAxisTypeThenIndex;
        if(!this.parent){
            dataCellsByAxisTypeThenIndex = {};
            
            this.plotList.forEach(function(plot){
                this._collectPlotAxesDataCells(plot, dataCellsByAxisTypeThenIndex);
            }, this);
            
            this._fixTrendsLabel(dataCellsByAxisTypeThenIndex);
        } else {
            dataCellsByAxisTypeThenIndex = this.root._dataCellsByAxisTypeThenIndex;
        }
        
        // Used later in _bindAxes as well.
        this._dataCellsByAxisTypeThenIndex = dataCellsByAxisTypeThenIndex;
        
        /* NOTE: Cartesian axes are created even when hasMultiRole && !parent
         * because it is needed to read axis options in the root chart.
         * Also binding occurs to be able to know its scale type. 
         * Yet, their scales are not setup at the root level.
         */
        
        // 1 = root, 2 = leaf, 1 | 2 = 3 = everywhere
        var here = 0;
        // Root?
        if(!this.parent){
            here |= 1;
        }
        // Leaf?
        if(this.parent || !hasMultiRole){
            here |= 2;
        }
        
        // Used later in _bindAxes as well.
        this._axisCreateHere = here;
        
        this._axisCreationOrder.forEach(function(type){
            // Create **here** ?
            if((this._axisCreateWhere[type] & here) !== 0){
                
                var dataCellsByAxisIndex = dataCellsByAxisTypeThenIndex[type];
                if(dataCellsByAxisIndex){
                    
                    var AxisClass = this._axisClassByType[type];
                    if(AxisClass){
                        dataCellsByAxisIndex.forEach(function(dataCells, axisIndex){
                            
                            new AxisClass(this, type, axisIndex);
                            
                        }, this);
                    }
                }
            }
        }, this);
        
        if(this.parent){
            // Copy axes that exist in root and not here
            this.root.axesList.forEach(function(axis){
                if(!def.hasOwn(this.axes, axis.id)){
                    this._addAxis(axis);
                }
            }, this);
        }
    },
    
    _fixTrendsLabel: function(dataCellsByAxisTypeThenIndex){
        // Pre-register the label of the first trend type 
        // in the "trend" data part atom, cause in multi-charts
        // an empty label would be registered first...
        // We end up using this to 
        // allow to specify an alternate label for the trend.
        var dataPartDimName = this._getDataPartDimName();
        if(dataPartDimName){
            // Find the first data cell with a trend type
            var firstDataCell = def
                .query(def.ownKeys(dataCellsByAxisTypeThenIndex))
                .selectMany(function(axisType){
                    return dataCellsByAxisTypeThenIndex[axisType];
                })
                .selectMany()
                .first (function(dataCell){ return !!dataCell.trend; })
                ;
            
            if(firstDataCell){
                var trendInfo = pvc.trends.get(firstDataCell.trend.type);
                var dataPartAtom = trendInfo.dataPartAtom;
                var trendLabel = firstDataCell.trend.label;
                if(trendLabel === undefined){
                    trendLabel = dataPartAtom.f;
                }
                
                this._firstTrendAtomProto = {
                    v: dataPartAtom.v,
                    f: trendLabel
                };
            } else {
                delete this._firstTrendAtomProto;
            }
        }
    },
    
    /**
     * Adds an axis to the chart.
     * 
     * @param {pvc.visual.Axis} axis The axis.
     *
     * @type pvc.visual.Axis
     */
    _addAxis: function(axis){
        
        this.axes[axis.id] = axis;
        if(axis.chart === this){
            axis.axisIndex = this.axesList.length;
        }
        
        this.axesList.push(axis);
        
        var typeAxes  = def.array.lazy(this.axesByType, axis.type);
        var typeIndex = typeAxes.count || 0;
        axis.typeIndex = typeIndex;
        typeAxes[axis.index] = axis;
        if(!typeIndex){
            typeAxes.first = axis;
        }
        typeAxes.count = typeIndex + 1;
        
        // For child charts, that simply copy color axes
        if(axis.type === 'color' && axis.isBound()){
            this._onColorAxisScaleSet(axis);
        }
        
        return this;
    },
    
    getAxis: function(type, index){
        var typeAxes = this.axesByType[type];
        if(typeAxes){
            return typeAxes[index];
        }
    },
    
    _bindAxes: function(hasMultiRole){
        // Bind all axes with dataCells registered in #_dataCellsByAxisTypeThenIndex
        // and which were created **here**
        
        var here = this._axisCreateHere;
        
        def
        .eachOwn(
            this._dataCellsByAxisTypeThenIndex, 
            function(dataCellsByAxisIndex, type){
                // Created **here** ?
                if((this._axisCreateWhere[type] & here) !== 0){
                    
                    dataCellsByAxisIndex.forEach(function(dataCells, index){
                        
                        var axisId = pvc.buildIndexedId(type, index);
                        var axis = this.axes[axisId];
                        if(!axis.isBound()){
                            axis.bind(dataCells);
                        }
                        
                    }, this);
                }
            }, 
            this);
    },
    
    _setAxesScales: function(isMulti){
        if(!this.parent){
            var colorAxes = this.axesByType.color;
            if(colorAxes){
                colorAxes.forEach(function(axis){
                    if(axis.isBound()){
                        axis.calculateScale();
                        this._onColorAxisScaleSet(axis);
                    }
                }, this);
            }
        }
    },
    
    _onColorAxisScaleSet: function(axis){
        switch(axis.index){
            case 0:
                this.colors = axis.option('Colors');
                break;
            
            case 1:
                if(this._allowV1SecondAxis){
                    this.secondAxisColor = axis.option('Colors');
                }
                break;
        }
    },
    
    /**
     * Obtains an unified color scale, 
     * of all the color axes with specified colors.
     * 
     * This color scale is used to satisfy axes
     * with non-specified colors.
     * 
     * Each color-role has a different unified color-scale,
     * in order that the color keys are of the same types.
     */
    _getRoleColorScale: function(roleName){
        return def.lazy(
            def.lazy(this, '_rolesColorScale'),
            roleName,
            this._createRoleColorScale, this);
    },
    
    _createRoleColorScale: function(roleName){
        var firstScale, scale;
        var valueToColorMap = {};
        
        this.axesByType.color.forEach(function(axis){
            // Only use color axes with specified Colors
            var axisRole = axis.role;
            var isRoleCompatible = 
                (axisRole.name === roleName) ||
                (axisRole.sourceRole && axisRole.sourceRole.name === roleName);
            
            if(isRoleCompatible && (axis.index === 0 || axis.option.isSpecified('Colors'))){
                scale = axis.scale;
                if(!firstScale){ firstScale = scale; }
                
                axis.domainValues.forEach(addDomainValue);
            }
        }, this);
        
        function addDomainValue(value){
            // First color wins
            var key = '' + value;
            if(!def.hasOwnProp.call(valueToColorMap, key)){
                valueToColorMap[key] = scale(value);
            }
        }
        
        if(!firstScale){
            return pvc.createColorScheme()();
        }
        
        scale = function(value){
            var key = '' + value;
            if(def.hasOwnProp.call(valueToColorMap, key)){
                return valueToColorMap[key];
            }
            
            // creates a new entry...
            var color = firstScale(value);
            valueToColorMap[key] = color;
            return color;
        };
        
        def.copy(scale, firstScale); // TODO: domain() and range() should be overriden...
        
        return scale;
    },
    
    _onLaidOut: function(){
        
    }
});

pvc.BaseChart
.add({
    /**
     * The base panel is the root container of a chart.
     * <p>
     * The base panel of a <i>root chart</i> is the top-most root container.
     * It has {@link pvc.BasePanel#isTopRoot} equal to <tt>true</tt>.
     * </p>
     * <p>
     * The base panel of a <i>non-root chart</i> is the root of the chart's panels,
     * but is not the top-most root panel, over the charts hierarchy.
     * </p>
     * 
     * @type pvc.BasePanel
     */
    basePanel:   null,
    
    /**
     * The panel that shows the chart's title.
     * <p>
     * This panel is the first child of {@link #basePanel} to be created.
     * It is only created when the chart has a non-empty title.
     * </p>
     * <p>
     * Being the first child causes it to occupy the 
     * whole length of the side of {@link #basePanel} 
     * to which it is <i>docked</i>.
     * </p>
     * 
     * @type pvc.TitlePanel
     */
    titlePanel:  null,
    
    /**
     * The panel that shows the chart's main legend.
     * <p>
     * This panel is the second child of {@link #basePanel} to be created.
     * There is an option to not show the chart's legend,
     * in which case this panel is not created.
     * </p>
     * 
     * <p>
     * The current implementation of the legend panel
     * presents a <i>discrete</i> association of colors and labels.
     * </p>
     * 
     * @type pvc.LegendPanel
     */
    legendPanel: null,
    
    /**
     * The panel that hosts child chart's base panels.
     * 
     * @type pvc.MultiChartPanel
     */
    _multiChartPanel: null,
    
    _initChartPanels: function(hasMultiRole){
        /* Initialize chart panels */
        this._initBasePanel  ();
        this._initTitlePanel ();
        
        var legendPanel = this._initLegendPanel();
        
        if(!this.parent && hasMultiRole) {
            this._initMultiChartPanel();
            
            if(legendPanel){
                this._initLegendScenes(legendPanel);
            }
        } else {
            var options = this.options;
            
            if(legendPanel){
                this._initLegendScenes(legendPanel);
            }
            
            this._preRenderContent({
                margins:           hasMultiRole ? options.smallContentMargins  : options.contentMargins,
                paddings:          hasMultiRole ? options.smallContentPaddings : options.contentPaddings,
                clickAction:       options.clickAction,
                doubleClickAction: options.doubleClickAction
            });
        }
    },
    
    /**
     * Override to create chart specific content panels here.
     * No need to call base.
     * 
     * @param {object} contentOptions Object with content specific options. Can be modified.
     * @param {pvc.Sides} [contentOptions.margins] The margins for the content panels. 
     * @param {pvc.Sides} [contentOptions.paddings] The paddings for the content panels.
     * 
     * @virtual
     */
    _preRenderContent: function(contentOptions){
        /* NOOP */
    },
    
    /**
     * Creates and initializes the base panel.
     */
    _initBasePanel: function() {
        var options = this.options;
        var basePanelParent = this.parent && this.parent._multiChartPanel;
        
        this.basePanel = new pvc.BasePanel(this, basePanelParent, {
            margins:  this.margins,
            paddings: this.paddings,
            size:     {width: this.width, height: this.height}
        });
    },
    
    /**
     * Creates and initializes the title panel,
     * if the title is specified.
     */
    _initTitlePanel: function(){
        var options = this.options;
        if (!def.empty(options.title)) {
            var isRoot = !this.parent;
            this.titlePanel = new pvc.TitlePanel(this, this.basePanel, {
                title:        options.title,
                font:         options.titleFont,
                anchor:       options.titlePosition,
                align:        options.titleAlign,
                alignTo:      options.titleAlignTo,
                offset:       options.titleOffset,
                keepInBounds: options.titleKeepInBounds,
                margins:      options.titleMargins,
                paddings:     options.titlePaddings,
                titleSize:    options.titleSize,
                titleSizeMax: options.titleSizeMax
            });
        }
    },
    
    /**
     * Creates and initializes the legend panel,
     * if the legend is active.
     */
    _initLegendPanel: function(){
        var options = this.options;
        // global legend(s) switch
        if (options.legend) {

            var legend = new pvc.visual.Legend(this, 'legend', 0);
            
            // TODO: pass all these options to Legend class
            
            this.legendPanel = new pvc.LegendPanel(this, this.basePanel, {
                anchor:       legend.option('Position'),
                align:        legend.option('Align'),
                alignTo:      options.legendAlignTo,
                offset:       options.legendOffset,
                keepInBounds: options.legendKeepInBounds,
                size:         legend.option('Size'),
                sizeMax:      legend.option('SizeMax'),
                margins:      legend.option('Margins'),
                paddings:     legend.option('Paddings'),
                font:         legend.option('Font'),
                scenes:       def.getPath(options, 'legend.scenes'),
                
                // Bullet legend
                textMargin:   options.legendTextMargin,
                itemPadding:  options.legendItemPadding,
                markerSize:   options.legendMarkerSize
                //shape:        options.legendShape // TODO: <- doesn't this come from the various color axes?
            });
            
            return this.legendPanel;
        }
    },
    
    _getLegendBulletRootScene: function(){
        return this.legendPanel && this.legendPanel._getBulletRootScene();
    },
    
    /**
     * Creates and initializes the multi-chart panel.
     */
    _initMultiChartPanel: function(){
        var basePanel = this.basePanel;
        var options = this.options;
        
        this._multiChartPanel = new pvc.MultiChartPanel(
            this, 
            basePanel, 
            {
                margins:  options.contentMargins,
                paddings: options.contentPaddings
            });
        
        this._multiChartPanel.createSmallCharts();
        
        // BIG HACK: force legend to be rendered after the small charts, 
        // to allow them to register legend renderers.
        basePanel._children.unshift(basePanel._children.pop());
    },
    
    _coordinateSmallChartsLayout: function(scopesByType){
        // NOOP
    },
    
    /**
     * Creates the legend group scenes of a chart.
     *
     * The default implementation creates
     * one legend group per data part value
     * and with one legend item per 
     * value of the "color" visual role.
     *
     * Legend groups are registered with the id prefix "part"
     * followed by the corresponding part value.
     */
    _initLegendScenes: function(legendPanel){
        
        var rootScene, dataPartDimName;
        var legendIndex = 0; // always start from 0
        
        // For all color axes...
        var colorAxes = this.axesByType.color;
        if(colorAxes){
            colorAxes.forEach(processAxis, this);
        }
        
        // ------------

        function processAxis(colorAxis){
            if(colorAxis.option('LegendVisible')){
                var dataCells = colorAxis && colorAxis.dataCells;
                if(dataCells){
                    dataCells
                    .forEach(function(dataCell){
                        if(dataCell.role.isDiscrete()){
                            var domainData = dataCell.data;
                            
                            if(!rootScene){
                                dataPartDimName = this._getDataPartDimName();
                                rootScene = legendPanel._getBulletRootScene();
                            }
                            
                            var dataPartAtom;
                            var locked = colorAxis.option('LegendClickMode') === 'toggleVisible' && 
                                         (dataPartAtom = domainData.atoms[dataPartDimName]) && 
                                         dataPartAtom.value === 'trend';
                            
                            var groupScene = rootScene.createGroup({
                                group:           domainData,
                                colorAxis:       colorAxis,
                                clickMode:       locked ? 'none' : undefined,
                                extensionPrefix: pvc.buildIndexedId('legend', legendIndex++)
                             });
                            
                            // For later binding an appropriate bullet renderer
                            dataCell.legendBulletGroupScene = groupScene;
                            
                            var partColorScale = colorAxis.scale;
                            
                            domainData
                                .children()
                                .each(function(itemData){
                                    var itemScene = groupScene.createItem({group: itemData});
                                    
                                    // HACK...
                                    itemScene.color = partColorScale(itemData.value);
                                });
                        }
                    }, this);
                }
            }
        }
    }
});

pvc.BaseChart
.add({
    _updateSelectionSuspendCount: 0,
    _lastSelectedDatums: null,
    
    /** 
     * Clears any selections and, if necessary,
     * re-renders the parts of the chart that show selected marks.
     * 
     * @type undefined
     * @virtual 
     */
    clearSelections: function(){
        if(this.data.owner.clearSelected()) {
            this.updateSelections();
        }
        
        return this;
    },
    
    _updatingSelections: function(method, context){
        this._suspendSelectionUpdate();
        
        var datums = this._lastSelectedDatums ? this._lastSelectedDatums.values() : [];
        //this._log("Previous Datum count=" + datums.length + 
        //        " keys=\n" + datums.map(function(d){return d.key;}).join('\n'));
        
        try {
            method.call(context || this);
        } finally {
            this._resumeSelectionUpdate();
        }
    },
    
    _suspendSelectionUpdate: function(){
        if(this === this.root) {
            this._updateSelectionSuspendCount++;
        } else {
            this.root._suspendSelectionUpdate();
        }
    },
    
    _resumeSelectionUpdate: function(){
        if(this === this.root) {
            if(this._updateSelectionSuspendCount > 0) {
                if(!(--this._updateSelectionSuspendCount)) {
                        this.updateSelections();
                    }
                }
        } else {
            this.root._resumeSelectionUpdate();
        }
    },
    
    /** 
     * Re-renders the parts of the chart that show marks.
     * 
     * @type undefined
     * @virtual 
     */
    updateSelections: function(){
        if(this === this.root) {
            if(this._inUpdateSelections) {
                return this;
            }
            
            if(this._updateSelectionSuspendCount) {
                return this;
            }
            
            var selectedChangedDatumMap = this._calcSelectedChangedDatums();
            if(!selectedChangedDatumMap){
                return;
            }
            
            pvc.removeTipsyLegends();
            
            // Reentry control
            this._inUpdateSelections = true;
            try {
                // Fire action
                var action = this.options.selectionChangedAction;
                if(action){
                    var selectedDatums = this.data.selectedDatums();
                    var selectedChangedDatums = selectedChangedDatumMap.values();
                    action.call(
                        this.basePanel._getContext(), 
                        selectedDatums, 
                        selectedChangedDatums);
                }
                
                // Rendering afterwards allows the action to change the selection in between
                this.useTextMeasureCache(function(){
                    this.basePanel.renderInteractive();
                }, this);
            } finally {
                this._inUpdateSelections = false;
            }
        } else {
            this.root.updateSelections();
        }
        
        return this;
    },
    
    _calcSelectedChangedDatums: function(){
        // Capture currently selected datums
        // Calculate the ones that changed.
        var selectedChangedDatums;
        var nowSelectedDatums  = this.data.selectedDatumMap();
        var lastSelectedDatums = this._lastSelectedDatums;
        if(!lastSelectedDatums){
            if(!nowSelectedDatums.count){
                return;
            }
            
            selectedChangedDatums = nowSelectedDatums.clone();
        } else {
            selectedChangedDatums = lastSelectedDatums.symmetricDifference(nowSelectedDatums);
            if(!selectedChangedDatums.count){
                return;
            }
        }
        
        this._lastSelectedDatums = nowSelectedDatums;
        
        var datums = this._lastSelectedDatums ? this._lastSelectedDatums.values() : [];
//        this._log("Now Datum count=" + datums.length + 
//                " keys=\n" + datums.map(function(d){return d.key;}).join('\n'));
        
        return selectedChangedDatums;
    },
    
    _onUserSelection: function(datums){
        if(!datums || !datums.length){
            return datums;
        }
        
        if(this === this.root) {
            // Fire action
            var action = this.options.userSelectionAction;
            if(action){
                return action.call(null, datums) || datums;
            }
            
            return datums;
        }
        
        return this.root._onUserSelection(datums);
    }
});

pvc.BaseChart
.add({
    
    _processExtensionPoints: function(){
        var components;
        if(!this.parent){
            var points = this.options.extensionPoints;
            components = {};
            if(points){
                for(var p in points) {
                    var id, prop;
                    var splitIndex = p.indexOf("_");
                    if(splitIndex > 0){
                        id   = p.substring(0, splitIndex);
                        prop = p.substr(splitIndex + 1);
                        if(id && prop){
                            var component = def.getOwn(components, id) ||
                                            (components[id] = new def.OrderedMap());
                            
                            component.add(prop, points[p]);
                        }
                    }
                }
            }
        } else {
            components = this.parent._components;
        }
        
        this._components = components;
    },
    
    /**
     * This is the method to be used for the extension points
     * for the specific contents of the chart. already ge a pie
     * chart! Goes through the list of options and, if it
     * matches the prefix, execute that method on the mark.
     * WARNING: It's the user's responsibility to make sure that
     * unexisting methods don't blow this.
     */
    extend: function(mark, ids, keyArgs){
        if(def.array.is(ids)){
            ids.forEach(function(id){
                this._extendCore(mark, id, keyArgs); 
            }, this);
        } else {
            this._extendCore(mark, ids, keyArgs);
        }
    },
    
    _extendCore: function(mark, id, keyArgs) {
        // if mark is null or undefined, skip
        if (mark) {
            var component = def.getOwn(this._components, id);
            if(component){
                if(mark.borderPanel){
                    mark = mark.borderPanel;
                }
                
                var logOut     = pvc.debug >= 3 ? [] : null;
                var constOnly  = def.get(keyArgs, 'constOnly', false); 
                var wrap       = mark.wrap;
                var keyArgs2   = {tag: pvc.extensionTag};
                var isRealMark = mark instanceof pv.Mark;
                
                component.forEach(function(v, m){
                    // Not everything that is passed to 'mark' argument
                    //  is actually a mark...(ex: scales)
                    // Not locked and
                    // Not intercepted and
                    if(mark.isLocked && mark.isLocked(m)){
                        if(logOut) {logOut.push(m + ": locked extension point!");}
                    } else if(mark.isIntercepted && mark.isIntercepted(m)) {
                        if(logOut) {logOut.push(m + ":" + pvc.stringify(v) + " (controlled)");}
                    } else {
                        if(logOut) {logOut.push(m + ": " + pvc.stringify(v)); }

                        // Extend object css and svg properties
                        if(v != null){
                            var type = typeof v;
                            if(type === 'object'){
                                if(m === 'svg' || m === 'css'){
                                    var v2 = mark.propertyValue(m);
                                    if(v2){
                                        v = def.copy(v2, v);
                                    }
                                }
                            } else if(isRealMark && (wrap || constOnly) && type === 'function'){
                                if(constOnly){
                                    return;
                                }
                                
                                if(m !== 'add'){ // TODO: "add" extension idiom - any other exclusions?
                                    v = wrap.call(mark, v, m);
                                }
                            }
                        }
                        
                        // Distinguish between mark methods and properties
                        if (typeof mark[m] === "function") {
                            if(m != 'add' && mark.intercept){
                                mark.intercept(m, v, keyArgs2);
                            } else {
                                // Not really a mark or not a real protovis property 
                                mark[m](v);
                            }
                        } else {
                            mark[m] = v;
                        }
                    }
                });

                if(logOut){
                    if(logOut.length){
                        this._log("Applying Extension Points for: '" + id + "'\n\t* " + logOut.join("\n\t* "));
                    } else if(pvc.debug >= 5) {
                        this._log("No Extension Points for: '" + id + "'");
                    }
                }
            }
        } else if(pvc.debug >= 4){
            this._log("Applying Extension Points for: '" + id + "' (target mark does not exist)");
        }
    },

    /**
     * Obtains the specified extension point.
     */
    _getExtension: function(id, prop) {
        var component;
        if(!def.array.is(id)){
            component = def.getOwn(this._components, id);
            if(component){
                return component.get(prop);
            }
        } else {
            // Last extension points are applied last, so have priority...
            var i = id.length - 1, value;
            while(i >= 0){
                component = def.getOwn(this._components, id[i--]);
                if(component && (value = component.get(prop)) !== undefined){
                    return value;
                }
            }
        }
    },
    
    _getConstantExtension: function(id, prop) {
        var value = this._getExtension(id, prop);
        if(!def.fun.is(value)){
            return value;
        }
    }
});


/**
 * Base panel. 
 * A lot of them will exist here, with some common properties. 
 * Each class that extends pvc.base will be 
 * responsible to know how to use it.
 */
def
.type('pvc.BasePanel', pvc.Abstract)
.init(function(chart, parent, options) {
    this.axes = {};
    
    if(options){
        if(options.scenes){
            this._sceneTypeExtensions = options.scenes;
            delete options.scenes;
        }
        
        var axes = options.axes;
        if(axes){
            def.copy(this.axes, axes);
            delete options.axes;
        }
    }
    
    // TODO: Danger...
    $.extend(this, options);
    
    this.chart = chart;

    if(!this.axes.color){
        this.axes.color = chart.axes.color;
    }
    
    this.position = {
        /*
        top:    0,
        right:  0,
        bottom: 0,
        left:   0
        */
    };
    
    var margins = options && options.margins;
    if(!parent && margins === undefined){
        // FIXME: Give a default margin on the root panel
        //  because otherwise borders of panels may be clipped..
        // Even now that the box model supports borders,
        // the "plot" panel still gets drawn outside
        // cause it is drawn over? See the box plot...
        // The rubber band also should take its border into account
        //  to not be drawn off...
        margins = 3;
    }
    
    this.margins  = new pvc.Sides(margins);
    this.paddings = new pvc.Sides(options && options.paddings);
    this.size     = new pvc.Size (options && options.size    );
    this.sizeMax  = new pvc.Size (options && options.sizeMax );
    
    if(!parent) {
        this.parent    = null;
        this.root      = this;
        this.topRoot   = this;
        this.isRoot    = true;
        this.isTopRoot = true;
        this.data      = this.chart.data;
        
    } else {
        this.parent    = parent;
        this.isTopRoot = false;
        this.isRoot    = (parent.chart !== chart);
        this.root      = this.isRoot ? this : parent.root;
        this.topRoot   = parent.topRoot;
        this.data      = parent.data; // TODO

        if(this.isRoot) {
            this.position.left = chart.left; 
            this.position.top  = chart.top;
        }
        
        parent._addChild(this);
    }
    
    /* Root panels do not need layout */
    if(this.isRoot) {
        this.anchor  = null;
        this.align   = null;
        this.alignTo = null;
        this.offset  = null;
    } else {
        this.align = pvc.parseAlign(this.anchor, this.align);
        
        // * a string with a named alignTo value
        // * a number
        // * a PercentValue object
        var alignTo = this.alignTo;
        var side = this.anchor;
        if(alignTo != null && alignTo !== '' && (side === 'left' || side === 'right')){
            if(alignTo !== 'page-middle'){
                if(!isNaN(+alignTo.charAt(0))){
                    alignTo = pvc.PercentValue.parse(alignTo); // percent or number
                } else {
                    alignTo = pvc.parseAlign(side, alignTo);
                }
            }
        } else {
            alignTo = this.align;
        }
        
        this.alignTo = alignTo;
        
        this.offset = new pvc.Offset(this.offset);
    }
    
    if(this.borderWidth == null){
        var borderWidth;
        var extensionId = this._getExtensionId();
        if(extensionId){
            var strokeStyle = this._getExtension(extensionId, 'strokeStyle');
            if(strokeStyle != null){
                borderWidth = +this._getConstantExtension(extensionId, 'lineWidth'); 
                if(isNaN(borderWidth) || !isFinite(borderWidth)){
                    borderWidth = 1.5;
                }
            }
        }
        
        this.borderWidth = borderWidth == null ? 0 : 1.5;
    }
})
.add({
    chart: null,
    parent: null,
    _children: null,
    type: pv.Panel, // default one
    
    _extensionPrefix: '',
    
    /**
     * Total height of the panel in pixels.
     * Includes vertical paddings and margins.
     * @type number  
     */
    height: null,
    
    /**
     * Total width of the panel in pixels.
     * Includes horizontal paddings and margins.
     * @type number
     */
    width: null,
    
    /**
     * The static effective border width of the panel.
     * 
     * If a constant extension point exists,
     * its value is used to initialize this property.
     * 
     * If an extension point exists for the <tt>strokeStyle</tt> property,
     * and its value is not null, 
     * the width, taken from the extension point, or defaulted, is considered.
     * Otherwise, the effective width is 0.
     * 
     * The default active value is <tt>1.5</tt>.
     * 
     * @type number
     */
    borderWidth: null,
    
    anchor: "top",
    
    pvPanel: null, // padding/client pv panel (within border box, separated by paddings)
    
    margins:   null,
    paddings:  null,
    
    isRoot:    false,
    isTopRoot: false,
    root:      null, 
    topRoot:   null,
    
    _layoutInfo: null, // once per layout info
    
    _signs: null,
    
    /**
     * The data that the panel uses to obtain "data".
     * @type pvc.data.Data
     */
    data: null,

    dataPartValue: null,
    
    /**
     * Indicates if the top root panel is rendering with animation
     * and, if so, the current phase of animation.
     * 
     * <p>This property can assume the following values:</p>
     * <ul>
     * <li>0 - Not rendering with animation (may even not be rendering at all).</li>
     * <li>1 - Rendering the animation's <i>start</i> point,</li>
     * <li>2 - Rendering the animation's <i>end</i> point.</li>
     * </ul>
     * 
     * @see #animate
     * @see #isAnimatingStart
     * 
     * @type number
     */
    _isAnimating: 0,
    
    _isRubberBandSelecting: false,
    
    /**
     * Shared state between {@link _handleClick} and {@link #_handleDoubleClick}.
     */
    _ignoreClicks: 0,
    
    /**
     * Indicates the name of the role that should be used whenever a V1 dimension value is required.
     * Only the first dimension of the specified role is considered.
     * <p>
     * In a derived class use {@link Object.create} to override this object for only certain
     * v1 dimensions.
     * </p>
     * @ type string
     */
    _v1DimRoleName: {
        'series':   'series',
        'category': 'category',
        'value':    'value'
    },
    
    _sceneTypeExtensions: null,
    
    clickAction:       null,
    doubleClickAction: null,
    
    compatVersion: function(options){
        return this.chart.compatVersion(options);
    },
    
    _createLogInstanceId: function(){
        return "" + 
               this.constructor + this.chart._createLogChildSuffix();
    },
    
    defaultVisibleBulletGroupScene: function(){
        // Return legendBulletGroupScene, 
        // from the first data cell of same dataPartValue and 
        // having one legendBulletGroupScene.
        var colorAxis = this.axes.color;
        if(colorAxis && colorAxis.option('LegendVisible')){
            var dataPartValue = this.dataPartValue;
            return def
                .query(colorAxis.dataCells)
                .where(function(dataCell){ return dataCell.dataPartValue === dataPartValue; })
                .select(function(dataCell){ return dataCell.legendBulletGroupScene; })
                .first(def.truthy)
                ;
        }
        
        return null;
    },
    
    _getLegendBulletRootScene: function(){
        return this.chart._getLegendBulletRootScene();
    },
    
    /**
     * Adds a panel as child.
     */
    _addChild: function(child){
        // <Debug>
        /*jshint expr:true */
        child.parent === this || def.assert("Child has a != parent.");
        // </Debug>
        
        (this._children || (this._children = [])).push(child);
    },
    
    _addSign: function(sign){
        (this._signs || (this._signs = [])).push(sign); 
    },
    
    /* LAYOUT PHASE */
    
    /** 
     * Calculates and sets its size,
     * taking into account a specified total size.
     * 
     * @param {pvc.Size} [availableSize] The total size available for the panel.
     * <p>
     * On root panels this argument is not specified,
     * and the panels' current {@link #width} and {@link #height} are used as default. 
     * </p>
     * @param {object}  [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.force=false] Indicates that the layout should be
     * performed even if it has already been done.
     * @param {pvc.Size} [keyArgs.referenceSize] The size that should be used for 
     * percentage size calculation. 
     * This will typically be the <i>client</i> size of the parent.
     * @param {pvc.Sides} [keyArgs.paddings] The paddings that should be used for 
     * the layout. Default to the panel's paddings {@link #paddings}.
     * @param {pvc.Sides} [keyArgs.margins] The margins that should be used for 
     * the layout. Default to the panel's margins {@link #margins}.
     * @param {boolean} [keyArgs.canChange=true] Whether this is a last time layout. 
     */
    layout: function(availableSize, keyArgs){
        if(!this._layoutInfo || def.get(keyArgs, 'force', false)) {
            
            var referenceSize = def.get(keyArgs, 'referenceSize');
            if(!referenceSize && availableSize){
                referenceSize = def.copyOwn(availableSize);
            }
            
            // Does this panel have a **desired** fixed size specified?
            
            // * size may have no specified components 
            // * referenceSize may be null
            var desiredSize = this.size.resolve(referenceSize);
            var sizeMax     = this.sizeMax.resolve(referenceSize);
            
            if(!availableSize) {
                if(desiredSize.width == null || desiredSize.height == null){
                    throw def.error.operationInvalid("Panel layout without width or height set.");
                }
                
                availableSize = def.copyOwn(desiredSize);
            }
            
            if(!referenceSize && availableSize){
                referenceSize = def.copyOwn(availableSize);
            }
            
            // Apply max size to available size
            if(sizeMax.width != null && availableSize.width > sizeMax.width){
                availableSize.width = sizeMax.width;
            }
            
            if(sizeMax.height != null && availableSize.height > sizeMax.height){
                availableSize.height = sizeMax.height;
            }
            
            var halfBorder   = this.borderWidth / 2;
            var realMargins  = (def.get(keyArgs, 'margins' ) || this.margins ).resolve(referenceSize);
            var realPaddings = (def.get(keyArgs, 'paddings') || this.paddings).resolve(referenceSize);
            
            var margins  = pvc.Sides.inflate(realMargins,  halfBorder);
            var paddings = pvc.Sides.inflate(realPaddings, halfBorder);
            
            var spaceWidth  = margins.width  + paddings.width;
            var spaceHeight = margins.height + paddings.height;
            
            var availableClientSize = new pvc.Size(
                    Math.max(availableSize.width  - spaceWidth,  0),
                    Math.max(availableSize.height - spaceHeight, 0)
                );
            
            var desiredClientSize = def.copyOwn(desiredSize);
            if(desiredClientSize.width != null){
                desiredClientSize.width = Math.max(desiredClientSize.width - spaceWidth, 0);
            }
            
            if(desiredClientSize.height != null){
                desiredClientSize.height = Math.max(desiredClientSize.height - spaceHeight, 0);
            }
            
            var prevLayoutInfo = this._layoutInfo || null;
            var canChange = def.get(keyArgs, 'canChange', true);
            
            var layoutInfo = 
                this._layoutInfo = {
                    canChange:         canChange,
                    referenceSize:     referenceSize,
                    
                    realMargins:       realMargins,
                    realPaddings:      realPaddings,
                    
                    borderWidth:       this.borderWidth,
                    
                    margins:           margins,
                    paddings:          paddings,
                    
                    desiredClientSize: desiredClientSize,
                    clientSize:        availableClientSize,
                    
                    pageClientSize:    prevLayoutInfo ? prevLayoutInfo.pageClientSize : availableClientSize.clone(),
                    previous:          prevLayoutInfo
                };
            
            if(prevLayoutInfo){
                // Free old memory
                delete prevLayoutInfo.previous;
                delete prevLayoutInfo.pageClientSize;
            }
            
            var clientSize = this._calcLayout(layoutInfo);
            
            var size;
            if(!clientSize){
                size = availableSize; // use all available size
                clientSize = availableClientSize;
            } else {
                layoutInfo.clientSize = clientSize;
                size = {
                    width:  clientSize.width  + spaceWidth,
                    height: clientSize.height + spaceHeight
                };
            }
            
            this.isVisible = (clientSize.width > 0 && clientSize.height > 0);
            
            delete layoutInfo.desiredClientSize;
            
            this.width  = size.width;
            this.height = size.height;
            
            if(!canChange && prevLayoutInfo){
                delete layoutInfo.previous;
            }
            
            if(pvc.debug >= 4){
                this._log("  -> layout size={width: " + this.width + ", height: " + this.height + "}"); 
            }
            
            this._onLaidOut();
        }
    },
    
    _onLaidOut: function(){
        if(this.isRoot){
            this.chart._onLaidOut();
        }
    },
    
    /**
     * Override to calculate panel client size.
     * <p>
     * The default implementation performs a dock layout {@link #layout} on child panels
     * and uses all of the available size. 
     * </p>
     * 
     * @param {object} layoutInfo An object that is supplied with layout information
     * and on which to export custom layout information.
     * <p>
     * This object is later supplied to the method {@link #_createCore},
     * and can thus be used to store any layout by-product
     * relevant for the creation of the protovis marks and
     * that should be cleared whenever a layout becomes invalid.
     * </p>
     * <p>
     * The object is supplied with the following properties:
     * </p>
     * <ul>
     *    <li>referenceSize - size that should be used for percentage size calculation. 
     *        This will typically be the <i>client</i> size of the parent.
     *    </li>
     *    <li>margins - the resolved margins object. All components are present, possibly with the value 0.</li>
     *    <li>paddings - the resolved paddings object. All components are present, possibly with the value 0.</li>
     *    <li>desiredClientSize - the desired fixed client size. Do ignore a null width or height property value.</li>
     *    <li>clientSize - the available client size, already limited by a maximum size if specified.</li>
     * </ul>
     * <p>
     * Do not modify the contents of the objects of 
     * any of the supplied properties.
     * </p>
     * @virtual
     */
    _calcLayout: function(layoutInfo){
        
        if(!this._children) {
            return;
        }
        
        var aolMap = pvc.BasePanel.orthogonalLength;
        var aoMap  = pvc.BasePanel.relativeAnchor;
        var altMap = pvc.BasePanel.leftTopAnchor;
        var aofMap = pvc.Offset.namesSidesToOffset;
        
        // Classify children
        
        var fillChildren = [];
        var sideChildren = [];
        
        this._children.forEach(function(child) {
            var a = child.anchor;
            if(a){ // requires layout
                if(a === 'fill') {
                    fillChildren.push(child);
                } else {
                    /*jshint expr:true */
                    def.hasOwn(aoMap, a) || def.fail.operationInvalid("Unknown anchor value '{0}'", [a]);
                    
                    sideChildren.push(child);
                }
            }
        });
    
        // When expanded (see checkChildLayout)
        // a re-layout is performed.
        var clientSize = def.copyOwn(layoutInfo.clientSize);
        var childKeyArgs = {
                force: true,
                referenceSize: clientSize
            };
        
        var margins, remSize;
        
        doMaxTimes(5, layoutCycle, this);
        
        /* Return possibly changed clientSize */
        return clientSize;
        
        // --------------------
        function doMaxTimes(maxTimes, fun, ctx){
            var index = 0;
            while(maxTimes--){
                // remTimes = maxTimes
                if(fun.call(ctx, maxTimes, index) === false){
                    return true;
                }
                index++;
            }
            
            return false;
        }
        
        function layoutCycle(remTimes, iteration){
            if(pvc.debug >= 5){
                this._log("==== LayoutCycle #" + (iteration + 1));
            }
            
            var canResize = (remTimes > 0);
            
            // Reset margins and remSize
            // ** Instances we can mutate
            margins = new pvc.Sides(0);
            remSize = def.copyOwn(clientSize);
            
            // Lay out SIDE child panels
            var child;
            var index = 0;
            var count = sideChildren.length;
            while(index < count){
                child = sideChildren[index];
                if(pvc.debug >= 5){
                    this._log("SIDE Child i=" + index + " at " + child.anchor);
                }
                
                if(layoutChild.call(this, child, canResize)){
                    return true; // resized => break
                }
                
                index++;
            }
            
            // Lay out FILL child panels
            index = 0;
            count = fillChildren.length;
            while(index < count){
                child = fillChildren[index];
                if(pvc.debug >= 5){
                    this._log("FILL Child i=" + index);
                }
                
                if(layoutChild.call(this, child, canResize)){
                    return true; // resized => break
                }
                
                index++;
            }
            
            return false; // !resized
        }
        
        function layoutChild(child, canResize) {
            var resized = false;
            var paddings;
            
            childKeyArgs.canChange = canResize;
            
            doMaxTimes(3, function(remTimes, iteration){
                if(pvc.debug >= 5){
                    this._log("  -> Attempt #" + (iteration + 1));
                }
                
                childKeyArgs.paddings = paddings;
                childKeyArgs.canChange = remTimes > 0;
                
                child.layout(new pvc.Size(remSize), childKeyArgs);
                if(child.isVisible){
                    resized = checkChildResize.call(this, child, canResize);
                    if(resized){
                        return false; // stop
                    }
                    
                    paddings = child._layoutInfo.requestPaddings;
                    if(paddings){
                        // Child wants to repeat its layout with != paddings
                        if(remTimes > 0){
                            paddings = new pvc.Sides(paddings);
                            if(pvc.debug >= 5){
                                this._log("  -> Child requested paddings change: " + pvc.stringify(paddings));
                            }
                            return true; // again
                        }
                        
                        if(pvc.debug >= 2){
                            this._log("  -> [Warning] FILL Child requests paddings change but iterations limit has been reached.");
                        }
                        
                        // ignore overflow
                    }
                    
                    // --------
                    
                    positionChild.call(this, child);
                        
                    if(child.anchor !== 'fill'){
                        updateSide.call(this, child);
                    }
                }
                
                return false; // stop
            }, this);
            
            return resized;
        }
        
        function checkChildResize(child, canResize){
            var resized = false;
            var addWidth = child.width - remSize.width;
            if(addWidth > 0){
                if(pvc.debug >= 3){
                    this._log("  -> addWidth=" + addWidth); 
                }
                
                if(!canResize){
                    if(pvc.debug >= 2){
                        this._log("  -> [Warning] Layout iterations limit reached.");
                    }
                } else {
                    resized = true;
                    
                    remSize   .width += addWidth;
                    clientSize.width += addWidth;
                }
            }
            
            var addHeight = child.height - remSize.height;
            if(addHeight > 0){
                if(pvc.debug >= 3){
                    this._log("  -> addHeight=" + addHeight); 
                }
                
                if(!canResize){
                    if(pvc.debug >= 2){
                        this._log("  -> [Warning] Layout iterations limit reached.");
                    }
                } else {
                    resized = true;
                    
                    remSize   .height += addHeight;
                    clientSize.height += addHeight;
                }
            }
            
            return resized;
        }
        
        function positionChild(child) {
            var side  = child.anchor;
            var align = child.align;
            var alignTo = child.alignTo;
            var sidePos;
            if(side === 'fill'){
                side = 'left';
                sidePos = margins.left + remSize.width / 2 - (child.width / 2);
                align = alignTo = 'middle';
            } else {
                sidePos = margins[side];
            }
            
            var sideo, sideOPosChildOffset;
            switch(align){
                case 'top':
                case 'bottom':
                case 'left':
                case 'right':
                    sideo = align;
                    sideOPosChildOffset = 0;
                    break;
                
                case 'center':
                case 'middle':
                    // 'left', 'right' -> 'top'
                    // else -> 'left'
                    sideo = altMap[aoMap[side]];
                    
                    // left -> width; top -> height
                    sideOPosChildOffset = - child[aolMap[sideo]] / 2;
                    break;
            }
            
            
            var sideOPosParentOffset;
            var sideOTo;
            switch(alignTo){
                case 'top':
                case 'bottom':
                case 'left':
                case 'right':
                    sideOTo = alignTo;
                    sideOPosParentOffset = (sideOTo !== sideo) ? remSize[aolMap[sideo]] : 0;
                    break;

                case 'center':
                case 'middle':
                    sideOTo = altMap[aoMap[side]];
                    
                    sideOPosParentOffset = remSize[aolMap[sideo]] / 2;
                    break;
                        
                case 'page-center':
                case 'page-middle':
                    sideOTo = altMap[aoMap[side]];
                    
                    var lenProp = aolMap[sideo];
                    var pageLen = Math.min(remSize[lenProp], layoutInfo.pageClientSize[lenProp]);
                    sideOPosParentOffset = pageLen / 2;
                    break;
            }
            
            var sideOPos = margins[sideOTo] + sideOPosParentOffset + sideOPosChildOffset;
            
            var resolvedOffset = child.offset.resolve(remSize);
            if(resolvedOffset){
                sidePos  += resolvedOffset[aofMap[side ]] || 0;
                sideOPos += resolvedOffset[aofMap[sideo]] || 0;
            }
            
            if(child.keepInBounds){
                if(sidePos < 0){
                    sidePos = 0;
                }
                
                if(sideOPos < 0){
                    sideOPos = 0;
                }
            }
            
            child.setPosition(
                    def.set({}, 
                        side,  sidePos,
                        sideo, sideOPos));
        }
        
        // Decreases available size and increases margins
        function updateSide(child) {
            var side   = child.anchor;
            var sideol = aolMap[side];
            var olen   = child[sideol];
            
            margins[side]   += olen;
            remSize[sideol] -= olen;
        }
    },
    
    invalidateLayout: function(){
        this._layoutInfo = null;
        
        if(this._children) {
            this._children.forEach(function(child){
                child.invalidateLayout();
            });
        }
    },
    
    /** 
     * CREATION PHASE
     * 
     * Where the protovis main panel, and any other marks, are created.
     * 
     * If the layout has not been performed it is so now.
     */
    _create: function(force) {
        if(!this.pvPanel || force) {
            
            this.pvPanel = null;
            
            delete this._signs;
            
            /* Layout */
            this.layout();
            
            if(!this.isVisible){
                return;
            }
            
            if(this.isRoot){
                this._creating();
            }
            
            var margins  = this._layoutInfo.margins;
            var paddings = this._layoutInfo.paddings;
            
            /* Protovis Panel */
            if(this.isTopRoot) {
                this.pvRootPanel = 
                this.pvPanel = new pv.Panel().canvas(this.chart.options.canvas);
                
                if(margins.width > 0 || margins.height > 0){
                    this.pvPanel
                        .width (this.width )
                        .height(this.height);
                    
                    // As there is no parent panel,
                    // the margins cannot be accomplished by positioning
                    // on the parent panel and sizing.
                    // We thus create another panel to be a child of pvPanel
                   
                    this.pvPanel = this.pvPanel.add(pv.Panel);
                }
            } else {
                this.pvPanel = this.parent.pvPanel.add(this.type);
            }
            
            var pvBorderPanel = this.pvPanel;
            
            // Set panel size
            var width  = this.width  - margins.width;
            var height = this.height - margins.height;
            pvBorderPanel
                .width (width)
                .height(height);
            
            // Set panel positions
            var hasPositions = {};
            def.eachOwn(this.position, function(v, side){
                pvBorderPanel[side](v + margins[side]);
                hasPositions[this.anchorLength(side)] = true;
            }, this);
            
            if(!hasPositions.width && margins.left > 0){
                pvBorderPanel.left(margins.left);
            }
            
            if(!hasPositions.height && margins.top > 0){
                pvBorderPanel.top(margins.top);
            }
            
            // Check padding
            if(paddings.width > 0 || paddings.height > 0){
                // We create separate border (outer) and inner (padding) panels
                this.pvPanel = pvBorderPanel.add(pv.Panel)
                                   .width (width  - paddings.width )
                                   .height(height - paddings.height)
                                   .left(paddings.left)
                                   .top (paddings.top );
            }
            
            pvBorderPanel.borderPanel  = pvBorderPanel;
            pvBorderPanel.paddingPanel = this.pvPanel;
            
            this.pvPanel.paddingPanel  = this.pvPanel;
            this.pvPanel.borderPanel   = pvBorderPanel;
            
            if(pvc.debug >= 15){
                this.pvPanel // inner
                    .strokeStyle('lightgreen')
                    .lineWidth(1)
                    .strokeDasharray('- ');
                
                pvBorderPanel // outer
                    .strokeStyle('lightblue')
                    .lineWidth(1)
                    .strokeDasharray(null); 
            }
            
            var extensionId = this._getExtensionId();
            if(extensionId != null){ // '' is allowed cause this is relative to #_getExtensionPrefix
                // Wrap the panel that is extended with a Panel sign
                new pvc.visual.Panel(this, null, {
                    panel:       pvBorderPanel,
                    extensionId: extensionId
                });
            }
            
            /* Protovis marks that are pvc Panel specific,
             * and/or create child panels.
             */
            this._createCore(this._layoutInfo);
            
            /* RubberBand */
            if (this.isTopRoot && this.chart.options.selectable && pv.renderer() !== 'batik'){
                this._initRubberBand();
            }

            /* Extensions */
            this.applyExtensions();
        }
    },

    _creating: function(){
        if(this._children) {
            this._children.forEach(function(child){
                child._creating();
            });
        }
    },
    
    /**
     * Override to create specific protovis components for a given panel.
     * 
     * The default implementation calls {@link #_create} on each child panel.
     * 
     * @param {object} layoutInfo The object with layout information 
     * "exported" by {@link #_calcLayout}.
     * 
     * @virtual
     */
    _createCore: function(layoutInfo){
        if(this._children) {
            this._children.forEach(function(child){
                child._create();
            });
        }
    },
    
    /** 
     * RENDER PHASE
     * 
     * Where protovis components are rendered.
     * 
     * If the creation phase has not been performed it is so now.
     */
    
    /**
     * Renders the top root panel.
     * <p>
     * The render is always performed from the top root panel,
     * independently of the panel on which the method is called.
     * </p>
     * 
     * @param {object} [keyArgs] Keyword arguments.
     * @param {boolean} [keyArgs.bypassAnimation=false] Indicates that animation should not be performed.
     * @param {boolean} [keyArgs.recreate=false] Indicates that the panel and its descendants should be recreated.
     */
    render: function(keyArgs){
        
        if(!this.isTopRoot) {
            return this.topRoot.render(keyArgs);
        }
        
        this._create(def.get(keyArgs, 'recreate', false));
        
        if(!this.isVisible){
            return;
        }
        
        this._onRender();
        
        var options = this.chart.options;
        var pvPanel = this.pvRootPanel;
        
        this._isAnimating = options.animate && !def.get(keyArgs, 'bypassAnimation', false) ? 1 : 0;
        try {
            // When animating, renders the animation's 'start' point
            pvPanel.render();
            
            // Transition to the animation's 'end' point
            if (this._isAnimating) {
                this._isAnimating = 2;
                
                var me = this;
                pvPanel
                    .transition()
                    .duration(2000)
                    .ease("cubic-in-out")
                    .start(function(){
                        me._isAnimating = 0;
                        me._onRenderEnd(true);
                    });
            } else {
                this._onRenderEnd(false);
            }
        } finally {
            this._isAnimating = 0;
        }
    },
    
    _onRender: function(){
        var renderCallback = this.chart.options.renderCallback;
        if (renderCallback) {
            if(this.compatVersion() <= 1){
                renderCallback.call(this.chart);
            } else {
                var context = this._getContext();
                renderCallback.call(context, context.scene);
            }
        }
    },
    
    /**
     * Called when a render has ended.
     * When the render performed an animation
     * and the 'animated' argument will have the value 'true'.
     *
     * The default implementation calls each child panel's
     * #_onRenderEnd method.
     * @virtual
     */
    _onRenderEnd: function(animated){
        if(this._children){
            this._children.forEach(function(child){
                child._onRenderEnd(animated);
            });
        }
    },
    
    /**
     * The default implementation renders
     * the marks returned by #_getSelectableMarks, 
     * or this.pvPanel if none is returned (and it has no children)
     * which is generally in excess of what actually requires
     * to be re-rendered.
     * The call is then propagated to any child panels.
     * 
     * @virtual
     */
    renderInteractive: function(){
        if(this.isVisible){
            var pvMarks = this._getSelectableMarks();
            if(pvMarks && pvMarks.length){
                pvMarks.forEach(function(pvMark){ pvMark.render(); });
            } else if(!this._children) {
                this.pvPanel.render();
                return;
            }
            
            if(this._children){
                this._children.forEach(function(child){
                    child.renderInteractive();
                });
            }
        }
    },

    /**
     * Returns an array of marks whose instances are associated to a datum, or null.
     * @virtual
     */
    _getSelectableMarks: function(){
        return null;
    },
    
    
    /* ANIMATION */
    
    animate: function(start, end) {
        return (this.topRoot._isAnimating === 1) ? start : end;
    },
    
    /**
     * Indicates if the panel is currently 
     * rendering the animation start phase.
     * <p>
     * Prefer using this function instead of {@link #animate} 
     * whenever its <tt>start</tt> or <tt>end</tt> arguments
     * involve a non-trivial calculation. 
     * </p>
     * 
     * @type boolean
     */
    isAnimatingStart: function() {
        return (this.topRoot._isAnimating === 1);
    },
    
    /**
     * Indicates if the panel is currently 
     * rendering animation.
     * 
     * @type boolean
     */
    isAnimating: function() {
        return (this.topRoot._isAnimating > 0);
    },
    
    /* SIZE & POSITION */
    setPosition: function(position){
        for(var side in position){
            if(def.hasOwn(pvc.Sides.namesSet, side)){
                var s = position[side]; 
                if(s === null) {
                    delete this.position[side];
                } else {
                    s = +s; // -> to number
                    if(!isNaN(s) && isFinite(s)){
                        this.position[side] = s;
                    }
                }
            }
        }
    },
    
    createAnchoredSize: function(anchorLength, size){
        if (this.isAnchorTopOrBottom()) {
            return new pvc.Size(size.width, Math.min(size.height, anchorLength));
        } 
        return new pvc.Size(Math.min(size.width, anchorLength), size.height);
    },
    
    /* EXTENSION */
    
    /**
     * Override to apply specific extensions points.
     * @virtual
     */
    applyExtensions: function(){
        if (this._signs) {
            this._signs.forEach(function(sign){
                sign.applyExtensions();
            });
        }
    },

    /**
     * Extends a protovis mark with extension points 
     * having a given panel-relative component id.
     */
    extend: function(mark, id, keyArgs) {
        this.chart.extend(mark, this._makeExtensionAbsId(id), keyArgs);
    },
    
    /**
     * Extends a protovis mark with extension points 
     * having a given absolute component id.
     */
    extendAbs: function(mark, absId, keyArgs) {
        this.chart.extend(mark, absId, keyArgs);
    },
    
    _extendSceneType: function(typeKey, type, names){
        var typeExts = def.get(this._sceneTypeExtensions, typeKey);
        if(typeExts){
            pvc.extendType(type, typeExts, names);
        }
    },
    
    _absBaseExtId: {abs: 'base'},
    _absSmallBaseExtId: {abs: 'smallBase'},
    
    _getExtensionId: function(){
        if (this.isRoot) {
            return !this.chart.parent ? this._absBaseExtId : this._absSmallBaseExtId;
        }
    },
    
    _getExtensionPrefix: function(){
        return this._extensionPrefix;
    },
    
    _makeExtensionAbsId: function(id){
        return pvc.makeExtensionAbsId(id, this._getExtensionPrefix());
    },
    
    /**
     * Obtains an extension point given its identifier and property.
     */
    _getExtension: function(id, prop) {
        return this.chart._getExtension(this._makeExtensionAbsId(id), prop);
    },
    
    _getExtensionAbs: function(absId, prop) {
        return this.chart._getExtension(absId, prop);
    },

    _getConstantExtension: function(id, prop) {
        return this.chart._getConstantExtension(this._makeExtensionAbsId(id), prop);
    },
    
    // -----------------------------
    
    /**
     * Returns the underlying protovis Panel.
     * If 'layer' is specified returns
     * the protovis panel for the specified layer name.
     */
    getPvPanel: function(layer) {
        var mainPvPanel = this.pvPanel;
        if(!layer){
            return mainPvPanel;
        }

        if(!this.parent){
            throw def.error.operationInvalid("Layers are not possible in a root panel.");
        }

        if(!mainPvPanel){
            throw def.error.operationInvalid(
               "Cannot access layer panels without having created the main panel.");
        }

        var pvPanel = null;
        if(!this._layers){
            this._layers = {};
        } else {
            pvPanel = this._layers[layer];
        }

        if(!pvPanel){
            var pvParentPanel = this.parent.pvPanel;
            
            pvPanel = pvParentPanel.borderPanel.add(this.type)
                .extend(mainPvPanel.borderPanel);
            
            var pvBorderPanel = pvPanel;

            if(mainPvPanel !== mainPvPanel.borderPanel){
                pvPanel = pvBorderPanel.add(pv.Panel)
                                       .extend(mainPvPanel);
            }
            
            pvBorderPanel.borderPanel  = pvBorderPanel;
            pvBorderPanel.paddingPanel = pvPanel;
            
            pvPanel.paddingPanel  = pvPanel;
            pvPanel.borderPanel   = pvBorderPanel;
            
            this.initLayerPanel(pvPanel, layer);

            this._layers[layer] = pvPanel;
        }

        return pvPanel;
    },
    
    /**
     * Initializes a new layer panel.
     * @virtual
     */
    initLayerPanel: function(pvPanel, layer){
    },
    
    /* EVENTS & VISUALIZATION CONTEXT */
    _getV1DimName: function(v1Dim){
        var dimNames = this._v1DimName || (this._v1DimNameCache = {});
        var dimName  = dimNames[v1Dim];
        if(dimName == null) {
            var role = this.chart.visualRoles(this._v1DimRoleName[v1Dim], {assertExists: false});
            dimName = role ? role.firstDimensionName() : '';
            dimNames[v1Dim] = dimName;
        }
        
        return dimName;
    },
    
    _getV1Datum: function(scene){
        return scene.datum;
    },
    
    /**
     * Creates the visualization context of the panel.
     * <p>
     * Override to use a specific visualization context class. 
     * </p>
     * 
     * @param {pv.Mark} mark The protovis mark being rendered or targeted by an event.
     * @param {object} [event] An event object.
     * @type pvc.visual.Context
     * @virtual
     */
    _createContext: function(mark, ev){
        return new pvc.visual.Context(this, mark, ev);
    },
    
    /**
     * Obtains the visualization context of the panel,
     * prepared for a specified mark and event.
     *  
     * Creates a new context when necessary.
     * 
     * <p>
     * Override to perform specific updates. 
     * </p>
     * 
     * @param {pv.Mark} mark The protovis mark being rendered or targeted by an event.
     * @param {object} [event] An event object.
     * @type pvc.visual.Context
     * @virtual
     */
    _getContext: function(mark, ev){
        var context = this._context;
        if(!context || context.isPinned){
            this._context = this._createContext(mark, ev);
        } else {
            /*global visualContext_update:true */
            visualContext_update.call(context, mark, ev);
        }
        
        return this._context;
    },
    
    _isTooltipEnabled: function(){
        return !this.isRubberBandSelecting() && !this.isAnimating();
    },
    
    _ensurePropEvents: function(pvMark){
        // labels and other marks don't receive events by default
        var events = pvMark.propertyValue('events', /*inherit*/ true);
        if(!events || events === 'none'){
            pvMark.events('all');
        }
    },
    
    /* HOVERABLE */
    _addPropHoverable: function(pvMark){
        var panel  = this;
        
        var onEvent;
        var offEvent;
//        switch(pvMark.type) {
//            default:
//            case 'dot':
//            case 'line':
//            case 'area':
//            case 'rule':
//                onEvent  = 'point';
//                offEvent = 'unpoint';
//               panel._requirePointEvent();
//                break;

//            default:
                onEvent = 'mouseover';
                offEvent = 'mouseout';
//                break;
//        }
        
        pvMark
            .event(onEvent, function(scene){
                scene.setActive(true);

                if(!panel.isRubberBandSelecting() && !panel.isAnimating()) {
                    panel.renderInteractive();
                }
            })
            .event(offEvent, function(scene){
                if(scene.clearActive()) {
                    /* Something was active */
                    if(!panel.isRubberBandSelecting() && !panel.isAnimating()) {
                        panel.renderInteractive();
                    }
                }
            });
        
        this._ensurePropEvents(pvMark);
    },
    
    /* TOOLTIP */ 
    _addPropTooltip: function(pvMark, keyArgs){
        var chartTipOptions = this.chart._tooltipOptions;
        
        var tipOptions;
        var nowTipOptions = def.get(keyArgs, 'options');
        if(nowTipOptions){
            tipOptions = def.create(chartTipOptions, nowTipOptions);
        } else {
            tipOptions = Object.create(chartTipOptions);
        }
        
        var buildTooltip = def.get(keyArgs, 'buildTooltip') ||
                           this._getTooltipBuilder(tipOptions);
        if(!buildTooltip){
            return;
        }
        
        tipOptions.isEnabled = this._isTooltipEnabled.bind(this);
        
        var tipsyEvent = def.get(keyArgs, 'tipsyEvent');
        if(!tipsyEvent) {
//          switch(pvMark.type) {
//                case 'dot':
//                case 'line':
//                case 'area':
//                    this._requirePointEvent();
//                    tipsyEvent = 'point';
//                    tipOptions.usesPoint = true;
//                    break;
                
//                default:
                    tipsyEvent = 'mouseover';
//            }
        }
        
        var isLazy = def.get(keyArgs, 'isLazy', true);
        
        pvMark.localProperty("tooltip"/*, Function | String*/) 
              .tooltip(this._createTooltipProp(pvMark, buildTooltip, isLazy))
              .title(function(){ return '';} ) // Prevent browser tooltip
              .event(tipsyEvent, pv.Behavior.tipsy(tipOptions));
        
        this._ensurePropEvents(pvMark);
    },
    
    _getTooltipBuilder: function(tipOptions){
        var options = this.chart.options;
        var isV1Compat = this.compatVersion() <= 1;
        
        var tooltipFormat = tipOptions.format;
        if(!tooltipFormat) {
            if(!isV1Compat){
                return this._buildDataTooltip;
            }
            
            tooltipFormat = options.v1StyleTooltipFormat;
            if(!tooltipFormat){
                return;
            }
        }
        
        if(isV1Compat){
            return function(context){
                return tooltipFormat.call(
                        context.panel, 
                        context.getV1Series(),
                        context.getV1Category(),
                        context.getV1Value() || '',
                        context.getV1Datum());
            };
        }
        
        return function(context){
            return tooltipFormat.call(context, context.scene);
        };
    },
    
    _createTooltipProp: function(pvMark, buildTooltip, isLazy){
        var myself = this;
        if(!isLazy){
            return function(){
                // Capture current context
                var context = myself._getContext(pvMark, null);
                
                // discard intermediate points
                if (context.scene.isIntermediate){
                   return null;
                }
                
                return buildTooltip.call(myself, context);
            };
        }
        
        return function(){
            // Capture current context
            var context = myself._getContext(pvMark, null);
            
            // discard intermediate points
            if (context.scene.isIntermediate){
                return null;
            }
            
            context.pin();
            
            var tooltip;
            return function() {
                if(tooltip == null) {
                    tooltip = buildTooltip.call(myself, context);
                    context = null; // release pinned context;
                } 
                
                return tooltip; 
            };
        };
    },
    
    _requirePointEvent: function(radius){
        if(!this.isTopRoot) {
            return this.topRoot._requirePointEvent(radius);
        }

        if(!this._attachedPointEvent){

            // Fire point and unpoint events
            this.pvPanel
                .events('all')
                .event("mousemove", pv.Behavior.point(radius || 20));

            this._attachedPointEvent = true;
        }
    },
    
    _buildDataTooltip: function(context){

        var scene = context.scene;
        
        // No group and no datum?
        if(!scene.atoms) {
            return "";
        }
        
        var group = scene.group;
        var isMultiDatumGroup = group && group._datums.length > 1;
        
        // Single null datum?
        var firstDatum = scene.datum;
        if(!isMultiDatumGroup && (!firstDatum || firstDatum.isNull)) {
            return "";
        }
        
        var chart = this.chart;
        var data = chart.data;
        var visibleKeyArgs = {visible: true};
        
        var tooltip = [];
        
        if(firstDatum.isInterpolated){
            tooltip.push('<i>Interpolation</i>: ' + def.html.escape(firstDatum.interpolation) + '<br/>');
        } else if(firstDatum.isTrend){
            tooltip.push('<i>Trend</i>: ' + def.html.escape(firstDatum.trendType) + '<br/>');
        }
        
        var complexType = data.type;
        
        /* TODO: Big HACK to prevent percentages from
         * showing up in the Lines of BarLine
         */
        var playingPercentMap = context.panel.stacked === false ? 
                                null :
                                complexType.getPlayingPercentVisualRoleDimensionMap();
        
        var commonAtoms = isMultiDatumGroup ? group.atoms : scene.datum.atoms;
        var commonAtomsKeys = complexType.sortDimensionNames(def.keys(commonAtoms));
        
        function addDim(escapedDimLabel, label){
            tooltip.push('<b>' + escapedDimLabel + "</b>: " + (def.html.escape(label) || " - ") + '<br/>');
        }
        
        function calcPercent(atom, dimName) {
            var pct;
            if(group) {
                pct = group.dimensions(dimName).percentOverParent(visibleKeyArgs);
            } else {
                pct = data.dimensions(dimName).percent(atom.value);
            }
            
            return chart.options.percentValueFormat.call(null, pct);
        }
        
        var anyCommonAtom = false;
        commonAtomsKeys.forEach(function(dimName){
            var atom = commonAtoms[dimName];
            var dimType = atom.dimension.type;
            if(!dimType.isHidden){
                if(!isMultiDatumGroup || atom.value != null) {
                    anyCommonAtom = true;
                    
                    var valueLabel = atom.label;
                    if(playingPercentMap && playingPercentMap.has(dimName)) {
                        valueLabel += " (" + calcPercent(atom, dimName) + ")";
                    }
                    
                    addDim(def.html.escape(atom.dimension.type.label), valueLabel);
                }
            }
        }, this);
        
        if(isMultiDatumGroup) {
            if(anyCommonAtom){
                tooltip.push('<hr />');
            }
            
            tooltip.push("<b>#</b>: " + group._datums.length + '<br/>');
            
            complexType.sortDimensionNames(group.freeDimensionNames())
            .forEach(function(dimName){
                var dim = group.dimensions(dimName);
                if(!dim.type.isHidden){
                    var dimLabel = def.html.escape(dim.type.label),
                        valueLabel;
                    
                    if(dim.type.valueType === Number) {
                        // Sum
                        valueLabel = dim.format(dim.sum(visibleKeyArgs));
                        if(playingPercentMap && playingPercentMap.has(dimName)) {
                            valueLabel += " (" + calcPercent(null, dimName) + ")";
                        }
                        
                        dimLabel = "&sum; " + dimLabel;
                    } else {
                        valueLabel = dim.atoms(visibleKeyArgs).map(function(atom){ return atom.label || "- "; }).join(", ");
                    }
                    
                    addDim(dimLabel, valueLabel);
                }
            });
        }
        
        return '<div style="text-align: left;">' + tooltip.join('\n') + '</div>';
    },
    
    /* CLICK & DOUBLE-CLICK */
    _addPropClick: function(pvMark){
        var myself = this;
        
        function onClick(){
            var ev = arguments[arguments.length - 1];
            return myself._handleClick(this, ev);
        }
        
        pvMark.cursor("pointer")
              .event("click", onClick);
        
        this._ensurePropEvents(pvMark);
    },

    _addPropDoubleClick: function(pvMark){
        var myself = this;
        
        function onDoubleClick(){
            var ev = arguments[arguments.length - 1];
            return myself._handleDoubleClick(this, ev);
        }
        
        pvMark.cursor("pointer")
              .event("dblclick", onDoubleClick);
        
        this._ensurePropEvents(pvMark);
    },
    
    _isDoubleClickable: function(keyArgs){
        var options = keyArgs || this.chart.options;
        return options.clickable && !!this.doubleClickAction;
    },
    
    _handleDoubleClick: function(pvMark, ev){
        if(!this._isDoubleClickable()){
            return;
        }
        
        this._ignoreClicks = 2;
        
        var sign = pvMark.sign;
        if(!sign || sign.isDoubleClickable()){
            var context = this._getContext(pvMark, ev);
            this._onDoubleClick(context);
        }
    },
    
    _onDoubleClick: function(context){
        var handler = this.doubleClickAction;
        if(handler){
            if(this.compatVersion() <= 1){
                this._onV1DoubleClick(context, handler);
            } else {
                handler.call(context, context.scene);
            }
        }
    },
    
    _onV1DoubleClick: function(context, handler){
        handler.call(context.pvMark, 
                /* V1 ARGS */
                context.getV1Series(),
                context.getV1Category(),
                context.getV1Value(),
                context.event,
                context.getV1Datum());
    },
    
    _isClickable: function(keyArgs){
        var options = keyArgs || this.chart.options;
        return options.clickable && !!this.clickAction;
    },
    
    _shouldHandleClick: function(keyArgs){
        var options = keyArgs || this.chart.options;
        return options.selectable || this._isClickable(options);
    },
    
    _handleClick: function(pvMark, ev){
        if(!this._shouldHandleClick()){
            return;
        }

        var options = this.chart.options,
            context;
        
        if(!this.doubleClickAction){
            // Use shared context
            context = this._getContext(pvMark, ev);
            this._handleClickCore(context);
        } else {
            // Delay click evaluation so that
            // it may be canceled if double click meanwhile
            // fires.
            var myself = this;
            
            // Capture current context
            context = this._createContext(pvMark, ev);
            /*global window:true*/
            window.setTimeout(
                function(){
                    myself._handleClickCore.call(myself, context);
                },
                options.doubleClickMaxDelay || 300);

        }
    },

    _handleClickCore: function(context){
        if(this._ignoreClicks) {
            this._ignoreClicks--;
        } else {
            var sign = context.sign;
            if(!sign || sign.isClickable()){
                this._onClick(context);
            }
            
            if((sign  && sign.isSelectable()) || 
               (!sign && this.chart.options.selectable && context.scene.datum)){
                this._onSelect(context);
            }
        }
    },
    
    _onClick: function(context){
        var handler = this.clickAction;
        if(handler){
            if(this.compatVersion() <= 1){
                this._onV1Click(context, handler);
            } else {
                handler.call(context, context.scene);
            }
        }
    },
    
    _onV1Click: function(context, handler){
        handler.call(context.pvMark, 
                /* V1 ARGS */
                context.getV1Series(),
                context.getV1Category(),
                context.getV1Value(),
                context.event,
                context.getV1Datum());
    },
    
    /* SELECTION & RUBBER-BAND */
    _onSelect: function(context){
        var datums = context.scene.datums().array();
        if(datums.length){
            var chart = this.chart;
                
            chart._updatingSelections(function(){
                
                datums = chart._onUserSelection(datums);
                if(datums && datums.length){
                    if(chart.options.ctrlSelectMode && !context.event.ctrlKey){
                        chart.data.replaceSelected(datums);
                    } else {
                        pvc.data.Data.toggleSelected(datums);
                    }
                }
            }, this);
        }
    },
    
    isRubberBandSelecting: function(){
        return this.topRoot._isRubberBandSelecting;
    },
    
    /**
     * Add rubber-band functionality to panel.
     * Override to prevent rubber band selection.
     * 
     * @virtual
     */
    _initRubberBand: function(){
        var myself = this,
            chart = this.chart,
            options  = chart.options,
            data = chart.data;

        var dMin = 2; // Minimum dx or dy for a drag to be considered a rubber band selection

        this._isRubberBandSelecting = false;

        // Rubber band
        var rubberPvParentPanel = this.pvRootPanel || this.pvPanel.paddingPanel,
            toScreen,
            rb;
        
        var selectBar = 
            this.selectBar = 
            new pvc.visual.Bar(this, rubberPvParentPanel, {
                extensionId:   'rubberBand',
                normalStroke:  true,
                noHover:       true,
                noSelect:      true,
                noClick:       true,
                noDoubleClick: true,
                noTooltip:    true
            })
            .override('defaultStrokeWidth', function(){
                return 1.5;
            })
            .override('defaultColor', function(type){
                return type === 'stroke' ? 
                       '#86fe00' :                 /* 'rgb(255,127,0)' */ 
                       'rgba(203, 239, 163, 0.6)'  /* 'rgba(255, 127, 0, 0.15)' */
                       ;
            })
            .override('interactiveColor', function(color){
                return color;
            })
            .pvMark
            .lock('data', [new pvc.visual.Scene(null, {panel: this})])
            .lock('visible', function(){ return !!rb;  })
            .lock('left',    function(){ return rb.x;  })
            .lock('right')
            .lock('top',     function(){ return rb.y;  })
            .lock('bottom')
            .lock('width',   function(){ return rb.dx; })
            .lock('height',  function(){ return rb.dy; })
            .lock('cursor')
            .lock('events', 'none')
            ;
        
        // IE must have a fill style to fire events
        if(!this._getExtensionAbs('base', 'fillStyle')){
            rubberPvParentPanel.fillStyle(pvc.invisibleFill);
        }
        
        // Require all events, wether it's painted or not
        rubberPvParentPanel.events('all');
        
        // NOTE: Rubber band coordinates are always transformed to canvas/client 
        // coordinates (see 'select' and 'selectend' events)
         
        var selectionEndedDate;
        rubberPvParentPanel
            .event('mousedown', pv.Behavior.select({autoRefresh: false, datumIsRect: false}))
            .event('select', function(){
                if(!rb){
                    if(myself.isAnimating()){
                        return;
                    }
                    
                    var rb1 = this.selectionRect;
                    if(Math.sqrt(rb1.dx * rb1.dx + rb1.dy * rb1.dy) <= dMin){
                        return;
                    }
                    
                    rb = rb1;
                    myself._isRubberBandSelecting = true;
                    
                    if(!toScreen){
                        toScreen = rubberPvParentPanel.toScreenTransform();
                    }
                    
                    myself.rubberBand = rb.clone().apply(toScreen);
                } else {
                    rb = this.selectionRect;
                }
                
                selectBar.render();
            })
            .event('selectend', function(){
                if(rb){
                    var ev = arguments[arguments.length - 1];
                    
                    if(!toScreen){
                        toScreen = rubberPvParentPanel.toScreenTransform();
                    }
                    
                    myself.rubberBand = rb = this.selectionRect.apply(toScreen);
                    
                    rb = null;
                    myself._isRubberBandSelecting = false;
                    selectBar.render(); // hide rubber band
                    
                    // Process selection
                    myself._onRubberBandSelectionEnd(ev);
                    
                    selectionEndedDate = new Date();
                    
                    myself.rubberBand = rb = null;
                }
            });
        
        if(options.clearSelectionMode === 'emptySpaceClick'){
            rubberPvParentPanel
                .event("click", function() {
                    // It happens sometimes that the click is fired 
                    //  after mouse up, ending up clearing a just made selection.
                    if(selectionEndedDate){
                        var timeSpan = new Date() - selectionEndedDate;
                        if(timeSpan < 300){
                            selectionEndedDate = null;
                            return;
                        }
                    }
                    
                    if(data.owner.clearSelected()) {
                        myself.chart.updateSelections();
                    }
                });
        }
    },
    
    _onRubberBandSelectionEnd: function(ev){
        if(pvc.debug >= 3) {
            this._log('rubberBand ' + pvc.stringify(this.rubberBand));
        }
        
        var keyArgs = {toggle: false}; // output argument
        var datums = this._getDatumsOnRubberBand(ev, keyArgs);
        if(datums){
        var chart = this.chart;
            
            //this._log("Selecting Datum count=" + datums.length + 
            //          " keys=\n" + datums.map(function(d){return d.key;}).join('\n'));
            
            // Make sure selection changed action is called only once
            // Checks if any datum's selected changed, at the end
            chart._updatingSelections(function(){
                var clearBefore = !ev.ctrlKey && chart.options.ctrlSelectMode;
                if(clearBefore){
                chart.data.owner.clearSelected();
                    pvc.data.Data.setSelected(datums, true);
                } else if(keyArgs.toggle){
                    pvc.data.Data.toggleSelected(datums);
                } else {
                    pvc.data.Data.setSelected(datums, true);
            }
            });
            
            //this._log("End rubber band selection");
        }
    },
    
    _getDatumsOnRubberBand: function(ev, keyArgs){
        var datumMap = new def.Map();
        
        this._getDatumsOnRect(datumMap, this.rubberBand, keyArgs);
            
        var datums = datumMap.values();
        if(datums.length){
            datums = this.chart._onUserSelection(datums);
            if(datums && !datums.length){
                datums = null;
            }
        }
        
        return datums;
    },
    
    // Callback to handle end of rubber band selection
    _getDatumsOnRect: function(datumMap, rect, keyArgs){
        this._getOwnDatumsOnRect(datumMap, rect, keyArgs);
        
        if(this._children) {
            this._children.forEach(function(child){
                child._getDatumsOnRect(datumMap, rect, keyArgs);
            }, this);
        }
    },
    
    _getOwnDatumsOnRect: function(datumMap, rect, keyArgs){
        var any = false;
        
        if(this.isVisible){
            var pvMarks = this._getSelectableMarks();
            if(pvMarks && pvMarks.length){
                pvMarks.forEach(function(pvMark){
                    this._eachMarkDatumOnRect(pvMark, rect, function(datum){
                        datumMap.set(datum.id, datum);
                        any = true;
                    }, this);
                    
                }, this);
            }
        }
        
        return any;
    },
    
    _eachMarkDatumOnRect: function(pvMark, rect, fun, ctx){
        
        // center, partial and total (not implemented)
        var selectionMode = def.get(pvMark, 'rubberBandSelectionMode', 'partial');
        var useCenter = (selectionMode === 'center');
        
        pvMark.eachInstanceWithData(function(scenes, index, toScreen){
            
            var shape = pvMark.getShape(scenes, index);
            
            shape = (useCenter ? shape.center() : shape).apply(toScreen);
            
            processShape.call(this, shape, scenes[index], index);
        }, this);
        
        function processShape(shape, instance, index) {
        
            if (shape.intersectsRect(rect)){
                var group = instance.group;
                var datums = group ? group._datums : def.array.as(instance.datum);
                if(datums) {
                    datums.forEach(function(datum){
                        if(!datum.isNull) {
                            if(pvc.debug >= 20) {
                                this._log("Rubbered Datum.key=" + datum.key + ": " + pvc.stringify(shape) + " mark type: " + pvMark.type + " index=" + index);
                            }
                    
                            fun.call(ctx, datum);
                        }
                    }, this);
                }
            }
        }
    },
    
    /* ANCHORS & ORIENTATION */
    
    /**
     * Returns true if the anchor is one of the values 'top' or
     * 'bottom'.
     */
    isAnchorTopOrBottom: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return anchor === "top" || anchor === "bottom";
    },

    anchorOrtho: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return pvc.BasePanel.relativeAnchor[anchor];
    },

    anchorOrthoMirror: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return pvc.BasePanel.relativeAnchorMirror[anchor];
    },

    anchorOpposite: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return pvc.BasePanel.oppositeAnchor[anchor];
    },

    anchorLength: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return pvc.BasePanel.parallelLength[anchor];
    },

    anchorOrthoLength: function(anchor) {
        if (!anchor) {
            anchor = this.anchor;
        }
        return pvc.BasePanel.orthogonalLength[anchor];
    },

    isOrientationVertical: function(orientation) {
        return this.chart.isOrientationVertical(orientation);
    },

    isOrientationHorizontal: function(orientation) {
        return this.chart.isOrientationHorizontal(orientation);
    }
})
.addStatic({
    // Determine what is the associated method to
    // call to position the labels correctly
    relativeAnchor: {
        top: "left",
        bottom: "left",
        left: "bottom",
        right: "bottom"
    },
    
    leftBottomAnchor: {
        top:    "bottom",
        bottom: "bottom",
        left:   "left",
        right:  "left"
    },
    
    leftTopAnchor: {
        top:    "top",
        bottom: "top",
        left:   "left",
        right:  "left"
    },
    
    horizontalAlign: {
        top:    "right",
        bottom: "left",
        middle: "center",
        right:  "right",
        left:   "left",
        center: "center"
    },
    
    verticalAlign: {
        top:    "top",
        bottom: "bottom",
        middle: "middle",
        right:  "bottom",
        left:   "top",
        center: "middle"
    },
    
    verticalAlign2: {
        top:    "top",
        bottom: "bottom",
        middle: "middle",
        right:  "top",
        left:   "bottom",
        center: "middle"
    },

    relativeAnchorMirror: {
        top: "right",
        bottom: "right",
        left: "top",
        right: "top"
    },

    oppositeAnchor: {
        top: "bottom",
        bottom: "top",
        left: "right",
        right: "left"
    },

    parallelLength: {
        top: "width",
        bottom: "width",
        right: "height",
        left: "height"
    },

    orthogonalLength: {
        top: "height",
        bottom: "height",
        right: "width",
        left: "width"
    },

    oppositeLength: {
        width:  "height",
        height: "width"
    }
});

def
.type('pvc.PlotPanel', pvc.BasePanel)
.init(function(chart, parent, plot, options) {
    // Prevent the border from affecting the box model,
    // providing a static 0 value, independently of the actual drawn value...
    //this.borderWidth = 0;
    
    this.base(chart, parent, options);
    
    this.plot = plot;
    this._extensionPrefix = plot.extensionPrefixes;
    this.dataPartValue = plot.option('DataPart');
    this.axes.color    = chart.getAxis('color', plot.option('ColorAxis') - 1);
    this.orientation   = plot.option('Orientation'  );
    this.valuesVisible = plot.option('ValuesVisible');
    this.valuesAnchor  = plot.option('ValuesAnchor' );
    this.valuesMask    = plot.option('ValuesMask'   );
    this.valuesFont    = plot.option('ValuesFont'   );
    
    this.chart._addPlotPanel(this);
})
.add({
    anchor:  'fill',

    _getExtensionId: function(){
        // chart is deprecated
        var extensionIds = ['chart', 'plot'];
        if(this.plotName){
            extensionIds.push(this.plotName);
        }
        
        return extensionIds;
    },
    
    /* @override */
    isOrientationVertical: function(){
        return this.orientation === pvc.orientation.vertical;
    },

    /* @override */
    isOrientationHorizontal: function(){
        return this.orientation === pvc.orientation.horizontal;
    }
});
def
.type('pvc.MultiChartPanel', pvc.BasePanel)
.add({
    anchor: 'fill',
    _multiInfo: null,
    
    createSmallCharts: function(){
        var chart = this.chart;
        var options = chart.options;
        
        /* I - Determine how many small charts to create */
        
        // multiChartMax can be Infinity
        var multiChartMax = Number(options.multiChartMax);
        if(isNaN(multiChartMax) || multiChartMax < 1) {
            multiChartMax = Infinity;
        }
        
        var multiChartRole = chart.visualRoles('multiChart');
        var data = chart.data.flattenBy(multiChartRole, {visible: true});
        var leafCount = data._children.length;
        var count = Math.min(leafCount, multiChartMax);
        if(count === 0) {
            // Shows no message to the user.
            // An empty chart, like when all series are hidden through the legend.
            return;
        }
        
        /* II - Determine basic layout (row and col count) */
        
        // multiChartColumnsMax can be Infinity
        var multiChartColumnsMax = +options.multiChartColumnsMax; // to number
        if(isNaN(multiChartColumnsMax) || multiChartMax < 1) {
            multiChartColumnsMax = 3;
        }
        
        var colCount = Math.min(count, multiChartColumnsMax);
        // <Debug>
        /*jshint expr:true */
        colCount >= 1 && isFinite(colCount) || def.assert("Must be at least 1 and finite");
        // </Debug>
        
        var rowCount = Math.ceil(count / colCount);
        // <Debug>
        /*jshint expr:true */
        rowCount >= 1 || def.assert("Must be at least 1");
        // </Debug>

        /* III - Determine if axes need coordination (null if no coordination needed) */
        
        var coordRootAxesByScopeType = this._getCoordinatedRootAxesByScopeType();
        var coordScopesByType, addChartToScope, indexChartByScope;
        if(coordRootAxesByScopeType){
            coordScopesByType = {};
            
            // Each scope is a specific 
            // 'row', 'column' or the single 'global' scope 
            addChartToScope = function(childChart, scopeType, scopeIndex){
                var scopes = def.array.lazy(coordScopesByType, scopeType);
                
                def.array.lazy(scopes, scopeIndex).push(childChart);
            };
            
            indexChartByScope = function(childChart){
                // Index child charts by scope
                //  on scopes having axes requiring coordination.
                if(coordRootAxesByScopeType.row){
                    addChartToScope(childChart, 'row', childChart.smallRowIndex);
                }
                
                if(coordRootAxesByScopeType.column){
                    addChartToScope(childChart, 'column', childChart.smallColIndex);
                }
                
                if(coordRootAxesByScopeType.global){
                    addChartToScope(childChart, 'global', 0);
                }
            };
        }
        
        /* IV - Create and _preRender small charts */
        var childOptionsBase = this._buildSmallChartsBaseOptions();
        var ChildClass = chart.constructor;
        for(var index = 0 ; index < count ; index++) {
            var childData = data._children[index];
            
            var colIndex = (index % colCount);
            var rowIndex = Math.floor(index / colCount);
            var childOptions = def.set(
                Object.create(childOptionsBase),
                'smallColIndex', colIndex,
                'smallRowIndex', rowIndex,
                'title',         childData.absLabel, // does not change with trends 
                'data',          childData);
            
            var childChart = new ChildClass(childOptions);
            
            if(!coordRootAxesByScopeType){
                childChart._preRender();
            } else {
                // options, data, plots, axes, 
                // trends, interpolation, axes_scales
                childChart._preRenderPhase1();
                
                indexChartByScope(childChart);
            }
        }
        
        // Need _preRenderPhase2?
        if(coordRootAxesByScopeType){
            // For each scope type having scales requiring coordination
            // find the union of the scales' domains for each
            // scope instance
            // Finally update all scales of the scope to have the 
            // calculated domain.
            def.eachOwn(coordRootAxesByScopeType, function(axes, scopeType){
                axes.forEach(function(axis){
                    
                    coordScopesByType[scopeType]
                        .forEach(function(scopeCharts){
                            this._coordinateScopeAxes(axis.id, scopeCharts);
                        }, this);
                    
                }, this);
            }, this);
            
            // Finalize _preRender, now that scales are coordinated
            chart.children.forEach(function(childChart){
                childChart._preRenderPhase2();
            });
        }
        
        // By now, trends and interpolation
        // have updated the data's with new Datums, if any.
        
        this._multiInfo = {
          data:     data,
          count:    count,
          rowCount: rowCount,
          colCount: colCount,
          multiChartColumnsMax: multiChartColumnsMax,
          coordScopesByType: coordScopesByType
        };
    },
    
    _getCoordinatedRootAxesByScopeType: function(){
        // Index axes that need to be coordinated, by scopeType
        var hasCoordination = false;
        var rootAxesByScopeType = 
            def
            .query(this.chart.axesList)
            .multipleIndex(function(axis){
                if(axis.scaleType !== 'discrete' && // Not implemented (yet...)
                   axis.option.isDefined('DomainScope')){
                    
                    var scopeType = axis.option('DomainScope');
                    if(scopeType !== 'cell'){
                        hasCoordination = true;
                        return scopeType;
                    }
                }
            })
            ;
        
        return hasCoordination ? rootAxesByScopeType : null;
    },
    
    _coordinateScopeAxes: function(axisId, scopeCharts){
        var unionExtent =
            def
            .query(scopeCharts)
            .select(function(childChart){
                var scale = childChart.axes[axisId].scale;
                if(!scale.isNull){
                    var domain = scale.domain();
                    return {min: domain[0], max: domain[1]};
                }
            })
            .reduce(pvc.unionExtents, null)
            ;
        
        if(unionExtent){
            // Fix the scale domain of every scale.
            scopeCharts.forEach(function(childChart){
                var axis  = childChart.axes[axisId];
                var scale = axis.scale;
                if(!scale.isNull){
                    scale.domain(unionExtent.min, unionExtent.max);
                    
                    axis.setScale(scale); // force update of dependent info.
                }
            });
        }
    },
    
    _buildSmallChartsBaseOptions: function(){
        // All size-related information is only supplied later in #_createCore.
        var chart = this.chart;
        var options = chart.options;
        return def.set(
            Object.create(options), 
               'parent',        chart,
               'legend',        false,
               'titleFont',     options.smallTitleFont,
               'titlePosition', options.smallTitlePosition,
               'titleAlign',    options.smallTitleAlign,
               'titleAlignTo',  options.smallTitleAlignTo,
               'titleOffset',   options.smallTitleOffset,
               'titleKeepInBounds', options.smallTitleKeepInBounds,
               'titleMargins',  options.smallTitleMargins,
               'titlePaddings', options.smallTitlePaddings,
               'titleSize',     options.smallTitleSize,
               'titleSizeMax',  options.smallTitleSizeMax);
    },
    
    /**
     * <p>
     * Implements small multiples chart layout.
     * Currently, it's essentially a flow-layout, 
     * from left to right and then top to bottom.
     * </p>
     * 
     * <p>
     * One small multiple chart is generated per unique combination 
     * of the values of the 'multiChart' visual role.
     * </p>
     * 
     * <p>
     * The option "multiChartMax" is the maximum number of small charts 
     * that can be laid out.
     * 
     * This can be useful if the chart's size cannot grow or 
     * if it cannot grow too much.
     * 
     * Pagination can be implemented with the use of this and 
     * the option 'multiChartPageIndex', to allow for effective printing of 
     * small multiple charts.
     * </p>
     * 
     * <p>
     * The option "multiChartPageIndex" is the desired page index.
     * This option requires that "multiChartMax" is also specified with
     * a finite and >= 1 value.
     * 
     * After a render is performed, 
     * the chart properties
     * {@link pvc.BaseChart#multiChartPageCount} and 
     * {@link pvc.BaseChart#multiChartPageIndex} will have been updated. 
     * </p>
     * 
     * <p>
     * The option 'multiChartColumnsMax' is the
     * maximum number of charts that can be laid  out in a row.
     * The default value is 3.
     * 
     * The value +Infinity can be specified, 
     * in which case there is no direct limit on the number of columns.
     * 
     * If the width of small charts does not fit in the available width 
     * then the chart's width is increased. 
     * </p>
     * <p>
     * The option 'smallWidth' can be specified to fix the width, 
     * of each small chart, in pixels or, in string "1%" format, 
     * as a percentage of the available width.
     * 
     * When not specified, but the option "multiChartColumnsMax" is specified and finite,
     * the width of the small charts is the available width divided
     * by the maximum number of charts in a row that <i>actually</i> occur
     * (so that if there are less small charts than 
     *  the maximum that can be placed on a row, 
     *  these, nevertheless, take up the whole width).
     * 
     * When both the options "smallWidth" and "multiChartColumnsMax" 
     * are unspecified, then the behavior is the same as if
     * the value "33%" had been specified for "smallWidth":
     * 3 charts will fit in the chart's initially specified width,
     * yet the chart's width can grow to accommodate for further small charts.
     * </p>
     * <p>
     * The option "multiChartSingleRowFillsHeight" affects the 
     * determination of the small charts height for the case where a single
     * row exists.
     * When the option is true, or unspecified, and a single row exists,
     * the height of the small charts will be all the available height,
     * looking similar to a non-multi-chart version of the same chart.
     *  When the option is false, 
     *  the determination of the small charts height does not depend
     *  on the number of rows, and proceeds as follows.
     * </p>
     * <p>
     * If the layout results in more than one row or 
     * when "multiChartSingleRowFillsHeight" is false,
     * the height of the small charts is determined using the option
     * 'smallAspectRatio', which is, by definition, width / height.
     * A typical aspect ratio value would be 5/4, 4/3 or the golden ratio (~1.62).
     * 
     * When the option is unspecified, 
     * a suitable value is determined,
     * using internal heuristic methods 
     * that generally depend on the concrete chart type
     * and specified options.
     * 
     * No effort is made to fill all the available height. 
     * The layout can result in two rows that occupy only half of the 
     * available height.
     * If the layout is such that the available height is exceeded, 
     * then the chart's height is increased.
     * </p>
     * <p>
     * The option 'margins' can be specified to control the 
     * spacing between small charts.
     * The default value is "2%".
     * Margins are only applied between small charts: 
     * the outer margins of border charts are always 0.  
     * </p>
     * <p>The option 'paddings' is applied to each small chart.</p>
     * 
     * ** Orthogonal scroll bar on height/width overflow??
     * ** Legend vertical center on page height ?? Dynamic?
     * 
     * @override
     */
    _calcLayout: function(layoutInfo){
        var multiInfo = this._multiInfo;
        if(!multiInfo){
            return;
        }
        
        var chart = this.chart;
        var options = chart.options;
        var clientSize = layoutInfo.clientSize;
        
        // TODO - multi-chart pagination
//        var multiChartPageIndex;
//        if(isFinite(multiChartMax)) {
//            multiChartPageIndex = chart.multiChartPageIndex;
//            if(isNaN(multiChartPageIndex)){
//                multiChartPageIndex = null;
//            } else {
//                // The next page number
//                // Initially, the chart property must have -1 to start iterating.
//                multiChartPageIndex++;
//            }
//        }
        
        var prevLayoutInfo = layoutInfo.previous;
        var initialClientWidth  = prevLayoutInfo ? prevLayoutInfo.initialClientWidth  : clientSize.width ;
        var initialClientHeight = prevLayoutInfo ? prevLayoutInfo.initialClientHeight : clientSize.height;
        
        var smallWidth  = pvc.PercentValue.parse(options.smallWidth);
        if(smallWidth != null){
            smallWidth = pvc.PercentValue.resolve(smallWidth, initialClientWidth);
        }
        
        var smallHeight = pvc.PercentValue.parse(options.smallHeight);
        if(smallHeight != null){
            smallHeight = pvc.PercentValue.resolve(smallHeight, initialClientHeight);
        }
        
        var ar = +options.smallAspectRatio; // + is to number
        if(isNaN(ar) || ar <= 0){
            ar = this._calulateDefaultAspectRatio();
        }
        
        if(smallWidth == null){
            if(isFinite(multiInfo.multiChartColumnsMax)){
                // Distribute currently available client width by the effective max columns.
                smallWidth = clientSize.width / multiInfo.colCount;
            } else {
                // Single Row
                // Chart grows in width as needed
                if(smallHeight == null){
                    // Both null
                    // Height uses whole height
                    smallHeight = initialClientHeight;
                }
                
                // Now use aspect ratio to calculate width
                smallWidth = ar * smallHeight;
            }
        }
        
        if(smallHeight == null){
            if((multiInfo.rowCount === 1 && def.get(options, 'multiChartSingleRowFillsHeight', true)) ||
               (multiInfo.colCount === 1 && def.get(options, 'multiChartSingleColFillsHeight', true))){
                
                // Height uses whole height
                smallHeight = initialClientHeight;
            } else {
                smallHeight = smallWidth / ar;
            }
        }
        
        // ----------------------
        
        def.set(
           layoutInfo, 
            'initialClientWidth',  initialClientWidth,
            'initialClientHeight', initialClientHeight,
            'width',  smallWidth,
            'height', smallHeight);
        
        return {
            width:  smallWidth * multiInfo.colCount,
            height: Math.max(clientSize.height, smallHeight * multiInfo.rowCount) // vertical align center: pass only: smallHeight * multiInfo.rowCount
        };
    },
    
    _calulateDefaultAspectRatio: function(/*totalWidth*/){
        if(this.chart instanceof pvc.PieChart){
            // 5/4 <=> 10/8 < 10/7 
            return 10/7;
        }
        
        // Cartesian, ...
        return 5/4;
        
        // TODO: this is not working well horizontal bar charts, for example
//        var chart = this.chart;
//        var options = chart.options;
//        var chromeHeight = 0;
//        var chromeWidth  = 0;
//        var defaultBaseSize  = 0.4;
//        var defaultOrthoSize = 0.2;
//        
//        // Try to estimate "chrome" of small chart
//        if(chart instanceof pvc.CartesianAbstract){
//            var isVertical = chart.isOrientationVertical();
//            var size;
//            if(options.showXScale){
//                size = parseFloat(options.xAxisSize || 
//                                  (isVertical ? options.baseAxisSize : options.orthoAxisSize) ||
//                                  options.axisSize);
//                if(isNaN(size)){
//                    size = totalWidth * (isVertical ? defaultBaseSize : defaultOrthoSize);
//                }
//                
//                chromeHeight += size;
//            }
//            
//            if(options.showYScale){
//                size = parseFloat(options.yAxisSize || 
//                                  (isVertical ? options.orthoAxisSize : options.baseAxisSize) ||
//                                  options.axisSize);
//                if(isNaN(size)){
//                    size = totalWidth * (isVertical ? defaultOrthoSize : defaultBaseSize);
//                }
//                
//                chromeWidth += size;
//            }
//        }
//        
//        var contentWidth  = Math.max(totalWidth - chromeWidth, 10);
//        var contentHeight = contentWidth / this._getDefaultContentAspectRatio();
//        
//        var totalHeight = chromeHeight + contentHeight;
//        
//        return totalWidth / totalHeight;
    },
    
//    _getDefaultContentAspectRatio: function(){
//        if(this.chart instanceof pvc.PieChart){
//            // 5/4 <=> 10/8 < 10/7 
//            return 10/7;
//        }
//        
//        // Cartesian
//        return 5/2;
//    },
    
    _getExtensionId: function(){
        return 'content';
    },
    
    _createCore: function(li){
        var mi = this._multiInfo;
        if(!mi){
            // Empty
            return;
        }
        
        var chart = this.chart;
        var options = chart.options;
        
        var smallMargins = options.smallMargins;
        if(smallMargins == null){
            smallMargins = new pvc.Sides(new pvc.PercentValue(0.02));
        } else {
            smallMargins = new pvc.Sides(smallMargins);
        }
        
        var smallPaddings = new pvc.Sides(options.smallPaddings);
        
        chart.children.forEach(function(childChart){
            childChart._setSmallLayout({
                left:      childChart.smallColIndex * li.width,
                top:       childChart.smallRowIndex * li.height,
                width:     li.width,
                height:    li.height,
                margins:   this._buildSmallMargins(childChart, smallMargins),
                paddings:  smallPaddings
            });
        }, this);
        
        var coordScopesByType = mi.coordScopesByType;
        if(coordScopesByType){
            chart._coordinateSmallChartsLayout(coordScopesByType);
        }
        
        this.base(li); // calls _create on child chart's basePanel
    },
    
    _buildSmallMargins: function(childChart, smallMargins){
        var mi = this._multiInfo;
        var lastColIndex = mi.colCount - 1;
        var lastRowIndex = mi.rowCount - 1;
        var colIndex = childChart.smallColIndex;
        var rowIndex = childChart.smallRowIndex;
        
        var margins = {};
        if(colIndex > 0){
            margins.left = smallMargins.left;
        }
        if(colIndex < lastColIndex){
            margins.right = smallMargins.right;
        }
        if(rowIndex > 0){
            margins.top = smallMargins.top;
        }
        if(rowIndex < lastRowIndex){
            margins.bottom = smallMargins.bottom;
        }
        
        return margins;
    }
});
def
.type('pvc.TitlePanelAbstract', pvc.BasePanel)
.init(function(chart, parent, options) {

    if (!options) {
        options = {};
    }

    var anchor = options.anchor || this.anchor;

    // titleSize
    if (options.size == null) {
        var size = options.titleSize;
        if (size != null) {
            // Single size (a number or a string with only one number)
            // should be interpreted as meaning the orthogonal length.
            options.size = new pvc.Size().setSize(size, {
                singleProp: this.anchorOrthoLength(anchor)
            });
        }
    }

    // titleSizeMax
    if (options.sizeMax == null) {
        var sizeMax = options.titleSizeMax;
        if (sizeMax != null) {
            // Single size (a number or a string with only one number)
            // should be interpreted as meaning the orthogonal length.
            options.sizeMax = new pvc.Size().setSize(sizeMax, {
                singleProp: this.anchorOrthoLength(anchor)
            });
        }
    }

    if (options.paddings == null) {
        options.paddings = this.defaultPaddings;
    }

    this.base(chart, parent, options);

    if (options.font === undefined) {
        var extensionFont = this._getExtension('label', 'font');
        if (typeof extensionFont === 'string') {
            this.font = extensionFont;
        }
    }
})
.add({
    pvLabel: null,
    anchor: 'top',

    title: null,
    titleSize: undefined,
    font: "12px sans-serif",

    defaultPaddings: 2,
    
    _extensionPrefix: 'title',
    
    /**
     * @override
     */
    _calcLayout: function(layoutInfo) {
            
        var requestSize = new pvc.Size();

        // TODO: take textAngle, textMargin and textBaseline into account

        // Naming is for anchor = top
        var a = this.anchor;
        var a_width = this.anchorLength(a);
        var a_height = this.anchorOrthoLength(a);
        
        // 2 - Small factor to avoid cropping text on either side
        var textWidth    = pv.Text.measure(this.title, this.font).width + 2;
        var clientWidth  = layoutInfo.clientSize[a_width];
        var desiredWidth = layoutInfo.desiredClientSize[a_width];
        
        if (desiredWidth == null) {
            desiredWidth = textWidth > clientWidth ? clientWidth : textWidth;
        } else if(desiredWidth > clientWidth) {
            desiredWidth = clientWidth;
        }

        var lines;
        if (textWidth > desiredWidth) {
            lines = pvc.text.justify(this.title, desiredWidth, this.font);
        } else {
            lines = this.title ? [ this.title ] : [];
        }

        // -------------

        var lineHeight = pv.Text.fontHeight(this.font);
        var realHeight = lines.length * lineHeight;
        var availableHeight = layoutInfo.clientSize[a_height];
        
        var desiredHeight = layoutInfo.desiredClientSize[a_height];
        if (desiredHeight == null) {
            desiredHeight = realHeight;
        } else if(desiredHeight > availableHeight) {
            desiredHeight = availableHeight;
        }
        
        if (realHeight > desiredHeight) {
            // Don't show partial lines unless it is the only one left
            var maxLineCount = Math.max(1, Math.floor(desiredHeight / lineHeight));
            if (lines.length > maxLineCount) {
                var firstCroppedLine = lines[maxLineCount];

                lines.length = maxLineCount;

                realHeight = desiredHeight = maxLineCount * lineHeight;

                var lastLine = lines[maxLineCount - 1] + " " + firstCroppedLine;

                lines[maxLineCount - 1] = 
                    pvc.text.trimToWidthB(
                        desiredWidth, 
                        lastLine, 
                        this.font, 
                        "..");
            }
        }

        layoutInfo.lines = lines;
        layoutInfo.topOffset = (desiredHeight - realHeight) / 2;
        layoutInfo.lineSize = {
            width: desiredWidth,
            height: lineHeight
        };

        layoutInfo.a_width = a_width;
        layoutInfo.a_height = a_height;

        requestSize[a_width] = desiredWidth;
        requestSize[a_height] = desiredHeight;

        return requestSize;
    },

    /**
     * @override
     */
    _createCore: function(layoutInfo) {
        var rootScene = this._buildScene(layoutInfo);
        
        // Label
        var rotationByAnchor = {
            top: 0,
            right: Math.PI / 2,
            bottom: 0,
            left: -Math.PI / 2
        };

        var textAlign = pvc.BasePanel.horizontalAlign[this.align];
    
        var textAnchor = pvc.BasePanel.leftTopAnchor[this.anchor];
        
        var wrapper;
        if(this.compatVersion() <= 1){
            wrapper = function(v1f){
                return function(itemScene){
                    return v1f.call(this);
                };
            };
        }
        
        this.pvLabel = new pvc.visual.Label(this, this.pvPanel, {
                extensionId: 'label',
                wrapper:     wrapper
            })
            .lock('data', rootScene.lineScenes)
            .pvMark
            [textAnchor](function(lineScene){
                return layoutInfo.topOffset + 
                       lineScene.vars.size.height / 2 +
                       this.index * lineScene.vars.size.height;
            })
            .textAlign(textAlign)
            [this.anchorOrtho(textAnchor)](function(lineScene){
                switch(this.textAlign()){
                    case 'center': return lineScene.vars.size.width / 2;
                    case 'left':   return 0;
                    case 'right':  return lineScene.vars.size.width;
                }
            })
            .text(function(lineScene) { return lineScene.vars.textLines[this.index]; })
            .font(this.font)
            .textBaseline('middle') // layout code does not support changing this
            .textAngle(rotationByAnchor[this.anchor])
            ;
    },
    
    _buildScene: function(layoutInfo){
        var rootScene = new pvc.visual.Scene(null, { panel: this, group: this.chart.data });
        var textLines = layoutInfo.lines;
        
        rootScene.vars.size  = layoutInfo.lineSize;
        rootScene.vars.textLines = textLines;
        
        rootScene.lineScenes = def.array.create(textLines.length, rootScene);
        
        return rootScene;
    },
    
    _getExtensionId: function() {
        return '';
    }
});

def
.type('pvc.TitlePanel', pvc.TitlePanelAbstract)
.init(function(chart, parent, options){
    
    if(!options){
        options = {};
    }
    
    var isV1Compat = chart.compatVersion() <= 1;
    if(isV1Compat){
        var size = options.titleSize;
        if(size == null){
            options.titleSize = 25;
        }
    }
    
    // Must be done before calling base, cause it uses _getExtension
    this._extensionPrefix = !chart.parent ? "title" : "smallTitle";
    
    this.base(chart, parent, options);
})
.add({

    font: "14px sans-serif",
    
    defaultPaddings: 4
});
/*
 * Legend panel. Generates the legend. Specific options are:
 * <i>legendPosition</i> - top / bottom / left / right. Default: bottom
 * <i>legendSize</i> - The size of the legend in pixels. Default: 25
 *
 * Has the following protovis extension points:
 *
 * <i>legend_</i> - for the legend Panel
 * <i>legendRule_</i> - for the legend line (when applicable)
 * <i>legendDot_</i> - for the legend marker (when applicable)
 * <i>legendLabel_</i> - for the legend label
 * 
 */
def
.type('pvc.LegendPanel', pvc.BasePanel)
.add({
    pvRule: null,
    pvDot: null,
    pvLabel: null,
    
    anchor: 'bottom',
    
    pvLegendPanel: null,
    
    textMargin: 6,    // The space *between* the marker and the text, in pixels.
    itemPadding:    2.5,  // Half the space *between* legend items, in pixels.
    markerSize: 15,   // *diameter* of marker *zone* (the marker itself may be a little smaller)
    font:  '10px sans-serif',

    /**
     * @override
     */
    _calcLayout: function(layoutInfo){
        return this._getBulletRootScene().layout(layoutInfo);
    },
    
    /**
     * @override
     */
    _createCore: function(layoutInfo) {
      var myself = this,
          clientSize = layoutInfo.clientSize,
          rootScene = this._getBulletRootScene(),
          itemPadding   = rootScene.vars.itemPadding,
          contentSize = rootScene.vars.size,
          sceneColorProp = function(scene){ return scene.color; };
      
       // Names are for horizontal layout (anchor = top or bottom)
      var isHorizontal = this.isAnchorTopOrBottom();
      var a_top    = isHorizontal ? 'top' : 'left';
      var a_bottom = this.anchorOpposite(a_top);    // top or bottom
      var a_width  = this.anchorLength(a_top);      // width or height
      var a_height = this.anchorOrthoLength(a_top); // height or width
      var a_center = isHorizontal ? 'center' : 'middle';
      var a_left   = isHorizontal ? 'left' : 'top';
      var a_right  = this.anchorOpposite(a_left);   // left or right
      
      // When V1 compat or size is fixed to less/more than content needs, 
      // it is still needed to align content inside
      
      // We align all rows left (or top), using the length of the widest row.
      // So "center" is a kind of centered-left align?
      
      var leftOffset = 0;
      switch(this.align){
          case a_right:
              leftOffset = clientSize[a_width] - contentSize.width;
              break;
              
          case a_center:
              leftOffset = (clientSize[a_width] - contentSize.width) / 2;
              break;
      }
      
      this.pvPanel.overflow("hidden");
      
      // ROW - A panel instance per row
      var pvLegendRowPanel = this.pvPanel.add(pv.Panel)
          .data(rootScene.vars.rows) // rows are "lists" of bullet item scenes
          [a_left  ](leftOffset)
          [a_top   ](function(){
              var prevRow = this.sibling(); 
              return prevRow ? (prevRow[a_top] + prevRow[a_height] + itemPadding[a_height]) : 0;
          })
          [a_width ](function(row){ return row.size.width;  })
          [a_height](function(row){ return row.size.height; })
          ;
      
      var wrapper;
      if(this.compatVersion() <= 1){
          wrapper = function(v1f){
              return function(itemScene){
                  return v1f.call(this, itemScene.vars.value.rawValue);
              };
          };
      }
      
      // ROW > ITEM - A pvLegendPanel instance per bullet item in a row
      this.pvLegendPanel = new pvc.visual.Panel(this, pvLegendRowPanel, {
              extensionId: 'panel',
              wrapper:     wrapper
          })
          .lockMark('data', function(row){ return row.items; }) // each row has a list of bullet item scenes
          .lock(a_right,  null)
          .lock(a_bottom, null)
          .lockMark(a_left, function(clientScene){
              var itemPadding  = clientScene.vars.itemPadding;
              var prevItem = this.sibling();
              return prevItem ? 
                      (prevItem[a_left] + prevItem[a_width] + itemPadding[a_width]) : 
                      0;
          })
          .lockMark('height', function(itemScene){ return itemScene.vars.clientSize.height; })
          .lockMark(a_top,
                  isHorizontal ?
                  // Center items in row's height, that may be higher
                  function(itemScene){
                      var vars = itemScene.vars;
                      return vars.row.size.height / 2 - vars.clientSize.height / 2;
                  } :
                  // Left align items of a same column
                  0)
          .lockMark('width',  
                  isHorizontal ?
                  function(itemScene){ return itemScene.vars.clientSize.width; } :
                  
                   // The biggest child width of the column
                  function(itemScene){ return this.parent.width(); })
          .pvMark
          .def("hidden", "false")
          .fillStyle(function(){ // TODO: ??
              return this.hidden() == "true" ? 
                     "rgba(200,200,200,1)" : 
                     "rgba(200,200,200,0.0001)";
          })
          .cursor(function(itemScene){
              return itemScene.isClickable() ? "pointer" : null;
          })
          .event("click", function(itemScene){
              if(itemScene.isClickable()){
                  return itemScene.click();
              }
          })
          ;
      
      // ROW > ITEM > MARKER
      var pvLegendMarkerPanel = new pvc.visual.Panel(this, this.pvLegendPanel)
          .pvMark
          .left(0)
          .top (0)
          .right (null)
          .bottom(null)
          .width (function(itemScene){ return itemScene.vars.markerSize; })
          .height(function(itemScene){ return itemScene.vars.clientSize.height; })
          ;
      
      if(pvc.debug >= 20){
          pvLegendRowPanel.strokeStyle('red');
          this.pvLegendPanel.strokeStyle('green');
          pvLegendMarkerPanel.strokeStyle('blue');
      }
      
      /* RULE/MARKER */
      rootScene.childNodes.forEach(function(groupScene){
          var pvGroupPanel = new pvc.visual.Panel(this, pvLegendMarkerPanel)
                  .pvMark
                  .visible(function(itemScene){
                      return itemScene.parent === groupScene; 
                  });
          
          groupScene.renderer().create(this, pvGroupPanel, groupScene.extensionPrefix, wrapper);
      }, this);

      /* LABEL */
      this.pvLabel = new pvc.visual.Label(this, pvLegendMarkerPanel.anchor("right"), {
              extensionId: 'label',
              wrapper: wrapper
          })
          .intercept('textStyle', function(itemScene) {
              var baseTextStyle = this.delegateExtension() || "black";
              return itemScene.isOn() ? 
                          baseTextStyle : 
                          pvc.toGrayScale(baseTextStyle, null, undefined, 150);
          })
          .pvMark
          .textAlign('left') // panel type anchors don't adjust textAlign this way
          .text(function(itemScene){ return itemScene.vars.value.label; })
          // -4 is to compensate for now the label being anchored to the panel instead of the rule or the dot...
          .lock('textMargin', function(itemScene){ return itemScene.vars.textMargin - 4; })
          .font(function(itemScene){ return itemScene.vars.font; }) // TODO: lock?
          .textDecoration(function(itemScene){ return itemScene.isOn() ? "" : "line-through"; })
          ;
    },

    _getExtensionId: function(){
        return 'area'; 
    },
    
    _getExtensionPrefix: function(){
        return 'legend'; 
    },
    
    _getSelectableMarks: function(){
        // Catches both the marker and the label.
        // Also, if selection changes, renderInteractive re-renders these.
        return [this.pvLegendPanel];
    },
    
    _getBulletRootScene: function(){
        var rootScene = this._rootScene;
        if(!rootScene){
            /* The legend root scene contains all datums of its chart */
            rootScene = new pvc.visual.legend.BulletRootScene(null, {
                panel: this, 
                group: this.chart.data,
                horizontal: this.isAnchorTopOrBottom(),
                font:       this.font,
                markerSize: this.markerSize,
                textMargin: this.textMargin, 
                itemPadding:    this.itemPadding
            });
            
            this._rootScene = rootScene;
        }
        
        return rootScene;
    }
});
/**
 * CartesianAbstract is the base class for all 2D cartesian space charts.
 */
def
.type('pvc.CartesianAbstract', pvc.BaseChart)
.init(function(options){
    
    this.axesPanels = {};
    
    this.base(options);
})
.add({
    _gridDockPanel: null,
    
    axesPanels: null, 
    
    // V1 properties
    yAxisPanel: null,
    xAxisPanel: null,
    secondXAxisPanel: null,
    secondYAxisPanel: null,
    yScale: null,
    xScale: null,
    
    _visibleDataCache: null,
    
    _getSeriesRoleSpec: function(){
        return { isRequired: true, defaultDimension: 'series*', autoCreateDimension: true, requireIsDiscrete: true };
    },
    
    _getColorRoleSpec: function(){
        return { isRequired: true, defaultDimension: 'color*', defaultSourceRole: 'series', requireIsDiscrete: true };
    },

    _initData: function(){
        // Clear data related cache
        if(this._visibleDataCache) {
            delete this._visibleDataCache;
        }
        
        this.base.apply(this, arguments);
    },
    
    _collectPlotAxesDataCells: function(plot, dataCellsByAxisTypeThenIndex){
        
        this.base(plot, dataCellsByAxisTypeThenIndex);
        
        /* NOTE: Cartesian axes are created even when hasMultiRole && !parent
         * because it is needed to read axis options in the root chart.
         * Also binding occurs to be able to know its scale type. 
         * Yet, their scales are not setup at the root level.
         */
        
        /* Configure Base Axis Data Cell */
        if(plot.option.isDefined('BaseAxis')){
            var baseDataCellsByAxisIndex = 
                def
                .array
                .lazy(dataCellsByAxisTypeThenIndex, 'base');
            
            def
            .array
            .lazy(baseDataCellsByAxisIndex, plot.option('BaseAxis') - 1)
            .push({
                plot:          plot,
                role:          this.visualRoles(plot.option('BaseRole')),
                dataPartValue: plot.option('DataPart')
            });
        }
        
        /* Configure Ortho Axis Data Cell */
        if(plot.option.isDefined('OrthoAxis')){
            
            var trend = plot.option('Trend');
            var isStacked = plot.option.isDefined('Stacked') ?
                            plot.option('Stacked') :
                            undefined;
            
            var orthoDataCellsByAxisIndex = 
                def
                .array
                .lazy(dataCellsByAxisTypeThenIndex, 'ortho');
            
            var orthoRoleNames = def.array.to(plot.option('OrthoRole'));
            
            var dataCellBase = {
                dataPartValue: plot.option('DataPart' ),
                isStacked:     isStacked,
                trend:         trend,
                nullInterpolationMode: plot.option('NullInterpolationMode')
            };
            
            var orthoDataCells = 
                def
                .array
                .lazy(orthoDataCellsByAxisIndex, plot.option('OrthoAxis') - 1);
            
            orthoRoleNames.forEach(function(orthoRoleName){
                var dataCell = Object.create(dataCellBase);
                dataCell.role = this.visualRoles(orthoRoleName);
                orthoDataCells.push(dataCell);
            }, this)
            ;
        }
    },
    
    _addAxis: function(axis){
        this.base(axis);
        
        switch(axis.type){
            case 'base':
            case 'ortho':
                this.axes[axis.orientedId] = axis;
                if(axis.v1SecondOrientedId){
                    this.axes[axis.v1SecondOrientedId] = axis;
                }
                break;
        }
        
        return this;
    },
        
    _generateTrendsDataCell: function(dataCell){
        /*jshint onecase:true */
        var trend =  dataCell.trend;
        if(trend){
            var trendInfo = pvc.trends.get(trend.type);
            
            var newDatums = [];
            
            this._generateTrendsDataCellCore(newDatums, dataCell, trendInfo);
            
            if(newDatums.length){
                this.data.owner.add(newDatums);
            }
        }
    },
    
    _generateTrendsDataCellCore: function(dataCell, trendInfo){
        // abstract
        // see Metric and Categorical implementations
    },
        
    _setAxesScales: function(hasMultiRole){
        
        this.base(hasMultiRole);
        
        if(!hasMultiRole || this.parent){
            ['base', 'ortho'].forEach(function(type){
                var axisOfType = this.axesByType[type];
                if(axisOfType){
                    axisOfType.forEach(this._createAxisScale, this);
                }
            }, this);
        }
    },
    
    /**
     * Creates a scale for a given axis, with domain applied, but no range yet,
     * assigns it to the axis and assigns the scale to special v1 chart instance fields.
     * 
     * @param {pvc.visual.CartesianAxis} axis The axis.
     * @type pv.Scale
     */
    _createAxisScale: function(axis){
        var isOrtho = axis.type === 'ortho';
        var isCart  = isOrtho || axis.type === 'base';
        
        var scale = this._createScaleByAxis(axis);
        if(scale.isNull && pvc.debug >= 3){
            this._log(def.format("{0} scale for axis '{1}'- no data", [axis.scaleType, axis.id]));
        }
        
        scale = axis.setScale(scale).scale;
        
        if(isCart){
            /* V1 fields xScale, yScale, secondScale */
            if(isOrtho && axis.index === 1) {
                this.secondScale = scale;
            } else if(!axis.index) {
                this[axis.orientation + 'Scale'] = scale;
            }
        }
        
        return scale;
    },
    
    /**
     * Creates a scale for a given axis.
     * 
     * @param {pvc.visual.CartesianAxis} axis The axis.
     * @type pv.Scale
     */
    _createScaleByAxis: function(axis){
        var createScale = this['_create' + def.firstUpperCase(axis.scaleType) + 'ScaleByAxis'];
        
        return createScale.call(this, axis);
    },
    
    _preRenderContent: function(contentOptions){
        /* Create the grid/docking panel */
        this._gridDockPanel = new pvc.CartesianGridDockingPanel(this, this.basePanel, {
            margins:  contentOptions.margins,
            paddings: contentOptions.paddings
        });
        
        /* Create child axis panels
         * The order is relevant because of docking order. 
         */
        ['base', 'ortho'].forEach(function(type){
            var typeAxes = this.axesByType[type];
            if(typeAxes){
                def
                .query(typeAxes)
                .reverse()
                .each(function(axis){
                    this._createAxisPanel(axis);
                }, this)
                ;
            }
        }, this);
        
        /* Create main content panel 
         * (something derived from pvc.CartesianAbstractPanel) */
        this._createPlotPanels(this._gridDockPanel, {
            clickAction:        contentOptions.clickAction,
            doubleClickAction:  contentOptions.doubleClickAction
        });
    },
    
    /**
     * Creates an axis panel, if it is visible.
     * @param {pvc.visual.CartesianAxis} axis The cartesian axis.
     * @type pvc.AxisPanel
     */
    _createAxisPanel: function(axis){
        if(axis.option('Visible')) {
            var titlePanel;
            var title = axis.option('Title');
            if (!def.empty(title)) {
                titlePanel = new pvc.AxisTitlePanel(this, this._gridDockPanel, axis, {
                    title:        title,
                    font:         axis.option('TitleFont') || axis.option('Font'),
                    anchor:       axis.option('Position'),
                    align:        axis.option('TitleAlign'),
                    margins:      axis.option('TitleMargins'),
                    paddings:     axis.option('TitlePaddings'),
                    titleSize:    axis.option('TitleSize'),
                    titleSizeMax: axis.option('TitleSizeMax')
                });
            }
            
            var panel = new pvc.AxisPanel(this, this._gridDockPanel, axis, {
                anchor:            axis.option('Position'),
                size:              axis.option('Size'),
                sizeMax:           axis.option('SizeMax'),
                clickAction:       axis.option('ClickAction'),
                doubleClickAction: axis.option('DoubleClickAction'),
                useCompositeAxis:  axis.option('Composite'),
                font:              axis.option('Font'),
                labelSpacingMin:   axis.option('LabelSpacingMin'),
                tickExponentMin:   axis.option('TickExponentMin'),
                tickExponentMax:   axis.option('TickExponentMax'),
                grid:              axis.option('Grid'),
                gridCrossesMargin: axis.option('GridCrossesMargin'),
                ruleCrossesMargin: axis.option('RuleCrossesMargin'),
                zeroLine:          axis.option('ZeroLine'),
                domainRoundMode:   axis.option('DomainRoundMode'),
                desiredTickCount:  axis.option('DesiredTickCount'),
                showTicks:         axis.option('Ticks'),
                showMinorTicks:    axis.option('MinorTicks')
            });
            
            if(titlePanel){
                panel.titlePanel = titlePanel;
            }
            
            this.axesPanels[axis.id] = panel;
            this.axesPanels[axis.orientedId] = panel;
            
            // V1 fields
            if(axis.index <= 1 && axis.v1SecondOrientedId) {
                this[axis.v1SecondOrientedId + 'AxisPanel'] = panel;
            }
            
            return panel;
        }
    },

    /**
     * Creates a discrete scale for a given axis.
     * <p>
     * Uses the chart's <tt>panelSizeRatio</tt> to calculate the band.
     * </p>
     * 
     * @param {pvc.visual.CartesianAxis} axis The axis.
     * @virtual
     * @type pv.Scale
     */
    _createDiscreteScaleByAxis: function(axis){
        /* DOMAIN */

        // With composite axis, only 'singleLevel' flattening works well
        var dataPartValues = 
            axis.
            dataCells.
            map(function(dataCell){ return dataCell.dataPartValue; });
        
        var baseData = this._getVisibleData(dataPartValues, {ignoreNulls: false});
        var data = baseData && baseData.flattenBy(axis.role);
        
        var scale = new pv.Scale.ordinal();
        if(!data || !data.count()){
            scale.isNull = true;
        } else {
            var values = data.children()
                             .select(function(child){ return def.nullyTo(child.value, ""); })
                             .array();
            
            scale.domain(values);
        }
        
        return scale;
    },
    
    /**
     * Creates a continuous time-series scale for a given axis.
     * 
     * <p>
     * Uses the axis' option <tt>Offset</tt> to calculate excess domain margins at each end of the scale.
     * </p>
     * <p>
     * Also takes into account the specified axis' options 
     * <tt>DomainRoundMode</tt> and <tt>DesiredTickCount</tt>.
     * </p>
     * 
     * @param {pvc.visual.CartesianAxis} axis The axis.
     * @virtual
     * @type pv.Scale
     */
    _createTimeSeriesScaleByAxis: function(axis){
        /* DOMAIN */
        var extent = this._getContinuousVisibleExtent(axis); // null when no data...
        
        var scale = new pv.Scale.linear();
        if(!extent){
            scale.isNull = true;
        } else {
            var dMin = extent.min;
            var dMax = extent.max;

            if((dMax - dMin) === 0) {
                dMax = new Date(dMax.getTime() + 3600000); // 1 h
            }
        
            scale.domain(dMin, dMax);
            scale.minLocked = extent.minLocked;
            scale.maxLocked = extent.maxLocked;
        }
        
        return scale;
    },

    /**
     * Creates a continuous numeric scale for a given axis.
     *
     * <p>
     * Uses the axis' option <tt>Offset</tt> to calculate excess domain margins at each end of the scale.
     * </p>
     * <p>
     * Also takes into account the specified axis' options
     * <tt>DomainRoundMode</tt> and <tt>DesiredTickCount</tt>.
     * </p>
     *
     * @param {pvc.visual.CartesianAxis} axis The axis.
     * @virtual
     * @type pv.Scale
     */
    _createNumericScaleByAxis: function(axis){
        /* DOMAIN */
        var extent = this._getContinuousVisibleExtentConstrained(axis);
        
        var scale = new pv.Scale.linear();
        if(!extent){
            scale.isNull = true;
        } else {
            var tmp;
            var dMin = extent.min;
            var dMax = extent.max;
            
            if(dMin > dMax){
                tmp = dMin;
                dMin = dMax;
                dMax = tmp;
            }
            
            var originIsZero = axis.option('OriginIsZero');
            if(originIsZero){
                if(dMin === 0){
                    extent.minLocked = true;
                } else if(dMax === 0){
                    extent.maxLocked = true;
                } else if((dMin * dMax) > 0){
                    /* If both negative or both positive
                     * the scale does not contain the number 0.
                     */
                    if(dMin > 0){
                        if(!extent.minLocked){
                            extent.minLocked = true;
                            dMin = 0;
                        }
                    } else {
                        if(!extent.maxLocked){
                            extent.maxLocked = true;
                            dMax = 0;
                        }
                    }
                }
            }
    
            /*
             * If the bounds (still) are the same, things break,
             * so we add a wee bit of variation.
             * Ignoring locks.
             */
            if(dMin > dMax){
                tmp = dMin;
                dMin = dMax;
                dMax = tmp;
            }
            
            if(dMax - dMin <= 1e-12) {
                if(!extent.minLocked){
                    dMin = dMin !== 0 ? (dMin * 0.99) : -0.1;
                }
                
                // If both are locked, ignore max lock
                if(!extent.maxLocked || extent.minLocked){
                    dMax = dMax !== 0 ? dMax * 1.01 : 0.1;
                }
            }
            
            scale.domain(dMin, dMax);
            scale.minLocked = extent.minLocked;
            scale.maxLocked = extent.maxLocked;
        }
        
        return scale;
    },
    
    _onLaidOut: function(){
        if(this.plotPanelList && this.plotPanelList[0]){ // not the root of a multi chart
            /* Set scale ranges, after layout */
            ['base', 'ortho'].forEach(function(type){
                var axes = this.axesByType[type];
                if(axes){
                    axes.forEach(this._setCartAxisScaleRange, this);
                }
            }, this);
        }
    },
    
    _setCartAxisScaleRange: function(axis){
        var info = this.plotPanelList[0]._layoutInfo;
        var size = (axis.orientation === 'x') ?
           info.clientSize.width :
           info.clientSize.height;
        
        axis.setScaleRange(size);

        return axis.scale;
    },
        
    _getAxesRoundingPaddings: function(){
        var axesPaddings = {};
        
        var axesByType = this.axesByType;
        ['base', 'ortho'].forEach(function(type){
            var typeAxes = axesByType[type];
            if(typeAxes){
                typeAxes.forEach(processAxis);
            }
        });
        
        return axesPaddings;
        
        function setSide(side, pct, locked){
            var value = axesPaddings[side];
            if(value == null || pct > value){
                axesPaddings[side] = pct;
                axesPaddings[side + 'Locked'] = locked;
            } else if(locked) {
                axesPaddings[side + 'Locked'] = locked;
            }
        }
        
        function processAxis(axis){
            if(axis){
                // {begin: , end: , beginLocked: , endLocked: }
                var rp = axis.getScaleRoundingPaddings();
                if(rp){
                    var isX = axis.orientation === 'x';
                    setSide(isX ? 'left'  : 'bottom', rp.begin, rp.beginLocked);
                    setSide(isX ? 'right' : 'top'   , rp.end,   rp.endLocked);
                }
            }
        }
    },
    
    /*
     * Obtains the chart's visible data
     * grouped according to the charts "main grouping".
     * 
     * @param {string|string[]} [dataPartValue=null] The desired data part value or values.
     * @param {object} [keyArgs=null] Optional keyword arguments object.
     * @param {boolean} [keyArgs.ignoreNulls=true] Indicates that null datums should be ignored.
     * 
     * @type pvc.data.Data
     */
    _getVisibleData: function(dataPartValue, keyArgs){
        var ignoreNulls = def.get(keyArgs, 'ignoreNulls', true);
        if(ignoreNulls && this.options.ignoreNulls){
            // If already globally ignoring nulls, there's no need to do it explicitly anywhere
            ignoreNulls = false;
        }
        
        keyArgs = keyArgs ? Object.create(keyArgs) : {};
        keyArgs.ignoreNulls = ignoreNulls;
        
        var key = ignoreNulls + '|' + dataPartValue, // relying on array.toString, when an array
            data = def.getOwn(this._visibleDataCache, key);
        if(!data) {
            data = this._createVisibleData(dataPartValue, keyArgs);
            if(data){
                (this._visibleDataCache || (this._visibleDataCache = {}))
                    [key] = data;
            }
        }
        
        return data;
    },

    /*
     * Creates the chart's visible data
     * grouped according to the charts "main grouping".
     *
     * <p>
     * The default implementation groups data by series visual role.
     * </p>
     *
     * @param {string|string[]} [dataPartValue=null] The desired data part value or values.
     * 
     * @type pvc.data.Data
     * @protected
     * @virtual
     */
    _createVisibleData: function(dataPartValue, keyArgs){
        var partData = this.partData(dataPartValue);
        if(!partData){
            return null;
        }
        
        var ignoreNulls = def.get(keyArgs, 'ignoreNulls');
        
        return this._serRole && this._serRole.grouping ?
               partData.flattenBy(this._serRole, {visible: true, isNull: ignoreNulls ? false : null}) :
               partData;
    },
    
    _warnSingleContinuousValueRole: function(valueRole){
        if(!valueRole.grouping.isSingleDimension) {
            this._log("[WARNING] A linear scale can only be obtained for a single dimension role.");
        }
        
        if(valueRole.grouping.isDiscrete()) {
            this._log("[WARNING] The single dimension of role '{0}' should be continuous.", [valueRole.name]);
        }
    },
    
    /**
     * @virtual
     */
    _getContinuousVisibleExtentConstrained: function(axis, min, max){
        var minLocked = false;
        var maxLocked = false;
        
        if(min == null) {
            min = axis.option('FixedMin');
            minLocked = (min != null);
        }
        
        if(max == null) {
            max = axis.option('FixedMax');
            maxLocked = (max != null);
        }
        
        if(min == null || max == null) {
            var baseExtent = this._getContinuousVisibleExtent(axis); // null when no data
            if(!baseExtent){
                return null;
            }
            
            if(min == null){
                min = baseExtent.min;
            }
            
            if(max == null){
                max = baseExtent.max;
            }
        }
        
        return {min: min, max: max, minLocked: minLocked, maxLocked: maxLocked};
    },
    
    /**
     * Gets the extent of the values of the specified axis' roles
     * over all datums of the visible data.
     * 
     * @param {pvc.visual.CartesianAxis} valueAxis The value axis.
     * @type object
     *
     * @protected
     * @virtual
     */
    _getContinuousVisibleExtent: function(valueAxis){
        
        var dataCells = valueAxis.dataCells;
        if(dataCells.length === 1){
            // Most common case is faster
            return this._getContinuousVisibleCellExtent(valueAxis, dataCells[0]);
        }
        
        // This implementation takes the union of 
        // the extents of each data cell.
        // Even when a data cell has multiple data parts, 
        // it is evaluated as a whole.
        
        return def
            .query(dataCells)
            .select(function(dataCell){
                return this._getContinuousVisibleCellExtent(valueAxis, dataCell);
            }, this)
            .reduce(pvc.unionExtents, null);
    },

    /**
     * Gets the extent of the values of the specified role
     * over all datums of the visible data.
     *
     * @param {pvc.visual.CartesianAxis} valueAxis The value axis.
     * @param {pvc.visual.Role} valueDataCell The data cell.
     * @type object
     *
     * @protected
     * @virtual
     */
    _getContinuousVisibleCellExtent: function(valueAxis, valueDataCell){
        var valueRole = valueDataCell.role;
        
        this._warnSingleContinuousValueRole(valueRole);

        if(valueRole.name === 'series') {
            /* not supported/implemented? */
            throw def.error.notImplemented();
        }
        
        var useAbs = valueAxis.scaleUsesAbs();
        var data  = this._getVisibleData(valueDataCell.dataPartValue);
        var extent = data && data
            .dimensions(valueRole.firstDimensionName())
            .extent({ abs: useAbs });
        
        if(extent){
            var minValue = extent.min.value;
            var maxValue = extent.max.value;
            return {
                min: (useAbs ? Math.abs(minValue) : minValue), 
                max: (useAbs ? Math.abs(maxValue) : maxValue) 
            };
        }
    },
    
    markEventDefaults: {
        strokeStyle: "#5BCBF5",  /* Line Color */
        lineWidth: "0.5",  /* Line Width */
        textStyle: "#5BCBF5", /* Text Color */
        verticalOffset: 10, /* Distance between vertical anchor and label */
        verticalAnchor: "bottom", /* Vertical anchor: top or bottom */
        horizontalAnchor: "right", /* Horizontal anchor: left or right */
        forceHorizontalAnchor: false, /* Horizontal anchor position will be respected if true */
        horizontalAnchorSwapLimit: 80 /* Horizontal anchor will switch if less than this space available */
    },
    
    // TODO: chart orientation?
    markEvent: function(dateString, label, options){

        var baseScale = this.axes.base.scale;
        
        if(baseScale.type !== 'timeSeries'){
            this._log("Attempting to mark an event on a non timeSeries chart");
            return this;
        }

        var o = $.extend({}, this.markEventDefaults, options);
        
        // TODO: format this using dimension formatter...
        
        // Are we outside the allowed scale?
        var d = pv.Format.date(this.options.timeSeriesFormat).parse(dateString);
        var dpos = baseScale(d),
            range = baseScale.range();
        
        if( dpos < range[0] || dpos > range[1]){
            this._log("Event outside the allowed range, returning");
            return this;
        }

        // Add the line

        var panel = this.plotPanelList[0].pvPanel;
        var h = this.yScale.range()[1];

        // Detect where to place the horizontalAnchor
        //var anchor = o.horizontalAnchor;
        if( !o.forceHorizontalAnchor ){
            var availableSize = o.horizontalAnchor == "right"? range[1]- dpos : dpos;
            
            // TODO: Replace this availableSize condition with a check for the text size
            if (availableSize < o.horizontalAnchorSwapLimit ){
                o.horizontalAnchor = o.horizontalAnchor == "right" ? "left" : "right";
            }
        }

        var line = panel.add(pv.Line)
            .data([0,h])
            .strokeStyle(o.strokeStyle)
            .lineWidth(o.lineWidth)
            .bottom(function(d){
                return d;
            })
            .left(dpos);

        //var pvLabel = 
        line.anchor(o.horizontalAnchor)
            .top(o.verticalAnchor == "top" ? o.verticalOffset : (h - o.verticalOffset))
            .add(pv.Label)
            .text(label)
            .textStyle(o.textStyle)
            .visible(function(){
                return !this.index;
            });
        
        return this;
    },
    
    defaults: {
        /* Percentage of occupied space over total space in a discrete axis band */
        panelSizeRatio: 0.9,

        // Indicates that the *base* axis is a timeseries
        timeSeries: false,
        timeSeriesFormat: "%Y-%m-%d"
        
        // Show a frame around the plot area
        // plotFrameVisible: undefined
    }
});

def
.type('pvc.GridDockingPanel', pvc.BasePanel)
.add({
    anchor: 'fill',
    
    /**
     * Implements a docking/grid layout variant.
     * <p>
     * The layout contains 5 target positions: top, bottom, left, right and center.
     * These are mapped to a 3x3 grid. The corner cells always remain empty.
     * In the center cell, panels are superimposed.
     * </p>
     * <p>
     * Additionally, panels' paddings are shared:
     * Left and right paddings are shared by the top, center and bottom panels.
     * Top and bottom paddings are shared by the left, center and right panels.
     * </p>
     * <p>
     * Child panel's can inform of existing overflowPaddings - 
     * resulting of things that are ok to overflow, 
     * as long as they don't leave the parent panel's space, 
     * and that the parent panel itself tries to reserve space for it or 
     * ensure it is in a free area.
     * </p>
     * <p>
     * The empty corner cells of the grid layout can absorb some of the overflow 
     * content from non-fill child panels. 
     * If, for example, a child panel is placed at the 'left' cell and it
     * overflows in 'top', that overflow can be partly absorbed by 
     * the top-left corner cell, as long as there's a panel in the top cell that
     * imposes that much height. 
     * </p>
     * <p>
     * If the corner space is not enough to absorb the overflow paddings
     * 
     * </p>
     * 
     * @override
     */
    _calcLayout: function(layoutInfo){
        
        if(!this._children) {
            return;
        }
        
        // Objects we can mutate
        var margins  = new pvc.Sides(0);
        var paddings = new pvc.Sides(0);
        var remSize = def.copyOwn(layoutInfo.clientSize);
        var overFlowPaddings;
        var aolMap = pvc.BasePanel.orthogonalLength;
        var aoMap  = pvc.BasePanel.relativeAnchor;
        var alMap  = pvc.BasePanel.parallelLength;
        var me = this;
        var childKeyArgs = {
                force: true,
                referenceSize: layoutInfo.clientSize
            };
        
        var fillChildren = [];
        var sideChildren = [];
        
        // loop detection
        var paddingHistory = {}; 
        var loopSignal = {};
        var overflowPaddingsSignal = {};
        var isDisasterRecovery = false;
        
        if(pvc.debug >= 5){
            me._log("  ==== Layout Init - Side Panels Round");
        }
        
        // PHASE 0 - Initialization
        //
        // Splits children in two groups: FILL and SIDE, according to its anchor.
        // Children explicitly not requiring layout are excluded (!child.anchor).
        //
        // For FILL children, finds the maximum of the resolved paddings.
        // These paddings will be the minimum that will result from this layout.
        this._children.forEach(initChild);
        
        // PHASE 1 - MARGINS are imposed by SIDE children
        //
        // Lays out non-fill children receiving each, the remaining space as clientSize.
        //
        // Each adds its orthogonal length to the margin side where it is anchored.
        // The normal length is only correctly known after all non-fill
        // children have been laid out once.
        // 
        // As such the child is only positioned on the anchor coordinate.
        // The orthogonal anchor coordinate is only set on the second phase.
        // 
        // SIDE children may change paddings as well.
        sideChildren.forEach(layoutChild1Side);
        
        // -> remSize now contains the size of the CENTER cell and is not changed any more
        
        // PHASE 2 - Relayout each SIDE child with its final orthogonal length
        // PHASE 3 - Layout FILL children
        // 
        // Repeat 2 and 3 while paddings changed
        
        doMaxTimes(9, layoutCycle);
        
        layoutInfo.gridMargins  = new pvc.Sides(margins );
        layoutInfo.gridPaddings = new pvc.Sides(paddings);
        layoutInfo.gridSize     = new pvc.Size(remSize  );
        
        // All available client space is consumed.
        // As such, there's no need to return anything.
        // return;
        
        // --------
        
        function layoutCycle(remTimes, iteration){
            if(pvc.debug >= 5){
                me._log("  ==== LayoutCycle " + (isDisasterRecovery ? "Disaster MODE" : ("#" + (iteration + 1))));
            }
            
            var index, count;
            var canChange = layoutInfo.canChange !== false && !isDisasterRecovery && (remTimes > 0);
            var paddingsChanged;
            var ownPaddingsChanged = false;
            
            index = 0;
            count = sideChildren.length;
            while(index < count){
                if(pvc.debug >= 5){
                    me._log("    SIDE Child i=" + index);
                }
                
                paddingsChanged = layoutChild2Side(sideChildren[index], canChange);
                if(!isDisasterRecovery && paddingsChanged){
                    if(paddingsChanged === loopSignal){
                        // Oh no...
                        isDisasterRecovery = true;
                        layoutCycle(0);
                        return false; // stop;
                    }
                    
                    if(paddingsChanged === overflowPaddingsSignal){
                        // Don't stop right away cause there might be other overflow paddings requests
                        // of other side childs
                        if(!ownPaddingsChanged){
                            ownPaddingsChanged = true;
                            layoutInfo.requestPaddings = layoutInfo.paddings; 
                        }
                    } else {
                        if(remTimes > 0){
                            if(pvc.debug >= 5){
                                me._log("    SIDE Child i=" + index + " increased paddings");
                            }
                            return true; // repeat
                        } else if(pvc.debug >= 2){
                            me._log("    [Warning] SIDE Child i=" + index + " increased paddings but no more iterations possible.");
                        }
                    }
                }
                index++;
            }
            
            if(ownPaddingsChanged){
                if(pvc.debug >= 5){
                    me._log("    Restarting due to overflowPaddings change");
                }
                return false; // stop;
            }
            
            index = 0;
            count = fillChildren.length;
            while(index < count){
                if(pvc.debug >= 5){
                    me._log("    FILL Child i=" + index);
                }
                
                paddingsChanged = layoutChildFill(fillChildren[index], canChange);
                if(!isDisasterRecovery && paddingsChanged){
                    if(paddingsChanged === loopSignal){
                        // Oh no...
                        isDisasterRecovery = true;
                        layoutCycle(0);
                        return false; // stop;
                    }
                    
                    if(remTimes > 0){
                        if(pvc.debug >= 5){
                            me._log("    FILL Child i=" + index + " increased paddings");
                        }
                        return true; // repeat
                    } else if(pvc.debug >= 2){
                        me._log("    [Warning] FILL Child i=" + index + " increased paddings but no more iterations possible.");
                    }
                }
                index++;
            }
            
            return false; // stop
        }
        
        function doMaxTimes(maxTimes, fun){
            var index = 0;
            while(maxTimes--){
                // remTimes = maxTimes
                if(fun(maxTimes, index) === false){
                    return true;
                }
                index++;
            }
            
            return false;
        }
        
        function initChild(child) {
            var a = child.anchor;
            if(a){
                if(a === 'fill') {
                    fillChildren.push(child);
                    
                    var childPaddings = child.paddings.resolve(childKeyArgs.referenceSize);
                    
                    // After the op. it's not a pvc.Side anymore, just an object with same named properties.
                    paddings = pvc.Sides.resolvedMax(paddings, childPaddings);
                } else {
                    /*jshint expr:true */
                    def.hasOwn(aoMap, a) || def.fail.operationInvalid("Unknown anchor value '{0}'", [a]);
                    
                    sideChildren.push(child);
                }
            }
        }
        
        function layoutChild1Side(child, index) {
            if(pvc.debug >= 5){
                me._log("    SIDE Child i=" + index);
            }
            
            var paddingsChanged = false;
            
            var a = child.anchor;
            
            childKeyArgs.paddings = filterAnchorPaddings(a, paddings);
            
            child.layout(new pvc.Size(remSize), childKeyArgs);
            
            if(child.isVisible){
                
                paddingsChanged = checkAnchorPaddingsChanged(a, paddings, child);

                // Only set the *anchor* position
                // The other orthogonal position is dependent on the size of the other non-fill children
                positionChildNormal(a, child);
                
                updateSide(a, child);
            }
            
            return paddingsChanged;
        }
        
        function layoutChildFill(child, canChange) {
            var paddingsChanged = false;
            
            var a = child.anchor; // 'fill'
            
            childKeyArgs.paddings  = filterAnchorPaddings(a, paddings);
            childKeyArgs.canChange = canChange;
            
            child.layout(new pvc.Size(remSize), childKeyArgs);
            
            if(child.isVisible){
                paddingsChanged = checkAnchorPaddingsChanged(a, paddings, child, canChange);
                
                positionChildNormal(a, child);
                positionChildOrtho (child, a);
            }
            
            return paddingsChanged;
        }
        
        function layoutChild2Side(child, canChange) {
            var paddingsChanged = false;
            if(child.isVisible){
                var a = child.anchor;
                var al  = alMap[a];
                var aol = aolMap[a];
                var length  = remSize[al];
                var olength = child[aol];
                
                var childSize2 = new pvc.Size(def.set({}, al, length, aol, olength));
                
                childKeyArgs.paddings = filterAnchorPaddings(a, paddings);
                childKeyArgs.canChange = canChange;
                
                child.layout(childSize2, childKeyArgs);
                
                if(child.isVisible){
                    paddingsChanged = checkAnchorPaddingsChanged(a, paddings, child, canChange);
                    
                    if(checkOverflowPaddingsChanged(a, layoutInfo.paddings, child, canChange)){
                        return overflowPaddingsSignal;
                    }
                        
                    positionChildOrtho(child, child.align);
                }
            }
            
            return paddingsChanged;
        }
        
        function positionChildNormal(side, child) {
            var sidePos;
            if(side === 'fill'){
                side = 'left';
                sidePos = margins.left + remSize.width / 2 - (child.width / 2);
            } else {
                sidePos = margins[side];
            }
            
            child.setPosition(def.set({}, side, sidePos));
        }
        
        // Decreases available size and increases margins
        function updateSide(side, child) {
            var sideol = aolMap[side],
                olen   = child[sideol];
            
            margins[side]   += olen;
            remSize[sideol] -= olen;
        }
        
        function positionChildOrtho(child, align) {
            var sideo;
            if(align === 'fill'){
                align = 'middle';
            }
            
            var sideOPos;
            switch(align){
                case 'top':
                case 'bottom':
                case 'left':
                case 'right':
                    sideo = align;
                    sideOPos = margins[sideo];
                    break;
                
                case 'middle':
                    sideo    = 'bottom';
                    sideOPos = margins.bottom + (remSize.height / 2) - (child.height / 2);
                    break;
                    
                case 'center':
                    sideo    = 'left';
                    sideOPos = margins.left + remSize.width / 2 - (child.width / 2);
                    break;
            }
            
            child.setPosition(def.set({}, sideo, sideOPos));
        }
        
        function filterAnchorPaddings(a, paddings){
            var filtered = new pvc.Sides();
            
            getAnchorPaddingsNames(a).forEach(function(side){
                filtered.set(side, paddings[side]);
            });
            
            return filtered;
        }
        
        function checkAnchorPaddingsChanged(a, paddings, child, canChange){
            var newPaddings = child._layoutInfo.requestPaddings;
            
            var changed = false;
            if(newPaddings){
                if(pvc.debug >= 10){
                    me._log("    => clientSize=" + pvc.stringify(child._layoutInfo.clientSize));
                    me._log("    <= requestPaddings=" + pvc.stringify(newPaddings));
                }
                
                getAnchorPaddingsNames(a).forEach(function(side){
                    if(newPaddings.hasOwnProperty(side)){
                        var value    = paddings[side] || 0;
                        var newValue = Math.floor(10000 * (newPaddings[side] || 0)) / 10000;
                        var increase = newValue - value;
                        var minChange = Math.max(1, Math.abs(0.01 * value));
                        
                        // STABILITY requirement
                        if(increase !== 0 && Math.abs(increase) >= minChange){
                            if(!canChange){
                                if(pvc.debug >= 2){
                                    me._log("    [Warning] CANNOT change but child wanted to: " + side + "=" + newValue);
                                }
                            } else {
                                changed = true;
                                paddings[side] = newValue;
                                
                                if(pvc.debug >= 5){
                                    me._log("    changed padding " + side + " <- " + newValue);
                                }
                            }
                        }
                    }
                });
                
                if(changed){
                    var paddingKey = pvc.Sides
                                        .names
                                        .map(function(side){ return (paddings[side] || 0).toFixed(0); })
                                        .join('|');
                    
                    if(def.hasOwn(paddingHistory, paddingKey)){
                        // LOOP detected
                        if(pvc.debug >= 2){
                            me._log("    [Warning] LOOP detected");
                        }
                        changed = loopSignal;
                    } else {
                        paddingHistory[paddingKey] = true;
                    }
                    
                    paddings.width  = paddings.left + paddings.right ;
                    paddings.height = paddings.top  + paddings.bottom;
                }
            }
            
            return changed;
        }
        
        function checkOverflowPaddingsChanged(a, ownPaddings, child, canChange){
            var overflowPaddings = child._layoutInfo.overflowPaddings;
            
            var changed = false;
            if(overflowPaddings){
                if(pvc.debug >= 10){
                    me._log("    <= overflowPaddings=" + pvc.stringify(overflowPaddings));
                }
                
                getAnchorPaddingsNames(a).forEach(function(side){
                    if(overflowPaddings.hasOwnProperty(side)){
                        var value    = ownPaddings[side] || 0;
                        var newValue = Math.floor(10000 * (overflowPaddings[side] || 0)) / 10000;
                        newValue -= margins[side]; // corners absorb some of it
                        
                        var increase = newValue - value;
                        var minChange = Math.max(1, Math.abs(0.05 * value));
                        
                        // STABILITY & SPEED requirement
                        if(increase >= minChange){
                            if(!canChange){
                                if(pvc.debug >= 2){
                                    me._log("    [Warning] CANNOT change overflow padding but child wanted to: " + side + "=" + newValue);
                                }
                            } else {
                                changed = true;
                                ownPaddings[side] = newValue;
                                
                                if(pvc.debug >= 5){
                                    me._log("     changed overflow padding " + side + " <- " + newValue);
                                }
                            }
                        }
                    }
                });
                
                if(changed){
                    ownPaddings.width  = ownPaddings.left + ownPaddings.right ;
                    ownPaddings.height = ownPaddings.top  + ownPaddings.bottom;
                }
            }
            
            return changed;
        }
        
        function getAnchorPaddingsNames(a){
            switch(a){
                case 'left':
                case 'right':  return pvc.Sides.vnames;
                case 'top':
                case 'bottom': return pvc.Sides.hnames;
                case 'fill':   return pvc.Sides.names;
            }
        }

    }
});

def
.type('pvc.CartesianGridDockingPanel', pvc.GridDockingPanel)
.add({
    
    _getExtensionId: function(){
        return !this.chart.parent ? 'content' : 'smallContent';
    },
    
    /**
     * @override
     */
    _createCore: function(layoutInfo){
        var chart = this.chart;
        var axes  = chart.axes;
        var xAxis = axes.x;
        var yAxis = axes.y;
        
        // Full grid lines
        if(xAxis.option('Visible') && xAxis.option('Grid')) {
            this.xGridRule = this._createGridRule(xAxis);
        }
        
        if(yAxis.option('Visible') && yAxis.option('Grid')) {
            this.yGridRule = this._createGridRule(yAxis);
        }
        
        this.base(layoutInfo);

        var plotFrameVisible;
        if(chart.compatVersion() <= 1){
            plotFrameVisible = !!(xAxis.option('EndLine') || yAxis.option('EndLine'));
        } else {
            plotFrameVisible = def.get(chart.options, 'plotFrameVisible', true);
        }
            
        if(plotFrameVisible) {
            this.pvFrameBar = this._createFrame(layoutInfo, axes);
        }
            
        if(xAxis.scaleType !== 'discrete' && xAxis.option('ZeroLine')) {
            this.xZeroLine = this._createZeroLine(xAxis, layoutInfo);
        }

        if(yAxis.scaleType !== 'discrete' && yAxis.option('ZeroLine')) {
            this.yZeroLine = this._createZeroLine(yAxis, layoutInfo);
        }
    },
    
    _createGridRule: function(axis){
        var scale = axis.scale;
        if(scale.isNull){
            return;
        } 
        
        // Composite axis don't fill ticks
        var isDiscrete = axis.role.grouping.isDiscrete();
        var axisPanel  = this.chart.axesPanels[axis.id];
        var rootScene  = axisPanel._getRootScene();
        if(!rootScene){
            return;
        }
        
        var margins   = this._layoutInfo.gridMargins;
        var paddings  = this._layoutInfo.gridPaddings;
        
        var tick_a = axis.orientation === 'x' ? 'left' : 'bottom';
        var len_a  = this.anchorLength(tick_a);
        var obeg_a = this.anchorOrtho(tick_a);
        var oend_a = this.anchorOpposite(obeg_a);
        
        var tick_offset = margins[tick_a] + paddings[tick_a];
        
        var obeg = margins[obeg_a];
        var oend = margins[oend_a];
        
//      TODO: Implement GridCrossesMargin ...
//        var orthoAxis = this._getOrthoAxis(axis.type);
//        if(!orthoAxis.option('GridCrossesMargin')){
//            obeg += paddings[obeg_a];
//            oend += paddings[oend_a];
//        }
        
        var tickScenes = rootScene.leafs().array();
        var tickCount = tickScenes.length;
        if(isDiscrete && tickCount){
            // Grid rules are generated for MAJOR ticks only.
            // For discrete axes, each category
            // has a grid line at the beginning of the band,
            // and an extra end line in the last band
            tickScenes.push(tickScenes[tickCount - 1]);
        }
        
        var wrapper;
        if(this.compatVersion() <= 1){
            wrapper = function(v1f){
                return function(tickScene){
                    return v1f.call(this, tickScene.vars.tick.rawValue);
                };
            };
        }
        
        var pvGridRule = new pvc.visual.Rule(this, this.pvPanel, {
                extensionId: axis.extensionPrefixes.map(function(prefix){ return prefix + 'Grid'; }),
                wrapper:     wrapper
            })
            .lock('data', tickScenes)
            .lock(len_a, null)
            .override('defaultColor', function(){
                return pv.color("#f0f0f0");
            })
            .pvMark
            .lineWidth(1)
            .antialias(true)
            [obeg_a](obeg)
            [oend_a](oend)
            .zOrder(-12)
            ;
        
        if(isDiscrete){
            var halfStep = scale.range().step / 2;
            pvGridRule
                .lock(tick_a, function(tickScene){
                    var tickPosition = tick_offset + scale(tickScene.vars.tick.value);
                    
                    // Use **pvMark** index, cause the last two scenes report the same index.
                    var isLastLine = this.index === tickCount;
                    
                    return tickPosition + (isLastLine ? halfStep : -halfStep);
                })
                ;
        } else {
            pvGridRule
                .lock(tick_a, function(tickScene){
                    return tick_offset + scale(tickScene.vars.tick.value);
                });
        }
        
        return pvGridRule;
    },
    
    /* zOrder
     *
     * TOP
     * -------------------
     * Axis Rules:     0
     * Line/Dot/Area Content: -7
     * Frame/EndLine: -8
     * ZeroLine:      -9   <<------
     * Content:       -10 (default)
     * Grid:      -12
     * -------------------
     * BOT
     */
    
    _createFrame: function(layoutInfo, axes){
        if(axes.base.scale.isNull || 
           (axes.ortho.scale.isNull && (!axes.ortho2 || axes.ortho2.scale.isNull))){
            return;
        }
                
        var margins = layoutInfo.gridMargins;
        var left   = margins.left;
        var right  = margins.right;
        var top    = margins.top;
        var bottom = margins.bottom;
        
        // TODO: Implement GridCrossesMargin ...
        // Need to find the correct bounding box.
        // xScale(xScale.domain()[0]) -> xScale(xScale.domain()[1])
        // and
        // yScale(yScale.domain()[0]) -> yScale(yScale.domain()[1])
        var extensionIds = [];
        if(this.compatVersion() <= 1){
            extensionIds.push('xAxisEndLine');
            extensionIds.push('yAxisEndLine');
        }
        
        extensionIds.push('plotFrame');
        
        return new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: extensionIds
            })
            .pvMark
            .lock('left',   left)
            .lock('right',  right)
            .lock('top',    top)
            .lock('bottom', bottom)
            .lock('fillStyle', null)
            .strokeStyle("#666666")
            .lineWidth(1)
            .antialias(false)
            .zOrder(-8)
            ;
    },
    
    _createZeroLine: function(axis, layoutInfo){
        var scale = axis.scale;
        if(!scale.isNull){
            var domain = scale.domain();
    
            // Domain crosses zero?
            if(domain[0] * domain[1] < -1e-12){
                // TODO: Implement GridCrossesMargin ...
                
                var a = axis.orientation === 'x' ? 'left' : 'bottom';
                var len_a  = this.anchorLength(a);
                var obeg_a = this.anchorOrtho(a);
                var oend_a = this.anchorOpposite(obeg_a);
                
                var margins = layoutInfo.gridMargins;
                var paddings = layoutInfo.gridPaddings;
                
                var zeroPosition = margins[a] + paddings[a] + scale(0);
                
                var obeg = margins[obeg_a];
                var oend = margins[oend_a];
                
                var rootScene = new pvc.visual.Scene(null, {
                        panel: this 
                    });
                
                return new pvc.visual.Rule(this, this.pvPanel, {
                        extensionId: axis.extensionPrefixes.map(function(prefix){ return prefix + 'ZeroLine'; })
                    })
                    .lock('data', [rootScene])
                    .lock(len_a,  null)
                    .lock(obeg_a, obeg)
                    .lock(oend_a, oend)
                    .lock(a,      zeroPosition)
                    .override('defaultColor', function(){
                        return pv.color("#666666");
                    })
                    .pvMark
                    .lineWidth(1)
                    .antialias(true)
                    .zOrder(-9)
                    ;
            }
        }
    },

    _getOrthoAxis: function(type){
        var orthoType = type === 'base' ? 'ortho' : 'base';
        return this.chart.axes[orthoType];
    },
    
    /*
     * @override
     */
    _getDatumsOnRect: function(datumMap, rect, keyArgs){
        // TODO: this is done for x and y axis only, which is ok for now,
        // as only discrete axes use selection and
        // multiple axis are only continuous...
        var chart = this.chart,
            xAxisPanel = chart.axesPanels.x,
            yAxisPanel = chart.axesPanels.y,
            xDatumMap,
            yDatumMap;

        //1) x axis
        if(xAxisPanel){
            xDatumMap = new def.Map();
            xAxisPanel._getDatumsOnRect(xDatumMap, rect, keyArgs);
            if(!xDatumMap.count) {
                xDatumMap = null;
            }
        }

        //2) y axis
        if(yAxisPanel){
            yDatumMap = new def.Map();
            yAxisPanel._getOwnDatumsOnRect(yDatumMap, rect, keyArgs);
            if(!yDatumMap.count) {
                yDatumMap = null;
            }
        }

        // Rubber band selects on both axes?
        if(xDatumMap && yDatumMap) {
            xDatumMap.intersect(yDatumMap, /* into */ datumMap);
            
            keyArgs.toggle = true;

            // Rubber band selects over any of the axes?
        } else if(xDatumMap) {
            datumMap.copy(xDatumMap);
        } else if(yDatumMap) {
            datumMap.copy(yDatumMap);
        } else {
            chart.plotPanelList.forEach(function(plotPanel){
                plotPanel._getDatumsOnRect(datumMap, rect, keyArgs);
            }, this);
        }
    }
});

def
.type('pvc.CartesianAbstractPanel', pvc.PlotPanel)
.init(function(chart, parent, plot, options) {
    
    // Prevent the border from affecting the box model,
    // providing a static 0 value, independently of the actual drawn value...
    //this.borderWidth = 0;
    
    this.base(chart, parent, plot, options);
    
    var axes = this.axes;
    
    function addAxis(axis){
        axes[axis.type] = axis;
        
        // TODO: are these really needed??
        axes[axis.orientedId] = axis;
        if(axis.v1SecondOrientedId){
            axes[axis.v1SecondOrientedId] = axis;
        }
    }
    
    addAxis(chart.getAxis('base',  plot.option('BaseAxis' ) - 1));
    addAxis(chart.getAxis('ortho', plot.option('OrthoAxis') - 1));
    
    // ----------------
    
    // Initialize paddings from **chart** axes offsets
    // TODO: move this to the chart??
    var paddings = {};
    var hasAny = false;
    
    function setSide(side, pct){
        var value = paddings[side];
        if(value == null || pct > value){
            hasAny = true;
            paddings[side] = pct;
        }
    }
    
    function processAxis(axis){
        var offset = axis && axis.option('Offset');
        if(offset != null && offset > 0 && offset < 1) {
            if(axis.orientation === 'x'){
                setSide('left',  offset);
                setSide('right', offset);
            } else {
                setSide('top',    offset);
                setSide('bottom', offset);
            }
        }
    }
    
    var chartAxes = chart.axesByType;
    
    ['base', 'ortho'].forEach(function(type){
        var typeAxes = chartAxes[type];
        if(typeAxes){
            typeAxes.forEach(processAxis);
        }
    });
    
    if(hasAny){
        this.offsetPaddings = paddings;
    }
})
.add({
    
    offsetPaddings: null,
    
    _calcLayout: function(layoutInfo){
        layoutInfo.requestPaddings = this._calcRequestPaddings(layoutInfo);
    },
    
    _calcRequestPaddings: function(layoutInfo){
        var op = this.offsetPaddings;
        if(!op){
            return;
        }

        var rp = this.chart._getAxesRoundingPaddings();
        var clientSize = layoutInfo.clientSize;
        var paddings   = layoutInfo.paddings;
        
        var reqPad = {};
        pvc.Sides.names.forEach(function(side){
            var len_a = pvc.BasePanel.orthogonalLength[side];
            
            var clientLen  = clientSize[len_a];
            var paddingLen = paddings[len_a];
            
            var len = clientLen + paddingLen;
            
            // Only request offset-padding if the rp.side is not locked
            if(!rp[side + 'Locked']){
                var offset   = len * (op[side] || 0);
                var rounding = clientLen * (rp[side] || 0);
            
                reqPad[side] = Math.max(offset - rounding, 0);
            } else {
                reqPad[side] = 0;
            }
        }, this);
        
        return reqPad;
    },
    
    /**
     * @override
     */
    _createCore: function() {
        // Send the panel behind the axis, title and legend, panels
        this.pvPanel.zOrder(-10);
        
        var hideOverflow;
        var contentOverflow = this.chart.options.leafContentOverflow || 'auto';
        if(contentOverflow === 'auto'){
            // Overflow
            hideOverflow =
                def
                .query(['ortho', 'base'])
                .select(function(axisType) { return this.axes[axisType]; }, this)
                .any(function(axis){
                    return axis.option('FixedMin') != null ||
                           axis.option('FixedMax') != null;
                });
        } else {
            hideOverflow = (contentOverflow === 'hidden');
        }
        
        if (hideOverflow){
            // Padding area is used by bubbles and other vizs without problem
            this.pvPanel.borderPanel.overflow('hidden');
        }
    },
    
    _getVisibleData: function(){
        return this.chart._getVisibleData(this.dataPartValue);
    }
});/**
 * CategoricalAbstract is the base class for all categorical or timeseries
 */
def
.type('pvc.CategoricalAbstract', pvc.CartesianAbstract)
.init(function(options){
    
    this.base(options);

    var parent = this.parent;
    if(parent) {
        this._catRole = parent._catRole;
    }
})
.add({
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
      
        this._catRole = this._addVisualRole('category', this._getCategoryRoleSpec());
    },
    
    _getCategoryRoleSpec: function(){
        return {
            isRequired: true, 
            defaultDimension: 'category*', 
            autoCreateDimension: true 
        };
    },
    
    _generateTrendsDataCellCore: function(newDatums, dataCell, trendInfo){
        var serRole = this._serRole;
        var xRole   = this._catRole;
        var yRole   = dataCell.role;
        var trendOptions = dataCell.trend;
        
        this._warnSingleContinuousValueRole(yRole);
        
        var dataPartDimName = this._dataPartRole.firstDimensionName();
        var yDimName = yRole.firstDimensionName();
        var xDimName;
        var isXDiscrete = xRole.isDiscrete();
        if(!isXDiscrete){
            xDimName = xRole.firstDimensionName();
        }
        
        var sumKeyArgs = { zeroIfNone: false };
        var ignoreNullsKeyArgs = {ignoreNulls: false};
                
        // Visible data grouped by category and then series
        var data = this._getVisibleData(dataCell.dataPartValue);
        
        // TODO: It is usually the case, but not certain, that the base axis' 
        // dataCell(s) span "all" data parts.
        // The data that will be shown in the base scale...
        // Ideally the base scale would already be set up...
        var allPartsData   = this._getVisibleData(null, ignoreNullsKeyArgs);
        var allCatDataRoot = allPartsData.flattenBy(xRole, ignoreNullsKeyArgs);
        var allCatDatas    = allCatDataRoot._children;
        
        // For each series...
        def
        .scope(function(){
            return (serRole && serRole.isBound())   ?
                   data.flattenBy(serRole).children() : // data already only contains visible data
                   def.query([null]) // null series
                   ;
        })
        .each(genSeriesTrend, this);
          
        function genSeriesTrend(serData1){
            var funX = isXDiscrete ? 
                       null : // means: "use *index* as X value"
                       function(allCatData){
                           return allCatData.atoms[xDimName].value;
                       };

            var funY = function(allCatData){
                var group = data._childrenByKey[allCatData.key];
                if(group && serData1){
                    group = group._childrenByKey[serData1.key];
                }
                
                // When null, the data point ends up being ignored
                return group ? group.dimensions(yDimName).sum(sumKeyArgs) : null;
            };
            
            var options = def.create(trendOptions, {
                rows: def.query(allCatDatas),
                x: funX,
                y: funY
            });
            
            var trendModel = trendInfo.model(options);
            
            // If a label has already been registered, it is preserved... (See BaseChart#_fixTrendsLabel)
            var dataPartAtom = data.owner
                                .dimensions(dataPartDimName)
                                .intern(this.root._firstTrendAtomProto);
            
            if(trendModel){
                // At least one point...
                // Sample the line on each x and create a datum for it
                // on the 'trend' data part
                allCatDatas.forEach(function(allCatData, index){
                    var trendX = isXDiscrete ? 
                                 index :
                                 allCatData.atoms[xDimName].value;
                    
                    var trendY = trendModel.sample(trendX, funY(allCatData), index);
                    if(trendY != null){
                        var catData   = data._childrenByKey[allCatData.key];
                        var efCatData = catData || allCatData;
                        
                        var atoms;
                        var proto = catData;
                        if(serData1){
                            var catSerData = catData && 
                                             catData._childrenByKey[serData1.key];
                            
                            if(catSerData){
                                atoms = Object.create(catSerData._datums[0].atoms);
                            } else {
                                // Missing data point
                                atoms = Object.create(efCatData._datums[0].atoms);
                                
                                // Now copy series atoms
                                def.copyOwn(atoms, serData1.atoms);
                            }
                        } else {
                            // Series is unbound
                            atoms = Object.create(efCatData._datums[0].atoms);
                        }
                        
                        atoms[yDimName] = trendY;
                        atoms[dataPartDimName] = dataPartAtom;
                        
                        var newDatum = new pvc.data.Datum(efCatData.owner, atoms);
                        newDatum.isVirtual = true;
                        newDatum.isTrend   = true;
                        newDatum.trendType = trendInfo.type;
                        
                        newDatums.push(newDatum);
                    }
                }, this);
            }
        }
    },
    
    _interpolateDataCell: function(dataCell){
        var nullInterpMode = dataCell.nullInterpolationMode;
        if(nullInterpMode){
            var InterpType;
            switch(dataCell.nullInterpolationMode){
                case 'linear': InterpType = pvc.data.LinearInterpolationOper; break;
                case 'zero':   InterpType = pvc.data.ZeroInterpolationOper;   break;
                case 'none':   break;
                default: throw def.error.argumentInvalid('nullInterpolationMode', '' + nullInterpMode);
            }
        
            if(InterpType){
                this._warnSingleContinuousValueRole(dataCell.role);
                
                // TODO: It is usually the case, but not certain, that the base axis' 
                // dataCell(s) span "all" data parts.
                var visibleData = this._getVisibleData(dataCell.dataPartValue);
                if(visibleData.childCount() > 0){
                    var allPartsData = this._getVisibleData(null, {ignoreNulls: false});
                    new InterpType(
                         allPartsData,
                         visibleData, 
                         this._catRole,
                         this._serRole,
                         dataCell.role,
                         true) // dataCell.isStacked
                    .interpolate();
                }
            }
        }
    },
    
    /**
     * @override
     */
    _createVisibleData: function(dataPartValue, keyArgs){
        var serGrouping = this._serRole && this._serRole.flattenedGrouping();
        var catGrouping = this._catRole.flattenedGrouping();
        var partData    = this.partData(dataPartValue);
        
        var ignoreNulls = def.get(keyArgs, 'ignoreNulls');
        
        // Allow for more caching when isNull is null
        var groupKeyArgs = { visible: true, isNull: ignoreNulls ? false : null};
        
        return serGrouping ?
               // <=> One multi-dimensional, two-levels data grouping
               partData.groupBy([catGrouping, serGrouping], groupKeyArgs) :
               partData.groupBy(catGrouping, groupKeyArgs);
    },
    
    /**
     * Obtains the extent of the specified value axis' role
     * and data part values.
     *
     * <p>
     * Takes into account that values are shown grouped per category.
     * </p>
     *
     * <p>
     * The fact that values are stacked or not, per category,
     * is also taken into account.
     * Each data part can have its own stacking.
     * </p>
     *
     * <p>
     * When more than one datum exists per series <i>and</i> category,
     * the sum of its values is considered.
     * </p>
     *
     * @param {pvc.visual.CartesianAxis} valueAxis The value axis.
     * @param {pvc.visual.Role} valueDataCell The data cell.
     * @type object
     *
     * @override
     */
    _getContinuousVisibleCellExtent: function(valueAxis, valueDataCell){
        var valueRole = valueDataCell.role;
        
        switch(valueRole.name){
            case 'series':// (series throws in base)
            case 'category':
                /* Special case.
                 * The category role's single dimension belongs to the grouping dimensions of data.
                 * As such, the default method is adequate
                 * (gets the extent of the value dim on visible data).
                 *
                 * Continuous baseScale's, like timeSeries go this way.
                 */
                return this.base(valueAxis, valueDataCell);
        }
        
        this._warnSingleContinuousValueRole(valueRole);
        
        var dataPartValue = valueDataCell.dataPartValue;
        var valueDimName = valueRole.firstDimensionName();
        var data = this._getVisibleData(dataPartValue);
        var useAbs = valueAxis.scaleUsesAbs();
        
        if(valueAxis.type !== 'ortho' || !valueDataCell.isStacked){
            return data.leafs()
                       .select(function(serGroup){
                           var value = serGroup.dimensions(valueDimName).sum();
                           return useAbs && value < 0 ? -value : value;
                        })
                       .range();
        }

        /*
         * data is grouped by category and then by series
         * So direct childs of data are category groups
         */
        return data.children()
            /* Obtain the value extent of each category */
            .select(function(catGroup){
                var range = this._getStackedCategoryValueExtent(catGroup, valueDimName, useAbs);
                if(range){
                    return {range: range, group: catGroup};
                }
            }, this)
            .where(def.notNully)

            /* Combine the value extents of all categories */
            .reduce(function(result, rangeInfo){
                return this._reduceStackedCategoryValueExtent(
                            result,
                            rangeInfo.range,
                            rangeInfo.group);
            }.bind(this), null);

//        The following would not work:
//        var max = data.children()
//                    .select(function(catGroup){ return catGroup.dimensions(valueDimName).sum(); })
//                    .max();
//
//        return max != null ? {min: 0, max: max} : null;
    },

    /**
     * Obtains the extent of a value dimension in a given category group.
     * The default implementation determines the extent by separately
     * summing negative and positive values.
     * Supports {@link #_getContinuousVisibleExtent}.
     */
    _getStackedCategoryValueExtent: function(catGroup, valueDimName, useAbs){
        var posSum = null,
            negSum = null;

        catGroup
            .children()
            /* Sum all datum's values on the same leaf */
            .select(function(serGroup){
                var value = serGroup.dimensions(valueDimName).sum();
                return useAbs && value < 0 ? -value : value;
            })
            /* Add to positive or negative totals */
            .each(function(value){
                // Note: +null === 0
                if(value != null){
                    if(value >= 0){
                        posSum += value;
                    } else {
                        negSum += value;
                    }
                }
            });

        if(posSum == null && negSum == null){
            return null;
        }

        return {max: posSum || 0, min: negSum || 0};
    },
    
    /**
     * Reduce operation of category ranges, into a global range.
     *
     * The default implementation performs a range "union" operation.
     *
     * Supports {@link #_getContinuousVisibleExtent}.
     */
    _reduceStackedCategoryValueExtent: function(result, catRange, catGroup){
        return pvc.unionExtents(result, catRange);
    },
    
    _coordinateSmallChartsLayout: function(scopesByType){
        // TODO: optimize the case were 
        // the title panels have a fixed size and
        // the x and y FixedMin and FixedMax are all specified...
        // Don't need to coordinate in that case.

        this.base(scopesByType);
        
        // Force layout and retrieve sizes of
        // * title panel
        // * y panel if column or global scope (column scope coordinates x scales, but then the other axis' size also affects the layout...)
        // * x panel if row    or global scope
        var titleSizeMax  = 0;
        var titleOrthoLen;
        
        var axisIds = null;
        var sizesMaxByAxisId = {}; // {id:  {axis: axisSizeMax, title: titleSizeMax} }
        
        // Calculate maximum sizes
        this.children.forEach(function(childChart){
            
            childChart.basePanel.layout();
            
            var size;
            var panel = childChart.titlePanel;
            if(panel){
                if(!titleOrthoLen){
                    titleOrthoLen = panel.anchorOrthoLength();
                }
                
                size = panel[titleOrthoLen];
                if(size > titleSizeMax){
                    titleSizeMax = size;
                }
            }
            
            // ------
            
            var axesPanels = childChart.axesPanels;
            if(!axisIds){
                axisIds = 
                    def
                    .query(def.ownKeys(axesPanels))
                    .where(function(alias){ 
                        return alias === axesPanels[alias].axis.id; 
                    })
                    .select(function(id){
                        // side effect
                        sizesMaxByAxisId[id] = {axis: 0, title: 0};
                        return id;
                    })
                    .array();
            }
            
            axisIds.forEach(function(id){
                var axisPanel = axesPanels[id];
                var sizes = sizesMaxByAxisId[id];
                
                var ol = axisPanel.axis.orientation === 'x' ? 'height' : 'width';
                size = axisPanel[ol];
                if(size > sizes.axis){
                    sizes.axis = size;
                }
                
                var titlePanel = axisPanel.titlePanel;
                if(titlePanel){
                    size = titlePanel[ol];
                    if(size > sizes.title){
                        sizes.title = size;
                    }
                }
            });
        }, this);
        
        // Apply the maximum sizes to the corresponding panels
        this.children.forEach(function(childChart){
            
            if(titleSizeMax > 0){
                var panel  = childChart.titlePanel;
                panel.size = panel.size.clone().set(titleOrthoLen, titleSizeMax);
            }
            
            // ------
            
            var axesPanels = childChart.axesPanels;
            axisIds.forEach(function(id){
                var axisPanel = axesPanels[id];
                var sizes = sizesMaxByAxisId[id];
                
                var ol = axisPanel.axis.orientation === 'x' ? 'height' : 'width';
                axisPanel.size = axisPanel.size.clone().set(ol, sizes.axis);

                var titlePanel = axisPanel.titlePanel;
                if(titlePanel){
                    titlePanel.size = titlePanel.size.clone().set(ol, sizes.title);
                }
            });
            
            // Invalidate their previous layout
            childChart.basePanel.invalidateLayout();
        }, this);
    },
    
    defaults: {
     // Ortho <- value role
        // TODO: this should go somewhere else
        orthoAxisOrdinal: false // when true => ortho axis gets the series role (instead of the value role)
    }
});

def
.type('pvc.CategoricalAbstractPanel', pvc.CartesianAbstractPanel)
.init(function(chart, parent, plot, options){
    
    this.base(chart, parent, plot, options);
    
    this.stacked = plot.option('Stacked');
});
/**
 * AxisPanel panel.
 */
def
.type('pvc.AxisPanel', pvc.BasePanel)
.init(function(chart, parent, axis, options) {
    
    options = def.create(options, {
        anchor: axis.option('Position')
    });
    
    var anchor = options.anchor || this.anchor;
    
    // Prevent the border from affecting the box model,
    // providing a static 0 value, independently of the actual drawn value...
    //this.borderWidth = 0;
    
    this.base(chart, parent, options);
    
    this.axis = axis;
    this.roleName = axis.role.name;
    this.isDiscrete = axis.role.isDiscrete();
    this._extensionPrefix = axis.extensionPrefixes;
    
    if(this.labelSpacingMin == null){
        // The user tolerance for "missing" stuff is much smaller with discrete stuff
        this.labelSpacingMin = this.isDiscrete ? 0.1 : 1.5; // em
    }
    
    if(this.showTicks == null){
        this.showTicks = !this.isDiscrete;
    }

    if(options.font === undefined){
        var extFont = this._getConstantExtension('label', 'font');
        if(extFont){
            this.font = extFont;
        }
    }
    
    if(options.tickLength === undefined){
        // height or width
        var tickLength = +this._getConstantExtension('ticks', this.anchorOrthoLength(anchor)); 
        if(!isNaN(tickLength) && isFinite(tickLength)){
            this.tickLength = tickLength;
        }
    }
})
.add({
    pvRule:     null,
    pvTicks:    null,
    pvLabel:    null,
    pvRuleGrid: null,
    pvScale:    null,
    
    isDiscrete: false,
    roleName: null,
    axis: null,
    anchor: "bottom",
    tickLength: 6,
    
    scale: null,
    ruleCrossesMargin: true,
    font: '9px sans-serif', // label font
    labelSpacingMin: null,
    // To be used in linear scales
    domainRoundMode: 'none',
    desiredTickCount: null,
    tickExponentMin:  null,
    tickExponentMax:  null,
    showMinorTicks:   true,
    showTicks:        null,
    
    // bullet:       "\u2022"
    // middle-point: "\u00B7"
    // this.isAnchorTopOrBottom() ? ".." : ":"
    hiddenLabelText: "\u00B7",
    
    _isScaleSetup: false,
    
    _createLogInstanceId: function(){
        return this.base() + " - " + this.axis.id;
    },
    
    getTicks: function(){
        return this._layoutInfo && this._layoutInfo.ticks;
    },
    
    _calcLayout: function(layoutInfo){
        
        var scale = this.axis.scale;
        
        if(!this._isScaleSetup){
            this.pvScale = scale;
            this.scale   = scale; // TODO: At least HeatGrid depends on this. Maybe Remove?
            
            this.extend(scale, "scale"); // TODO - review extension interface
            
            this._isScaleSetup = true;
        }
        
        if(scale.isNull){
            layoutInfo.axisSize = 0;
        } else {
            this._calcLayoutCore(layoutInfo);
        }
        
        return this.createAnchoredSize(layoutInfo.axisSize, layoutInfo.clientSize);
    },
    
    _calcLayoutCore: function(layoutInfo){
        // Fixed axis size?
        var axisSize = layoutInfo.desiredClientSize[this.anchorOrthoLength()];
        
        layoutInfo.axisSize = axisSize; // may be undefined
        
        if (this.isDiscrete && this.useCompositeAxis){
            if(layoutInfo.axisSize == null){
                layoutInfo.axisSize = 50;
            }
        } else {
            layoutInfo.textAngle  = def.number.as(this._getExtension('label', 'textAngle'),  0);
            layoutInfo.textMargin = def.number.as(this._getExtension('label', 'textMargin'), 3);
            
            /* I  - Calculate ticks
             * --> layoutInfo.{ ticks, ticksText, maxTextWidth } 
             */
            this._calcTicks();
            
            if(this.scale.type === 'discrete'){
                this._calcDiscreteTicksHidden();
            }
            
            /* II - Calculate NEEDED axisSize so that all tick's labels fit */
            this._calcAxisSizeFromLabel(); // -> layoutInfo.requiredAxisSize, layoutInfo.labelBBox
            
            if(layoutInfo.axisSize == null){
                layoutInfo.axisSize = layoutInfo.requiredAxisSize;
            }
            
            /* III - Calculate Trimming Length if: FIXED/NEEDED > AVAILABLE */
            this._calcMaxTextLengthThatFits();
            
            
            /* IV - Calculate overflow paddings */
            this._calcOverflowPaddings();
        }
    },
    
    _calcAxisSizeFromLabel: function(){
        this._calcLabelBBox();
        this._calcAxisSizeFromLabelBBox();
    },

    // --> layoutInfo.labelBBox
    _calcLabelBBox: function(){
        var layoutInfo = this._layoutInfo;
        
        var align = this._getExtension('label', 'textAlign');
        if(typeof align !== 'string'){
            align = this.isAnchorTopOrBottom() ? 
                    "center" : 
                    (this.anchor == "left") ? "right" : "left";
        }
        
        var baseline = this._getExtension('label', 'textBaseline');
        if(typeof baseline !== 'string'){
            switch (this.anchor) {
                case "right":
                case "left":
                case "center":
                    baseline = "middle";
                    break;
                    
                case "bottom": 
                    baseline = "top";
                    break;
                  
                default:
                //case "top": 
                    baseline = "bottom";
                    //break;
            }
        } 
        
        return (layoutInfo.labelBBox = pvc.text.getLabelBBox(
                        layoutInfo.maxTextWidth != null ? layoutInfo.maxTextWidth : layoutInfo._maxTextWidth, 
                        layoutInfo.textHeight, 
                        align, 
                        baseline, 
                        layoutInfo.textAngle, 
                        layoutInfo.textMargin));
    },
    
    _calcAxisSizeFromLabelBBox: function(){
        var layoutInfo = this._layoutInfo;
        var labelBBox = layoutInfo.labelBBox;
        
        // The length not over the plot area
        var length = this._getLabelBBoxQuadrantLength(labelBBox, this.anchor);

        // --------------
        
        var axisSize = this.tickLength + length; 
        
        // Add equal margin on both sides?
        var angle = labelBBox.sourceAngle;
        if(!(angle === 0 && this.isAnchorTopOrBottom())){
            // Text height already has some free space in that case
            // so no need to add more.
            axisSize += this.tickLength;
        }
        
        layoutInfo.requiredAxisSize = axisSize;
    },
    
    _getLabelBBoxQuadrantLength: function(labelBBox, quadrantSide){
        // labelBBox coordinates are relative to the anchor point
        // x points to the right, y points downwards
        //        T
        //        ^
        //        |
        // L  <---0--->  R
        //        |
        //        v
        //        B
        //
        //  +--> xx
        //  |
        //  v yy
        //
        //  x1 <= x2
        //  y1 <= y2
        // 
        //  p1 +-------+
        //     |       |
        //     +-------+ p2
        
        var length;
        switch(quadrantSide){
            case 'left':   length = -labelBBox.x;  break;
            case 'right':  length =  labelBBox.x2; break;
            case 'top':    length = -labelBBox.y;  break;
            case 'bottom': length =  labelBBox.y2; break;
        }
        
        return Math.max(length, 0);
    },
    
    _calcOverflowPaddings: function(){
        if(!this._layoutInfo.canChange){
            if(pvc.debug >= 2){
                this._log("[WARNING] Layout cannot change. Skipping calculation of overflow paddings.");
            }
            return;
        }

        if(!this._layoutInfo.labelBBox){
            this._calcLabelBBox();
        }
        
        this._calcOverflowPaddingsFromLabelBBox();
    },
    
    _calcOverflowPaddingsFromLabelBBox: function(){
        var overflowPaddings = null;
        
        var layoutInfo = this._layoutInfo;
        var ticks = layoutInfo.ticks;
        var tickCount = ticks.length;
        if(tickCount){
            var paddings   = layoutInfo.paddings;
            var labelBBox  = layoutInfo.labelBBox;
            var isTopOrBottom = this.isAnchorTopOrBottom();
            var begSide    = isTopOrBottom ? 'left'  : 'top'   ;
            var endSide    = isTopOrBottom ? 'right' : 'bottom';
            var isDiscrete = this.scale.type === 'discrete';
            
            var clientLength = layoutInfo.clientSize[this.anchorLength()];
            this.axis.setScaleRange(clientLength);
            
            var sideTickOffset;
            if(isDiscrete){
                var halfBand = this.scale.range().step / 2; // don't use .band, cause it does not include margins... 
                sideTickOffset = def.set({}, 
                        begSide, halfBand,
                        endSide, halfBand);
            } else {
                sideTickOffset = def.set({}, 
                        begSide, this.scale(ticks[0]),
                        endSide, clientLength - this.scale(ticks[tickCount - 1]));
            }
            
            [begSide, endSide].forEach(function(side){
                var overflowPadding  = this._getLabelBBoxQuadrantLength(labelBBox, side);
                if(overflowPadding > 0){
                    // Discount real paddings that this panel already has
                    // cause they're, in principle, empty space that can be occupied.
                    overflowPadding -= (paddings[side] || 0);
                    if(overflowPadding > 0){
                        // On discrete axes, half of the band width is not yet overflow.
                        overflowPadding -= sideTickOffset[side];
                        if(overflowPadding > 1){ // small delta to avoid frequent relayouts... (the reported font height often causes this kind of "error" in BBox calculation)
                            if(isDiscrete){
                                // reduction of space causes reduction of band width
                                // which in turn usually causes the overflowPadding to increase,
                                // as the size of the text usually does not change.
                                // Ask a little bit more to hit the target faster.
                                overflowPadding *= 1.05;
                            }
                            
                            if(!overflowPaddings){ 
                                overflowPaddings= {}; 
                            }
                            overflowPaddings[side] = overflowPadding;
                        }
                    }
                }
            }, this);
            
            if(pvc.debug >= 6 && overflowPaddings){
                this._log("OverflowPaddings = " + pvc.stringify(overflowPaddings));
            }
        }
        
        layoutInfo.overflowPaddings = overflowPaddings;
    },
    
    _calcMaxTextLengthThatFits: function(){
        var layoutInfo = this._layoutInfo;
        
        if(this.compatVersion() <= 1){
            layoutInfo.maxTextWidth = null;
            return;
        }
        
        var availableClientLength = layoutInfo.clientSize[this.anchorOrthoLength()];
        
        var efSize = Math.min(layoutInfo.axisSize, availableClientLength);
        if(efSize >= (layoutInfo.requiredAxisSize - this.tickLength)){ // let overflow by at most tickLength
            // Labels fit
            // Clear to avoid any unnecessary trimming
            layoutInfo.maxTextWidth = null;
        } else {
            // Text may not fit. 
            // Calculate maxTextWidth where text is to be trimmed.
            var labelBBox = layoutInfo.labelBBox;
            
            // Now move backwards, to the max text width...
            var maxOrthoLength = efSize - 2 * this.tickLength;
            
            // A point at the maximum orthogonal distance from the anchor
            // Points in the outwards orthogonal direction.
            var mostOrthoDistantPoint;
            var parallelDirection;
            switch(this.anchor){
                case 'left':
                    parallelDirection = pv.vector(0, 1);
                    mostOrthoDistantPoint = pv.vector(-maxOrthoLength, 0);
                    break;
                
                case 'right':
                    parallelDirection = pv.vector(0, 1);
                    mostOrthoDistantPoint = pv.vector(maxOrthoLength, 0);
                    break;
                    
                case 'top':
                    parallelDirection = pv.vector(1, 0);
                    mostOrthoDistantPoint = pv.vector(0, -maxOrthoLength);
                    break;
                
                case 'bottom':
                    parallelDirection = pv.vector(1, 0);
                    mostOrthoDistantPoint = pv.vector(0, maxOrthoLength);
                    break;
            }
            
            var orthoOutwardsDir = mostOrthoDistantPoint.norm();
            
            // Intersect the line that passes through mostOrthoDistantPoint,
            // and has the direction parallelDirection with 
            // the top side and with the bottom side of the *original* label box.
            var corners = labelBBox.source.points();
            var botL = corners[0];
            var botR = corners[1];
            var topR = corners[2];
            var topL = corners[3];
            
            var topLRSideDir = topR.minus(topL);
            var botLRSideDir = botR.minus(botL);
            var intersect = pv.SvgScene.lineIntersect;
            var botI = intersect(mostOrthoDistantPoint, parallelDirection, botL, botLRSideDir);
            var topI = intersect(mostOrthoDistantPoint, parallelDirection, topL, topLRSideDir);
            
            // botI and topI will replace two of the original BBox corners
            // The original corners that are at the side of the 
            // the line that passes at mostOrthoDistantPoint and has direction parallelDirection (dividing line)
            // further away to the axis, are to be replaced.
            
            var sideLRWidth  = labelBBox.sourceTextWidth;
            var maxTextWidth = sideLRWidth;
            
            var botLI = botI.minus(botL);
            var botLILen = botLI.length();
            if(botLILen <= sideLRWidth && botLI.dot(topLRSideDir) >= 0){
                // botI is between botL and botR
                // One of botL and botR is in one side and 
                // the other at the other side of the dividing line.
                // On of the sides will be cut-off.
                // The cut-off side is the one whose points have the biggest
                // distance measured relative to orthoOutwardsDir
                
                if(botL.dot(orthoOutwardsDir) < botR.dot(orthoOutwardsDir)){
                    // botR is farther, so is on the cut-off side
                    maxTextWidth = botLILen; // surely, botLILen < maxTextWidth
                } else {
                    maxTextWidth = botI.minus(botR).length(); // idem
                }
            }
            
            var topLI = topI.minus(topL);
            var topLILen = topLI.length();
            if(topLILen <= sideLRWidth && topLI.dot(topLRSideDir) >= 0){
                // topI is between topL and topR
                
                if(topL.dot(orthoOutwardsDir) < topR.dot(orthoOutwardsDir)){
                    // topR is farther, so is on the cut-off side
                    maxTextWidth = Math.min(maxTextWidth, topLILen);
                } else {
                    maxTextWidth = Math.min(maxTextWidth, topI.minus(topR).length());
                }
            }
            
            // One other detail.
            // When align (anchor) is center,
            // just cutting on one side of the label original box
            // won't do, because when text is centered, the cut we make in length
            // ends up distributed by both sides...
            if(labelBBox.sourceAlign === 'center'){
                var cutWidth = sideLRWidth - maxTextWidth;
                
                // Cut same width on the opposite side. 
                maxTextWidth -= cutWidth;
            }
            
            layoutInfo.maxTextWidth = maxTextWidth;
            
            if(pvc.debug >= 3){
                this._log("Trimming labels' text at length " + maxTextWidth.toFixed(2) + "px maxOrthoLength=" + maxOrthoLength.toFixed(2) + "px");
            }
        }
    },
    
    // ----------------
    
    _calcTicks: function(){
        var layoutInfo = this._layoutInfo;
        
        layoutInfo.textHeight = pv.Text.fontHeight(this.font);
        layoutInfo.maxTextWidth = null;
        
        // Reset scale to original unrounded domain
        this.axis.setTicks(null);
        
        // update maxTextWidth, ticks and ticksText
        switch(this.scale.type){
            case 'discrete':   this._calcDiscreteTicks();   break;
            case 'timeSeries': this._calcTimeSeriesTicks(); break;
            case 'numeric':    this._calcNumberTicks(layoutInfo); break;
            default: throw def.error.operationInvalid("Undefined axis scale type"); 
        }
        
        this.axis.setTicks(layoutInfo.ticks);
        
        var clientLength = layoutInfo.clientSize[this.anchorLength()];
        this.axis.setScaleRange(clientLength);
        
        if(layoutInfo.maxTextWidth == null){
            layoutInfo.maxTextWidth = 
                def.query(layoutInfo.ticksText)
                    .select(function(text){ return pv.Text.measure(text, this.font).width; }, this)
                    .max();
        }
        
        // Backup value, cause the first one is cleared to prevent label trimming
        // but the max text width is important for other uses
        layoutInfo._maxTextWidth = layoutInfo.maxTextWidth;
    },
    
    _calcDiscreteTicks: function(){
        var layoutInfo = this._layoutInfo;
        var role = this.chart.visualRoles(this.roleName);
        var data = role.flatten(this.chart.data, {visible: true});
        
        layoutInfo.data  = data;
        layoutInfo.ticks = data._children;
        
        // If the discrete data is of a single Date value type,
        // we want to format the category values with an appropriate precision,
        // instead of showing the default label.
        var format, dimType;
        var grouping = role.grouping;
        if(grouping.isSingleDimension && 
           (dimType = grouping.firstDimensionType()) &&
           (dimType.valueType === Date)){
            // Calculate precision from data dimension's extent 
            var extent = data.dimensions(dimType.name).extent();
            // At least two atoms are required
            if(extent && extent.min !== extent.max){
                var scale = new pv.Scale.linear(extent.min.value, extent.max.value);
                // Force "best" tick and tick format determination 
                scale.ticks();
                var tickFormatter = this.axis.option('TickFormatter');
                if(tickFormatter){
                    scale.tickFormatter(tickFormatter);
                }
                
                format = function(child){ return scale.tickFormat(child.value); };
            }
        }
        
        if(!format){
            format = function(child){ return child.absLabel; };
        }
        
        layoutInfo.ticksText = data._children.map(format);
    },
    
    

    _calcTimeSeriesTicks: function(){
        this._calcContinuousTicks(this._layoutInfo/*, this.desiredTickCount */); // not used
    },
    
    _calcNumberTicks: function(layoutInfo){
        var desiredTickCount = this.desiredTickCount;
        if(desiredTickCount == null){
            if(this.isAnchorTopOrBottom()){
                this._calcNumberHTicks();
                return;
            }
            
            desiredTickCount = this._calcNumberVDesiredTickCount();
        }
        
        this._calcContinuousTicks(this._layoutInfo, desiredTickCount);
    },
    
    // --------------
    
    _calcContinuousTicks: function(ticksInfo, desiredTickCount){
        this._calcContinuousTicksValue(ticksInfo, desiredTickCount);
        this._calcContinuousTicksText(ticksInfo);
    },
    
    _calcContinuousTicksValue: function(ticksInfo, desiredTickCount){
        ticksInfo.ticks = this.scale.ticks(
                                desiredTickCount, {
                                    roundInside:       this.domainRoundMode !== 'tick',
                                    numberExponentMin: this.tickExponentMin,
                                    numberExponentMax: this.tickExponentMax
                                });
    },
    
    _calcContinuousTicksText: function(ticksInfo){
        
        ticksInfo.ticksText = def.query(ticksInfo.ticks)
                               .select(function(tick){ return this.scale.tickFormat(tick); }, this)
                               .array();
    },
    
    // --------------
    
    _calcDiscreteTicksHidden: function(){
        return this._tickIncludeModulo = this._calcDiscreteTicksHiddenCore();
    },
    
    _calcDiscreteTicksHiddenCore: function(){
        var mode = this.axis.option('OverlappedLabelsMode');
        if(mode !== 'hide'){
            return 1;
        }
        
        var layoutInfo = this._layoutInfo;
        var ticks = layoutInfo.ticks;
        var tickCount = ticks.length;
        if(tickCount <= 1) {
            return 1;
        }
        
        // Calculate includeModulo depending on labelSpacingMin
            
        // scale is already setup
        
        // How much label anchors are separated from each other
        // (in the direction of the axis)
        var b = this.scale.range().step; // don't use .band, cause it does not include margins...
        
        // Height of label box
        var h = layoutInfo.textHeight;
        
        // Width of label box
        var w = layoutInfo.maxTextWidth;  // Should use the average value?
        
        if(!(w > 0 && h > 0 && b > 0)){
            return 1;
        }
        
        // Minimum space that the user wants separating 
        // the closest edges of the bounding boxes of two consecutive labels, 
        // measured perpendicularly to the label text direction.
        var sMin = h * this.labelSpacingMin /* parameter in em */;
        
        // The angle that the text makes to the x axis (clockwise,y points downwards) 
        var a = layoutInfo.textAngle;
        
        var isTopOrBottom = this.isAnchorTopOrBottom();
        var sinOrCos =  isTopOrBottom ? 'sin' : 'cos';
        var cosOrSin = !isTopOrBottom ? 'sin' : 'cos';
        
        var tickIncludeModulo = 1;
        do{
            // Effective distance between anchors,
            // that results from showing only 
            // one in every 'tickIncludeModulo' ticks.
            var bEf = tickIncludeModulo * b;
            
            // The space that separates the closest edges, 
            // that are parallel to the text direction,
            // of the bounding boxes of 
            // two consecutive (not skipped) labels. 
            var sBase  = bEf * Math.abs(Math[sinOrCos](a)) - h;
            
            // The same, for the edges orthogonal to the text direction
            var sOrtho = bEf * Math.abs(Math[cosOrSin](a)) - w;
            
            // At least one of this distances must respect sMin
            if(sBase >= sMin || sOrtho >= sMin){
                break;
            }
            
            // Hide one more tick
            tickIncludeModulo++;
            
            // Are there still at least two ticks left?
        } while(Math.ceil(tickCount / tickIncludeModulo) > 1);
        
        if(tickIncludeModulo > 1 && pvc.debug >= 3){
            this._log("Showing only one in every " + tickIncludeModulo + " tick labels");
        }
        
        return tickIncludeModulo;
    },
    
    // --------------
    
    _calcNumberVDesiredTickCount: function(){
        var layoutInfo = this._layoutInfo;
        var lineHeight = layoutInfo.textHeight * (1 + Math.max(0, this.labelSpacingMin /*em*/)); 
        var clientLength = layoutInfo.clientSize[this.anchorLength()];
        
        return Math.max(1, ~~(clientLength / lineHeight));
    },
    
    _calcNumberHTicks: function(){
        var layoutInfo = this._layoutInfo;
        var clientLength = layoutInfo.clientSize[this.anchorLength()];
        var spacing = layoutInfo.textHeight * Math.max(0, this.labelSpacingMin/*em*/);
        var desiredTickCount = this._calcNumberHDesiredTickCount(spacing);
        
        var doLog = (pvc.debug >= 7);
        var dir, prevResultTickCount;
        var ticksInfo, lastBelow, lastAbove;
        do {
            if(doLog){ this._log("calculateNumberHTicks TickCount IN desired = " + desiredTickCount); }
            
            ticksInfo = {};
            
            this._calcContinuousTicksValue(ticksInfo, desiredTickCount);
            
            var ticks = ticksInfo.ticks;
            
            var resultTickCount = ticks.length;
            
            if(ticks.exponentOverflow){
                // TODO: Check if this part of the algorithm is working ok
                
                // Cannot go anymore in the current direction, if any
                if(dir == null){
                    if(ticks.exponent === this.exponentMin){
                        lastBelow = ticksInfo;
                        dir =  1;
                    } else {
                        lastAbove = ticksInfo;
                        dir = -1;
                    }
                } else if(dir === 1){
                    if(lastBelow){
                        ticksInfo = lastBelow;
                    }
                    break;
                } else { // dir === -1
                    if(lastAbove){
                        ticksInfo = lastAbove;
                    }
                    break;
                }
                
            } else if(prevResultTickCount == null || resultTickCount !== prevResultTickCount){
                
                if(doLog){ 
                    this._log("calculateNumberHTicks TickCount desired/resulting = " + desiredTickCount + " -> " + resultTickCount); 
                }
                
                prevResultTickCount = resultTickCount;
                
                this._calcContinuousTicksText(ticksInfo);
                
                var length = this._calcNumberHLength(ticksInfo, spacing);
                var excessLength = ticksInfo.excessLength = length - clientLength;
                var pctError = ticksInfo.error = Math.abs(excessLength / clientLength);
                
                if(doLog){
                    this._log("calculateNumberHTicks error=" + (excessLength >= 0 ? "+" : "-") + (ticksInfo.error * 100).toFixed(0) + "% count=" + resultTickCount + " step=" + ticks.step);
                    this._log("calculateNumberHTicks Length client/resulting = " + clientLength + " / " + length + " spacing = " + spacing);
                }
                
                if(excessLength > 0){
                    // More ticks than can fit
                    if(desiredTickCount === 1){
                        // Edge case
                        // Cannot make dir = -1 ...
                        if(resultTickCount === 3 && pctError <= 1){
                         // remove the middle tick
                            ticksInfo.ticks.splice(1,1);
                            ticksInfo.ticksText.splice(1,1);
                            ticksInfo.ticks.step *= 2;
                        } else {
                         // keep only the first tick
                            ticksInfo.ticks.length = 1;
                            ticksInfo.ticksText.length = 1;
                        }
                        delete ticksInfo.maxTextWidth;
                        break;
                    }
                    
                    if(lastBelow){
                        // We were below max length and then overshot...
                        // Choose the best conforming one
                        // Always choose the one that conforms to MinSpacing
                        //if(pctError > lastBelow.error){
                            ticksInfo = lastBelow;
                        //}
                        break;
                    }
                    
                    // Backup last *above* calculation
                    lastAbove = ticksInfo;
                    
                    dir = -1;
                } else {
                    // Less ticks than could fit
                    
                    if(pctError <= 0.05 || dir === -1){
                        // Acceptable
                        // or
                        // Already had exceeded the length and had decided to go down
//                        if(lastAbove && pctError > lastAbove.error){
//                            ticksInfo = lastAbove;
//                        }
                        
                        break;
                    }
                    
                    // Backup last *below* calculation
                    lastBelow = ticksInfo;
                                            
                    dir = +1;
                }
            }
            
            desiredTickCount += dir;
        } while(true);
        
        if(ticksInfo){
            layoutInfo.ticks = ticksInfo.ticks;
            layoutInfo.ticksText = ticksInfo.ticksText;
            layoutInfo.maxTextWidth = ticksInfo.maxTextWidth;
            
            if(pvc.debug >= 5){
                this._log("calculateNumberHTicks RESULT error=" + (ticksInfo.excessLength >= 0 ? "+" : "-") + (ticksInfo.error * 100).toFixed(0) + "% count=" + ticksInfo.ticks.length + " step=" + ticksInfo.ticks.step);
            }
        }
        
        if(doLog){ this._log("calculateNumberHTicks END"); }
    },
    
    _calcNumberHDesiredTickCount: function(spacing){
        // The initial tick count is determined 
        // from the formatted min and max values of the domain.
        var layoutInfo = this._layoutInfo;
        var domainTextLength = this.scale.domain().map(function(tick){
                tick = +tick.toFixed(2); // crop some decimal places...
                var text = this.scale.tickFormat(tick);
                return pv.Text.measure(text, this.font).width;
            }, this);
        
        var avgTextLength = Math.max((domainTextLength[1] + domainTextLength[0]) / 2, layoutInfo.textHeight);
        
        var clientLength = layoutInfo.clientSize[this.anchorLength()];
        
        return Math.max(1, ~~(clientLength / (avgTextLength + spacing)));
    },
    
    _calcNumberHLength: function(ticksInfo, spacing){
        // Measure full width, with spacing
        var ticksText = ticksInfo.ticksText;
        var maxTextWidth = 
            def.query(ticksText)
                .select(function(text){ 
                    return pv.Text.measure(text, this.font).width; 
                }, this)
                .max();
        
        /*
         * Include only half the text width on edge labels, 
         * cause centered labels are the most common scenario.
         * 
         * |w s ww s ww s w|
         * 
         */
        return Math.max(maxTextWidth, (ticksText.length - 1) * (maxTextWidth + spacing));
    },
    
    _createCore: function() {
        if(this.scale.isNull){
            return;
        }
        
        // Range
        var clientSize = this._layoutInfo.clientSize;
        var paddings   = this._layoutInfo.paddings;
        
        var begin_a = this.anchorOrtho();
        var end_a   = this.anchorOpposite(begin_a);
        var size_a  = this.anchorOrthoLength(begin_a);
        
        var rMin = this.ruleCrossesMargin ? -paddings[begin_a] : 0;
        var rMax = clientSize[size_a] + (this.ruleCrossesMargin ? paddings[end_a] : 0);
        var rSize = rMax - rMin;
        
        var ruleParentPanel = this.pvPanel;

        this._rSize = rSize;
        
        var rootScene = this._getRootScene();
        
        this.pvRule = new pvc.visual.Rule(this, this.pvPanel, {
                extensionId: 'rule'
            })
            .lock('data', [rootScene])
            .override('defaultColor', def.fun.constant("#666666"))
            // ex: anchor = bottom
            .lock(this.anchorOpposite(), 0) // top (of the axis panel)
            .lock(begin_a, rMin )  // left
            .lock(size_a,  rSize) // width
            .pvMark
            .zOrder(30)
            .strokeDasharray(null) // don't inherit from parent panel
            .lineCap('square')     // So that begin/end ticks better join with the rule
            ;

        if (this.isDiscrete){
            if(this.useCompositeAxis){
                this.renderCompositeOrdinalAxis();
            } else {
                this.renderOrdinalAxis();
            }
        } else {
            this.renderLinearAxis();
        }
    },
  
    _getExtensionId: function(){
        return ''; // NOTE: this is different from specifying null
    },
    
    _getRootScene: function(){
        if(!this._rootScene){
            var rootScene = 
                this._rootScene = 
                new pvc.visual.CartesianAxisRootScene(null, {
                    panel: this, 
                    group: this._getRootData()
                });
            
            var layoutInfo = this._layoutInfo;
            var ticksText = layoutInfo.ticksText;
            if (this.isDiscrete){
                if(this.useCompositeAxis){
                    this._buildCompositeScene(rootScene);
                } else {
                    layoutInfo.ticks.forEach(function(tickData, index){
                        new pvc.visual.CartesianAxisTickScene(rootScene, {
                            group:     tickData,
                            tick:      tickData.value,
                            tickRaw:   tickData.rawValue,
                            tickLabel: ticksText[index]
                        });
                    });
                }
            } else {
                layoutInfo.ticks.forEach(function(majorTick, index){
                    new pvc.visual.CartesianAxisTickScene(rootScene, {
                        tick:      majorTick,
                        tickRaw:   majorTick,
                        tickLabel: ticksText[index]
                    });
                }, this);
            }
        }
        
        return this._rootScene;
    },
    
    _buildCompositeScene: function(rootScene){
        
        var isV1Compat = this.compatVersion() <= 1;
         
        // Need this for code below not to throw when drawing the root
        rootScene.vars.tick = new pvc.visual.ValueLabelVar('', "");
        
        recursive(rootScene);
        
        function recursive(scene){
            var data = scene.group;
            if(isV1Compat){
                // depending on the specific version the
                // properties nodeLabel and label existed as well
                var tickVar = scene.vars.tick;
                scene.nodeValue = scene.value = tickVar.rawValue;
                scene.nodeLabel = scene.label = tickVar.label;
            }
            
            if(data.childCount()){
                data
                    .children()
                    .each(function(childData){
                        var childScene = new pvc.visual.CartesianAxisTickScene(scene, {
                            group:     childData,
                            tick:      childData.value,
                            tickRaw:   childData.rawValue,
                            tickLabel: childData.label
                        });
                        
                        recursive(childScene);
                    });
            }
        }
    },
    
    _getRootData: function(){
        var chart = this.chart;
        var data  = chart.data;
        
        if (this.isDiscrete && this.useCompositeAxis){
            var orientation = this.anchor;
            var reverse     = orientation == 'bottom' || orientation == 'left';
            data  = chart.visualRoles(this.roleName)
                         .select(data, {visible: true, reverse: reverse});
        }
        
        return data;
    },
    
    _getOrthoScale: function(){
        var orthoType = this.axis.type === 'base' ? 'ortho' : 'base';
        return this.chart.axes[orthoType].scale; // index 0
    },

    _getOrthoAxis: function(){
        var orthoType = this.axis.type === 'base' ? 'ortho' : 'base';
        return this.chart.axes[orthoType]; // index 0
    },
    
    renderOrdinalAxis: function(){
        var myself = this,
            scale = this.scale,
            hiddenLabelText   = this.hiddenLabelText,
            anchorOpposite    = this.anchorOpposite(),
            anchorLength      = this.anchorLength(),
            anchorOrtho       = this.anchorOrtho(),
            anchorOrthoLength = this.anchorOrthoLength(),
            layoutInfo        = this._layoutInfo,
            pvRule            = this.pvRule,
            ticks             = layoutInfo.ticks,
            data              = layoutInfo.data,
            itemCount         = layoutInfo.ticks.length,
            rootScene         = this._getRootScene(),
            includeModulo     = this._tickIncludeModulo,
            isV1Compat        = this.compatVersion() <= 1;
        
        rootScene.vars.tickIncludeModulo = includeModulo;
        rootScene.vars.hiddenLabelText   = hiddenLabelText;
        
        var wrapper;
        if(isV1Compat){
            // For use in child marks of pvTicksPanel
            var DataElement = function(tickVar){
                this.value = 
                this.absValue = tickVar.rawValue;
                this.nodeName = '' + (this.value || '');
                this.path = this.nodeName ? [this.nodeName] : [];
                this.label = 
                this.absLabel = tickVar.label;    
            };
            
            DataElement.prototype.toString = function(){
                return ''+this.value;
            };
            
            wrapper = function(v1f){
                return function(tickScene){
                    // Fix index due to the introduction of 
                    // pvTicksPanel panel.
                    var markWrapped = Object.create(this);
                    markWrapped.index = this.parent.index;
                    
                    return v1f.call(markWrapped, new DataElement(tickScene.vars.tick));
                };
            };
        }
        
        // Ticks correspond to each data in datas.
        // Ticks are drawn at the center of each band.
        
        var pvTicksPanel = new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: 'ticksPanel'
            })
            .lock('data', rootScene.childNodes)
            // This non-extendable property stores
            //  if the tick would be hidden by
            //  virtue of the includeModulo effect.
            .localProperty('hidden')
            .lockMark('hidden', function(){ // for use by
                return (this.index % includeModulo) !== 0;
            })
            .lock(anchorOpposite, 0) // top (of the axis panel)
            .lockMark(anchorOrtho, function(tickScene){
                return scale(tickScene.vars.tick.value);
            })
            .lock('strokeDasharray', null)
            .lock('strokeStyle', null)
            .lock('fillStyle',   null)
            .lock('lineWidth',   0)
            .pvMark
            .zOrder(20) // below axis rule
            ;
        
        if(isV1Compat || this.showTicks){
            var pvTicks = this.pvTicks = new pvc.visual.Rule(this, pvTicksPanel, {
                    extensionId: 'ticks',
                    wrapper:  wrapper
                })
                .lock('data')            // Inherited    
                // By default is visible unless the includeModulo hides it
                .intercept('visible', function(){
                    var visible = this.delegateExtension();
                    if(visible === undefined){
                        visible = !this.pvMark.parent.hidden();
                    }
                    return visible;
                })
                .optional('lineWidth', 1)
                .lock(anchorOpposite,  0) // top
                .lock(anchorOrtho,     0) // left
                .lock(anchorLength,    null)
                .optional(anchorOrthoLength, this.tickLength * 2/3) // slightly smaller than continuous ticks
                .override('defaultColor', function(type){
                    if(isV1Compat) {
                        return pv.Color.names.transparent;
                    }
                    
                    // Inherit ticks color from rule
                    // Control visibility through .visible or lineWidth
                    return pvRule.scene ? 
                           pvRule.scene[0].strokeStyle : 
                           "#666666";
                })
                .pvMark
                ;
        }
        
        // Determine anchored text properties
        var baseline;
        var align;
        switch(this.anchor){
            case 'top':
                align = 'center';
                baseline = 'bottom';
                break;
                
            case 'bottom':
                align = 'center';
                baseline = 'top';
                break;
                
            case 'left': 
                align = 'right';
                baseline = 'middle';
                break;
            
            case 'right': 
                align = 'left';
                baseline = 'middle';
                break;
        }
        
        var font = this.font;
        
        var maxTextWidth = this._layoutInfo.maxTextWidth;
        if(!isFinite(maxTextWidth)){
            maxTextWidth = 0;
        }
        
        // An pv anchor on pvTick is not used, on purpose,
        // cause if it were, hidding the tick with .visible,
        // would mess the positioning of the label...
        this.pvLabel = new pvc.visual.Label(
            this,
            pvTicksPanel,
            {
                extensionId: 'label',
                noClick:       false,
                noDoubleClick: false,
                noSelect:      false,
                noTooltip:    false,
                noHover:       false, // TODO: to work, scenes would need a common root
                wrapper:       wrapper,
                tooltipArgs:   {
                    // TODO: should be an option whether a data tooltip is desired
                    buildTooltip: function(context){ return context.scene.vars.tick.label; },
                    isLazy: false,
                    
                    options: {
                        gravity: this._calcTipsyGravity()
                    }
                }
            })
            .pvMark
            .zOrder(40) // above axis rule
            
            .lock(anchorOpposite, this.tickLength)
            .lock(anchorOrtho,    0)
            
            .font(font)
            .textStyle("#666666")
            .textAlign(align)
            .textBaseline(baseline)
            
            .text(function(tickScene){
                var text;
                if(this.parent.hidden()){
                    text = tickScene.vars.hiddenLabelText;
                } else {
                    text = tickScene.vars.tick.label;
                    if(maxTextWidth){
                        text = pvc.text.trimToWidthB(maxTextWidth, text, font, "..", false);
                    }
                }
                
                return text;
             })
            ;
        
        this._debugTicksPanel(pvTicksPanel);
    },
    
    _debugTicksPanel: function(pvTicksPanel){
        if(pvc.debug >= 16){ // one more than general debug box model
            var corners = this._layoutInfo.labelBBox.source.points();
            
            // Close the path
            if(corners.length > 1){
                // not changing corners on purpose
                corners = corners.concat(corners[0]);
            }
            
            pvTicksPanel
                // Single-point panel (w=h=0)
                .add(pv.Panel)
                    [this.anchorOpposite()](this.tickLength)
                    [this.anchorOrtho()](0)
                    [this.anchorLength()](0)
                    [this.anchorOrthoLength()](0)
                    .fillStyle(null)
                    .strokeStyle(null)
                    .lineWidth(0)
                 .add(pv.Line)
                    .visible(function(){
                        var gp = this.parent.parent;
                        return !gp.hidden || !gp.hidden(); 
                     })
                    .data(corners)
                    .left(function(p){ return p.x; })
                    .top (function(p){ return p.y; })
                    .strokeStyle('red')
                    .lineWidth(0.5)
                    .strokeDasharray('-')
                    ;
        }
    },
    
    renderLinearAxis: function(){
        // NOTE: Includes time series, 
        // so "tickScene.vars.tick.value" may be a number or a Date object...
        
        var scale  = this.scale,
            orthoAxis  = this._getOrthoAxis(),
            orthoScale = orthoAxis.scale,
            pvRule     = this.pvRule,
            anchorOpposite    = this.anchorOpposite(),
            anchorLength      = this.anchorLength(),
            anchorOrtho       = this.anchorOrtho(),
            anchorOrthoLength = this.anchorOrthoLength(),
            rootScene         = this._getRootScene();
        
        var wrapper;
        if(this.compatVersion() <= 1){
            wrapper = function(v1f){
                return function(tickScene){
                    // Fix index due to the introduction of 
                    // pvTicksPanel panel.
                    var markWrapped = Object.create(this);
                    markWrapped.index = this.parent.index;
                    
                    return v1f.call(markWrapped, tickScene.vars.tick.rawValue);
                };
            };
        }
        
        var pvTicksPanel = new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: 'ticksPanel'
            })
            .lock('data', rootScene.childNodes)
            .lock(anchorOpposite, 0) // top (of the axis panel)
            .lockMark(anchorOrtho, function(tickScene){
                return scale(tickScene.vars.tick.value);
            })
            .lock('strokeStyle', null)
            .lock('fillStyle',   null)
            .lock('lineWidth',   0)
            .pvMark
            .zOrder(20) // below axis rule
            ;
        
        if(this.showTicks){
            // (MAJOR) ticks
            var pvTicks = this.pvTicks = new pvc.visual.Rule(this, pvTicksPanel, {
                    extensionId: 'ticks',
                    wrapper: wrapper
                })
                .lock('data') // Inherited
                .override('defaultColor', function(){
                    // Inherit axis color
                    // Control visibility through color or through .visible
                    // NOTE: the rule only has one scene/instance
                    return pvRule.scene ? 
                           pvRule.scene[0].strokeStyle :
                           "#666666";
                })
                .lock(anchorOpposite, 0) // top
                .lock(anchorOrtho,    0) // left
                .lock(anchorLength,   null)
                .optional(anchorOrthoLength, this.tickLength)
                .pvMark
                ;
            
            // MINOR ticks are between major scale ticks
            if(this.showMinorTicks){
                var layoutInfo = this._layoutInfo;
                var ticks      = layoutInfo.ticks;
                var tickCount  = ticks.length;
                // Assume a linear scale
                var minorTickOffset = tickCount > 1 ? 
                        Math.abs(scale(ticks[1]) - scale(ticks[0])) / 2 : 
                        0;
                        
                this.pvMinorTicks = new pvc.visual.Rule(this, this.pvTicks, {
                        extensionId: 'minorTicks',
                        wrapper: wrapper
                    })
                    .lock('data') // Inherited
                    .intercept('visible', function(){
                        // The last minor tick isn't visible - only show between major ticks.
                        // Hide if the previous major tick is hidden.
                        var visible = (this.index < tickCount - 1) && 
                                      (!pvTicks.scene || pvTicks.scene[0].visible);
                        
                        return visible && this.delegateExtension(true);
                    })    
                    .override('defaultColor', function(){
                        // Inherit ticks color
                        // Control visibility through color or through .visible
                        return pvTicks.scene ? 
                               pvTicks.scene[0].strokeStyle : 
                               pv.Color.names.d;
                    })
                    .lock(anchorOpposite, 0) // top
                    .lock(anchorLength,   null)
                    .optional(anchorOrthoLength, this.tickLength / 2)
                    .lockMark(anchorOrtho, minorTickOffset)
                    .pvMark
                    ;
            }
        }
        
        this.renderLinearAxisLabel(pvTicksPanel, wrapper);
        
        this._debugTicksPanel(pvTicksPanel);
    },
    
    renderLinearAxisLabel: function(pvTicksPanel, wrapper){
        // Labels are visible (only) on MAJOR ticks,
        // On first and last tick care is taken
        //  with their H/V alignment so that
        //  the label is not drawn off the chart.

        // Use this margin instead of textMargin, 
        // which affects all margins (left, right, top and bottom).
        // Exception is the small 0.5 textMargin set below...
        var pvTicks = this.pvTicks;
        var anchorOpposite = this.anchorOpposite();
        var anchorOrtho    = this.anchorOrtho();
        
//        var pvLabelAnchor = pvTicks
//            .anchor(this.anchor)
//            .addMargin(this.anchorOpposite(), 2);
        
        var scale = this.scale;
        var font  = this.font;
        
        var maxTextWidth = this._layoutInfo.maxTextWidth;
        if(!isFinite(maxTextWidth)){
            maxTextWidth = 0;
        }
        
        var label = this.pvLabel = new pvc.visual.Label(this, pvTicksPanel, {
                extensionId: 'label',
                wrapper: wrapper
            })
            .lock('data') // inherited
            .pvMark

            .lock(anchorOpposite, this.tickLength)
            .lock(anchorOrtho,    0)
            .zOrder(40) // above axis rule
            .text(function(tickScene){
                var text = tickScene.vars.tick.label;
                if(maxTextWidth){
                    text = pvc.text.trimToWidthB(maxTextWidth, text, font, '..', false);
                }
                return text;
             })
            .font(this.font)
            .textStyle("#666666")
            //.textMargin(0.5) // Just enough for some labels not to be cut (vertical)
            ;
        
        // Label alignment
        var rootPanel = this.pvPanel.root;
        if(this.isAnchorTopOrBottom()){
            label
                .textBaseline(anchorOpposite)
                .textAlign(function(tickScene){
                    var absLeft;
                    if(this.index === 0){
                        absLeft = label.toScreenTransform().transformHPosition(label.left());
                        if(absLeft <= 0){
                            return 'left'; // the "left" of the text is anchored to the tick's anchor
                        }
                    } else if(this.index === tickScene.parent.childNodes.length - 1) { 
                        absLeft = label.toScreenTransform().transformHPosition(label.left());
                        if(absLeft >= rootPanel.width()){
                            return 'right'; // the "right" of the text is anchored to the tick's anchor
                        }
                    }
                    
                    return 'center';
                });
        } else {
            label
                .textAlign(anchorOpposite)
                .textBaseline(function(tickScene){
                    var absTop;
                    if(this.index === 0){
                        absTop = label.toScreenTransform().transformVPosition(label.top());
                        if(absTop >= rootPanel.height()){
                            return 'bottom'; // the "bottom" of the text is anchored to the tick's anchor
                        }
                    } else if(this.index === tickScene.parent.childNodes.length - 1) { 
                        absTop = label.toScreenTransform().transformVPosition(label.top());
                        if(absTop <= 0){
                            return 'top'; // the "top" of the text is anchored to the tick's anchor
                        }
                    }
                    
                    return 'middle';
                });
        }
    },

    // ----------------------------
    // Click / Double-click
    _onV1Click: function(context, handler){
        if(this.isDiscrete && this.useCompositeAxis){
            handler.call(context.pvMark, context.scene, context.event);
        }
    },
    
    _onV1DoubleClick: function(context, handler){
        if(this.isDiscrete && this.useCompositeAxis){
            handler.call(context.pvMark, context.scene, context.event);
        }
    },
    
    /** @override */
    _getSelectableMarks: function(){
        if(this.isDiscrete && this.isVisible && this.pvLabel){
            return [this.pvLabel];
        }
    },

    /////////////////////////////////////////////////
    //begin: composite axis
    renderCompositeOrdinalAxis: function(){
        var myself = this,
            isTopOrBottom = this.isAnchorTopOrBottom(),
            axisDirection = isTopOrBottom ? 'h' : 'v',
            diagDepthCutoff = 2, // depth in [-1/(n+1), 1]
            vertDepthCutoff = 2,
            font = this.font;
        
        var diagMargin = pv.Text.fontHeight(font) / 2;
        
        var layout = this._pvLayout = this.getLayoutSingleCluster();

        // See what will fit so we get consistent rotation
        layout.node
            .def("fitInfo", null)
            .height(function(tickScene, e, f){
                // Just iterate and get cutoff
                var fitInfo = pvc.text.getFitInfo(tickScene.dx, tickScene.dy, tickScene.vars.tick.label, font, diagMargin);
                if(!fitInfo.h){
                    if(axisDirection === 'v' && fitInfo.v){ // prefer vertical
                        vertDepthCutoff = Math.min(diagDepthCutoff, tickScene.depth);
                    } else {
                        diagDepthCutoff = Math.min(diagDepthCutoff, tickScene.depth);
                    }
                }

                this.fitInfo(fitInfo);

                return tickScene.dy;
            });

        // label space (left transparent)
        // var lblBar =
        layout.node.add(pv.Bar)
            .fillStyle('rgba(127,127,127,.001)')
            .strokeStyle(function(tickScene){
                if(tickScene.maxDepth === 1 || !tickScene.maxDepth) { // 0, 0.5, 1
                    return null;
                }

                return "rgba(127,127,127,0.3)"; //non-terminal items, so grouping is visible
            })
            .lineWidth( function(tickScene){
                if(tickScene.maxDepth === 1 || !tickScene.maxDepth) {
                    return 0;
                }
                return 0.5; //non-terminal items, so grouping is visible
            })
            .text(function(tickScene){
                return tickScene.vars.tick.label;
            });

        //cutoffs -> snap to vertical/horizontal
        var H_CUTOFF_ANG = 0.30,
            V_CUTOFF_ANG = 1.27;
        
        var align = isTopOrBottom ?
                    "center" :
                    (this.anchor == "left") ? "right" : "left";
        
        var wrapper;
        if(this.compatVersion() <= 1){
            wrapper = function(v1f){
                return function(tickScene){
                    return v1f.call(this, tickScene);
                };
            };
        }
        
        // draw labels and make them fit
        this.pvLabel = new pvc.visual.Label(this, layout.label, {
                extensionId: 'label',
                noClick:       false,
                noDoubleClick: false,
                noSelect:      false,
                noTooltip:    false,
                noHover:       false, // TODO: to work, scenes would need a common root
                wrapper:       wrapper,
                tooltipArgs:   {
                    // TODO: should be an option whether a data tooltip is desired
                    isLazy: false,
                    buildTooltip: function(context){ return context.scene.vars.tick.label; },
                    
                    options: {
                        gravity: this._calcTipsyGravity(),
                        offset:  diagMargin * 2
                    }
                }
            })
            .pvMark
            .def('lblDirection','h')
            .textAngle(function(tickScene){
                if(tickScene.depth >= vertDepthCutoff && tickScene.depth < diagDepthCutoff){
                    this.lblDirection('v');
                    return -Math.PI/2;
                }

                if(tickScene.depth >= diagDepthCutoff){
                    var tan = tickScene.dy/tickScene.dx;
                    var angle = Math.atan(tan);
                    //var hip = Math.sqrt(tickScene.dy*tickScene.dy + tickScene.dx*tickScene.dx);

                    if(angle > V_CUTOFF_ANG){
                        this.lblDirection('v');
                        return -Math.PI/2;
                    }

                    if(angle > H_CUTOFF_ANG) {
                        this.lblDirection('d');
                        return -angle;
                    }
                }

                this.lblDirection('h');
                return 0;//horizontal
            })
            .textMargin(1)
            //override central alignment for horizontal text in vertical axis
            .textAlign(function(tickScene){
                return (axisDirection != 'v' || tickScene.depth >= vertDepthCutoff || tickScene.depth >= diagDepthCutoff)? 'center' : align;
            })
            .left(function(tickScene) {
                return (axisDirection != 'v' || tickScene.depth >= vertDepthCutoff || tickScene.depth >= diagDepthCutoff)?
                     tickScene.x + tickScene.dx/2 :
                     ((align == 'right')? tickScene.x + tickScene.dx : tickScene.x);
            })
            .font(font)
            .textStyle("#666666")
            .text(function(tickScene){
                var fitInfo = this.fitInfo();
                var label = tickScene.vars.tick.label;
                switch(this.lblDirection()){
                    case 'h':
                        if(!fitInfo.h){//TODO: fallback option for no svg
                            return pvc.text.trimToWidth(tickScene.dx, label, font, '..');
                        }
                        break;
                    case 'v':
                        if(!fitInfo.v){
                            return pvc.text.trimToWidth(tickScene.dy, label, font, '..');
                        }
                        break;
                    case 'd':
                       if(!fitInfo.d){
                          //var ang = Math.atan(tickScene.dy/tickScene.dx);
                          var diagonalLength = Math.sqrt(tickScene.dy*tickScene.dy + tickScene.dx*tickScene.dx) ;
                          return pvc.text.trimToWidth(diagonalLength - diagMargin, label, font,'..');
                        }
                        break;
                }
                
                return label;
            })
            ;
    },
    
    getLayoutSingleCluster: function(){
        var rootScene   = this._getRootScene(),
            orientation = this.anchor,
            maxDepth    = rootScene.group.treeHeight,
            depthLength = this._layoutInfo.axisSize;
        
        // displace to take out bogus-root
        maxDepth++;
        
        var baseDisplacement = depthLength / maxDepth,
            margin = maxDepth > 2 ? ((1/12) * depthLength) : 0; // heuristic compensation
        
        baseDisplacement -= margin;
        
        var scaleFactor = maxDepth / (maxDepth - 1),
            orthoLength = pvc.BasePanel.orthogonalLength[orientation];
        
        var displacement = (orthoLength == 'width') ?
                (orientation === 'left' ? [-baseDisplacement, 0] : [baseDisplacement, 0]) :
                (orientation === 'top'  ? [0, -baseDisplacement] : [0, baseDisplacement]);

        this.pvRule
            .strokeStyle(null)
            .lineWidth(0);

        var panel = this.pvRule
            .add(pv.Panel)
                [orthoLength](depthLength)
                .strokeStyle(null)
                .lineWidth(0) //cropping panel
            .add(pv.Panel)
                [orthoLength](depthLength * scaleFactor)
                .strokeStyle(null)
                .lineWidth(0);// panel resized and shifted to make bogus root disappear
        
        panel.transform(pv.Transform.identity.translate(displacement[0], displacement[1]));
        
        // Create with bogus-root
        // pv.Hierarchy must always have exactly one root and
        //  at least one element besides the root
        return panel.add(pv.Layout.Cluster.Fill)
                    .nodes(rootScene.nodes())
                    .orient(orientation);
    },
    
    _calcTipsyGravity: function(){
        switch(this.anchor){
            case 'bottom': return 's';
            case 'top':    return 'n';
            case 'left':   return 'w';
            case 'right':  return 'e';
        }
        return 's';
    }
    // end: composite axis
    /////////////////////////////////////////////////
});
def
.type('pvc.AxisTitlePanel', pvc.TitlePanelAbstract)
.init(function(chart, parent, axis, options) {
    
    this.axis = axis;
    
    this.base(chart, parent, options);
    
    this._extensionPrefix = 
        axis
        .extensionPrefixes
        .map(function(prefix){
            return prefix + 'Title';
        });
})
.add({
    _calcLayout: function(layoutInfo){
        var scale = this.axis.scale;
        if(!scale || scale.isNull){
            return new pvc.Size(0, 0);
        }
        
        return this.base(layoutInfo);
    },
    
    _createCore: function(layoutInfo){
        var scale = this.axis.scale;
        if(!scale || scale.isNull){
            return;
        }
        
        return this.base(layoutInfo);
    }
});

/*
 * Pie chart panel. Generates a pie chart. 
 * 
 * Specific options are: 
 * 
 * <i>valuesVisible</i> - Show or hide slice value. Default: false 
 * 
 * <i>explodedSliceIndex</i> - Index of the slice which is <i>always</i> exploded, or null to explode every slice. Default: null.
 * 
 * <i>explodedOffsetRadius</i> - The radius by which an exploded slice is offset from the center of the pie (in pixels).
 * If one wants a pie with an exploded effect, specify a value in pixels here.
 * If above argument is specified, explodes only one slice, else explodes all. 
 * Default: 0
 * 
 * <i>activeOffsetRadius</i> - Percentage of slice radius to (additionally) explode an active slice.
 * Only used if the chart has option hoverable equal to true.
 * 
 * <i>innerGap</i> - The percentage of (the smallest of) the panel width or height used by the pie. 
 * Default: 0.9 (90%)
 * 
 * Deprecated in favor of options <i>leafContentMargins</i> and <i>leafContentPaddings</i>.
 * 
 * Has the following protovis extension points: 
 * <i>chart_</i> - for the main chart Panel 
 * <i>slice_</i> - for the main pie wedge 
 * <i>sliceLabel_</i> - for the main pie label
 * <i>sliceLinkLine_</i> - for the link lines, for when labelStyle = 'linked'
 * 
 * Example Pie Category Scene extension:
 * pie: {
 *     scenes: {
 *         category: {
 *             sliceLabelMask: "{value} ({value.percent})"
 *         }
 *     }
 * }
 */
def
.type('pvc.PieChartPanel', pvc.PlotPanel)
.init(function(chart, parent, plot, options){
    
    // Before base, just to bring to attention that ValuesMask depends on it
    var labelStyle = plot.option('ValuesLabelStyle');
    
    this.base(chart, parent, plot, options);
    
    this.explodedOffsetRadius = plot.option('ExplodedSliceRadius');
    this.explodedSliceIndex   = plot.option('ExplodedSliceIndex' );
    this.activeOffsetRadius   = plot.option('ActiveSliceRadius'  );
    this.labelStyle           = labelStyle;
    if(labelStyle === 'linked'){
        this.linkInsetRadius     = plot.option('LinkInsetRadius'    );
        this.linkOutsetRadius    = plot.option('LinkOutsetRadius'   );
        this.linkMargin          = plot.option('LinkMargin'         );
        this.linkHandleWidth     = plot.option('LinkHandleWidth'    );
        this.linkLabelSize       = plot.option('LinkLabelSize'      );
        this.linkLabelSpacingMin = plot.option('LinkLabelSpacingMin');
    }
})
.add({
    pvPie: null,
    pvPieLabel: null,
    
    valueRoleName: 'value',
    
    _getV1Datum: function(scene){
        // Ensure V1 tooltip function compatibility 
        var datum = scene.datum;
        if(datum){
            var datumEx = Object.create(datum);
            datumEx.percent = scene.vars.value.percent;
            datum = datumEx;
        }
        
        return datum;
    },
    
    /**
     * @override
     */
    _calcLayout: function(layoutInfo){
        var clientSize   = layoutInfo.clientSize;
        var clientWidth  = clientSize.width;
        var clientRadius = Math.min(clientWidth, clientSize.height) / 2;
        if(!clientRadius){
            return new pvc.Size(0,0);
        }
        
        var center = pv.vector(clientSize.width / 2, clientSize.height / 2);
        
        function resolvePercentRadius(radius){
            return def.between(pvc.PercentValue.resolve(radius, clientRadius), 0, clientRadius);
        }
        
        function resolvePercentWidth(width){
            return def.between(pvc.PercentValue.resolve(width, clientWidth), 0, clientWidth);
        }
        
        // ---------------------
        
        var labelFont = this._getConstantExtension('label', 'font');
        if(!def.string.is(labelFont)){
            labelFont = this.valuesFont;
        }
        
        var maxPieRadius = clientRadius;
        
        if(this.valuesVisible && this.labelStyle === 'linked'){
            // Reserve space for labels and links
            var linkInsetRadius  = resolvePercentRadius(this.linkInsetRadius );
            var linkOutsetRadius = resolvePercentRadius(this.linkOutsetRadius);
            var linkMargin       = resolvePercentWidth (this.linkMargin      );
            var linkLabelSize    = resolvePercentWidth (this.linkLabelSize   );
            
            var textMargin = def.number.to(this._getConstantExtension('label', 'textMargin'), 3);
            var textHeight = pv.Text.fontHeight(labelFont);
            
            var linkHandleWidth = this.linkHandleWidth * textHeight; // em
            linkMargin += linkHandleWidth;
            
            var linkLabelSpacingMin = this.linkLabelSpacingMin * textHeight; // em
            
            var freeWidthSpace = Math.max(0, clientWidth / 2 - clientRadius);
            
            // Radius stolen to pie by link and label
            var spaceH = Math.max(0, linkOutsetRadius + linkMargin + linkLabelSize - freeWidthSpace);
            var spaceV = linkOutsetRadius + textHeight; // at least one line of text (should be half line, but this way there's a small margin...)
            
            var linkAndLabelRadius = Math.max(0, spaceV, spaceH);
            
            // Use the extra width on the label
            //linkLabelSize += freeWidthSpace / 2;
            
            if(linkAndLabelRadius >= maxPieRadius){
                this.valuesVisible = false;
                if(pvc.debug >= 2){
                    this._log("Hiding linked labels due to insufficient space.");
                }
            } else {
                
                maxPieRadius -= linkAndLabelRadius;
                
                layoutInfo.link = {
                    insetRadius:     linkInsetRadius,
                    outsetRadius:    linkOutsetRadius,
                    elbowRadius:     maxPieRadius + linkOutsetRadius,
                    linkMargin:      linkMargin,
                    handleWidth:     linkHandleWidth,
                    labelSize:       linkLabelSize,
                    maxTextWidth:    linkLabelSize - textMargin,
                    labelSpacingMin: linkLabelSpacingMin,
                    textMargin:      textMargin,
                    lineHeight:      textHeight
                };
            }
        } 
        
        // ---------------------
        
        var explodedOffsetRadius = resolvePercentRadius(this.explodedOffsetRadius);
        
        var activeOffsetRadius = 0;
        if(this.chart.options.hoverable){
            activeOffsetRadius = resolvePercentRadius(this.activeOffsetRadius);
        }
        
        var effectOffsetRadius = explodedOffsetRadius + activeOffsetRadius;
        
        var normalPieRadius = maxPieRadius - effectOffsetRadius;
        if(normalPieRadius < 0){
            return new pvc.Size(0,0);
        }
        
        // ---------------------
        
        layoutInfo.center = center;
        layoutInfo.clientRadius = clientRadius;
        layoutInfo.normalRadius = normalPieRadius;
        layoutInfo.explodedOffsetRadius = explodedOffsetRadius;
        layoutInfo.activeOffsetRadius = activeOffsetRadius;
        layoutInfo.labelFont = labelFont;
    },
    
    /**
     * @override
     */
    _createCore: function(layoutInfo) {
        var myself = this;
        var chart = this.chart;
        var options = chart.options;
        var visibleKeyArgs = {visible: true};
        
        var rootScene = this._buildScene();
        var center = layoutInfo.center;
        var normalRadius = layoutInfo.normalRadius;
        
        // ------------
        
        var wrapper;
        var extensionIds = ['slice'];
        if(this.compatVersion() <= 1){
            extensionIds.push(''); // let access as "pie_"
            wrapper = function(v1f){
                return function(pieCatScene){
                    return v1f.call(this, pieCatScene.vars.value.value);
                };
            };
        }
        
        this.pvPie = new pvc.visual.PieSlice(this, this.pvPanel, {
                extensionId: extensionIds,
                center: center,
                activeOffsetRadius: layoutInfo.activeOffsetRadius,
                wrapper: wrapper,
                tooltipArgs:   {
                    options: {
                        useCorners: true,
                        gravity: function(){
                            var isRightPlane = Math.cos(this.midAngle()) >= 0;
                            var isTopPlane   = Math.sin(this.midAngle()) >= 0;
                            return  isRightPlane ?
                                    (isTopPlane ? 'nw' : 'sw') :
                                    (isTopPlane ? 'ne' : 'se')
                                    ;
                        }
                    }
                }
            })
            
            .lock('data', rootScene.childNodes)
            
            .override('angle', function(){ return this.scene.vars.value.angle;  })
            
            .override('baseOffsetRadius', function(){
                var explodeIndex = myself.explodedSliceIndex;
                if (explodeIndex == null || explodeIndex == this.pvMark.index) {
                    return layoutInfo.explodedOffsetRadius;
                }
                
                return this.base();
            })
            
            .lock('outerRadius', function(){ return chart.animate(0, normalRadius); })
            
            .localProperty('innerRadiusEx', pvc.PercentValue.parse)
            
            // In case the inner radius is specified, we better animate it as well
            .intercept('innerRadius', function(scene){
                var innerRadius = this.delegateExtension();
                if(innerRadius == null){
                    var innerRadiusPct = this.pvMark.innerRadiusEx();
                    if(innerRadiusPct != null){
                        innerRadius = pvc.PercentValue.resolve(
                                    innerRadiusPct, 
                                    this.pvMark.outerRadius()) || 0;
                    } else {
                        innerRadius = 0;
                    }
                }
                
                return innerRadius > 0 ? chart.animate(0, innerRadius) : 0;
            })
            .pvMark
            ;
        
        if(this.valuesVisible){
            if(this.labelStyle === 'inside'){
                
                this.pvPieLabel = new pvc.visual.Label(this, this.pvPie.anchor(this.valuesAnchor), {
                        extensionId: 'label',
                        wrapper:     wrapper
                    })
                    .intercept('visible', function(scene){
                        var angle = scene.vars.value.angle;
                        if(angle < 0.001){
                            return false;
                        }
                        
                        return this.delegateExtension(true);
                    })
                    .pvMark
                    .text(function(scene){ return scene.vars.value.sliceLabel; })
                    .textMargin(10);
                
            } else if(this.labelStyle === 'linked') {
                var linkLayout = layoutInfo.link;
                
                rootScene.layoutLinkLabels(layoutInfo);
                
                this.pvLinkPanel = this.pvPanel.add(pv.Panel)
                    .data(rootScene.childNodes)
                    .localProperty('pieSlice')
                    .pieSlice(function(scene){
                        return myself.pvPie.scene[this.index];  
                     })
                    ;
                
                this.pvLinkLine = new pvc.visual.Line(
                    this, 
                    this.pvLinkPanel, 
                    {
                        extensionId:  'linkLine',
                        freePosition:  true,
                        noClick:       true,
                        noDoubleClick: true,
                        noSelect:      true,
                        noTooltip:    true,
                        noHover:       true 
                    })
                    .lockMark('data', function(scene){
                        // Calculate the dynamic dot at the 
                        // slice's middle angle and outer radius...
                        var pieSlice = this.parent.pieSlice();
                        var midAngle = pieSlice.startAngle + pieSlice.angle / 2;
                        var outerRadius = pieSlice.outerRadius - linkLayout.insetRadius;
                        var x = pieSlice.left + outerRadius * Math.cos(midAngle);
                        var y = pieSlice.top  + outerRadius * Math.sin(midAngle);
                        
                        var firstDotScene = scene.childNodes[0];
                        if(!firstDotScene || !firstDotScene._isFirstDynamicScene){
                            firstDotScene = new pvc.visual.PieLinkLineScene(
                                scene, x, y, /* index */ 0);
                            
                            firstDotScene._isFirstDynamicScene = true;
                        } else {
                            firstDotScene.x = x;
                            firstDotScene.y = y;
                        }
                        
                        return scene.childNodes;
                    })
                    .override('defaultColor', function(type){
                        if(type === 'stroke'){
                            return 'black';
                        }
                        return this.base(type);
                    })
                    .override('defaultStrokeWidth', def.fun.constant(0.5))
                    .pvMark
                    .lock('visible')
                    .lock('top',  function(dot){ return dot.y; })
                    .lock('left', function(dot){ return dot.x; })
                    ;
                
                this.pvPieLabel = new pvc.visual.Label(
                    this, 
                    this.pvLinkPanel, 
                    {
                        extensionId:   'label',
                        noClick:       false,
                        noDoubleClick: false,
                        noSelect:      false,
                        noHover:       false
                    })
                    .lockMark('data', function(scene){
                        // Repeat the scene, once for each line
                        return scene.lineScenes; 
                    })
                    .pvMark
                    .lock('visible')
                    .left     (function(scene){ return scene.vars.link.labelX; })
                    .top      (function(scene){ return scene.vars.link.labelY + ((this.index + 1) * linkLayout.lineHeight); }) // must be mark.index because of repeating scene...
                    .textAlign(function(scene){ return scene.vars.link.labelAnchor; })
                    .textMargin(linkLayout.textMargin)
                    .textBaseline('bottom')
                    .text     (function(scene){ return scene.vars.link.labelLines[this.index]; })
                    .fillStyle('red')
                    ;
                
                // <Debug>
                if(pvc.debug >= 20){
                    this.pvPanel.add(pv.Panel)
                        .zOrder(-10)
                        .left  (center.x - layoutInfo.clientRadius)
                        .top   (center.y - layoutInfo.clientRadius)
                        .width (layoutInfo.clientRadius * 2)
                        .height(layoutInfo.clientRadius * 2)
                        .strokeStyle('red')
                    ;
                    
                    // Client Area
                    this.pvPanel
                        .strokeStyle('green');
                    
                    var linkColors = pv.Colors.category10();
                    this.pvLinkLine
                        .segmented(true)
                        .strokeStyle(function(){ return linkColors(this.index); });
                }
                // </Debug>
            }
            
            this.pvPieLabel
                .font(layoutInfo.labelFont);
        }
    },
    
    _getExtensionId: function(){
        // chart is deprecated
        // content coincides, visually in this chart type
        // - actually it shares the same panel...
        
        var extensionIds = [{abs: 'content'}];
        if(this.chart.parent){ 
            extensionIds.push({abs: 'smallContent'});
        }
        
        return extensionIds.concat(this.base());
    },
    
    /**
     * Renders this.pvBarPanel - the parent of the marks that are affected by selection changes.
     * @override
     */
    renderInteractive: function(){
        this.pvPanel.render();
    },

    /**
     * Returns an array of marks whose instances are associated to a datum, or null.
     * @override
     */
    _getSelectableMarks: function(){
        var marks = [this.pvPie];
        if(this.pvPieLabel){
            marks.push(this.pvPieLabel);
        }
        
        return marks;
    },
    
    _buildScene: function(){
        var rootScene  = new pvc.visual.PieRootScene(this);
        
        // v1 property
        this.sum = rootScene.vars.sumAbs.value;
        
        return rootScene;
    }
});

def
.type('pvc.visual.PieRootScene', pvc.visual.Scene)
.init(function(panel){
    var chart = panel.chart;
    var data = chart.visualRoles('category').flatten(chart.data, pvc.data.visibleKeyArgs);
    var colorVarHelper = new pvc.visual.ColorVarHelper(chart, chart._colorRole);
    
    this.base(null, {panel: panel, group: data});
    
    // ---------------
    
    var valueRoleName = panel.valueRoleName;
    var valueDimName  = chart.visualRoles(valueRoleName).firstDimensionName();
    var valueDim      = data.dimensions(valueDimName);
    
    var options = chart.options;
    var percentValueFormat = options.percentValueFormat;
    
    var rootScene = this;
    var sumAbs = 0;
    
    /* Create category scene sub-class */
    var CategSceneClass = def.type(pvc.visual.PieCategoryScene)
        .init(function(categData, value){
            
            // Adds to parent scene...
            this.base(rootScene, {group: categData});
            
            this.vars.category = new pvc.visual.ValueLabelVar(
                    categData.value, 
                    categData.label);

            sumAbs += Math.abs(value);
            
            this.vars.value = new pvc.visual.ValueLabelVar(
                            value,
                            formatValue(value, categData));
            
            colorVarHelper.onNewScene(this, /* isLeaf */ true);
        });
    
    /* Extend with any user extensions */
    panel._extendSceneType('category', CategSceneClass, ['sliceLabel', 'sliceLabelMask']);
    
    /* Create child category scenes */
    data.children().each(function(categData){
        // Value may be negative
        // Don't create 0-value scenes
        var value = categData.dimensions(valueDimName).sum(pvc.data.visibleKeyArgs);
        if(value !== 0){
            new CategSceneClass(categData, value);
        }
    });
    
    // -----------
    
    // TODO: should this be in something like: chart.axes.angle.scale ?
    this.angleScale = pv.Scale
                        .linear(0, sumAbs)
                        .range(0, 2 * Math.PI)
                        .by1(Math.abs);
    
    this.vars.sumAbs = new pvc.visual.ValueLabelVar(sumAbs, formatValue(sumAbs));
    
    this.childNodes.forEach(function(categScene){
        completeBuildCategScene.call(categScene);
    });
    
    function formatValue(value, categData){
        if(categData){
            var datums = categData._datums;
            if(datums.length === 1){
                // Prefer to return the already formatted/provided label
                return datums[0].atoms[valueDimName].label;
            }
        }
        
        return valueDim.format(value);
    }
    
    /** 
     * @private 
     * @instance pvc.visual.PieCategoryScene
     */
    function completeBuildCategScene(){
        var valueVar = this.vars.value;
        
        // Calculate angle (span)
        valueVar.angle = this.parent.angleScale(valueVar.value);
        
        // Create percent sub-var of the value var
        var percent = Math.abs(valueVar.value) / sumAbs;
        
        valueVar.percent = new pvc.visual.ValueLabelVar(
                percent,
                percentValueFormat(percent));
        
        // Calculate slice label
        valueVar.sliceLabel = this.sliceLabel();
    }
})
.add({
    layoutLinkLabels: function(layoutInfo){
        var startAngle = -Math.PI / 2;
        
        var leftScenes  = [];
        var rightScenes = [];
        
        this.childNodes.forEach(function(categScene){
            startAngle = categScene.layoutI(layoutInfo, startAngle);
            
            (categScene.vars.link.dir > 0 ? rightScenes : leftScenes)
            .push(categScene);
        });
        
        // Distribute left and right labels and finish their layout
        this._distributeLabels(-1, leftScenes,  layoutInfo);
        this._distributeLabels(+1, rightScenes, layoutInfo);
    },
    
    _distributeLabels: function(dir, scenes, layoutInfo){
        // Initially, for each category scene, 
        //   targetY = elbowY
        // Taking additionally labelHeight into account,
        //  if this position causes overlapping, find a != targetY
        //  that does not cause overlap.
        
        // Sort scenes by Y position
        scenes.sort(function(sceneA, sceneB){
            return def.compare(sceneA.vars.link.targetY, sceneB.vars.link.targetY);
        });
        
        /*jshint expr:true */
        this._distributeLabelsDownwards(scenes, layoutInfo) &&
        this._distributeLabelsUpwards  (scenes, layoutInfo) &&
        this._distributeLabelsEvenly   (scenes, layoutInfo);
        
        scenes.forEach(function(categScene){
            categScene.layoutII(layoutInfo);
        });
    },
    
    _distributeLabelsDownwards: function(scenes, layoutInfo){
        var linkLayout = layoutInfo.link;
        var labelSpacingMin = linkLayout.labelSpacingMin;
        var yMax = layoutInfo.clientSize.height;
        var overlapping = false;
        for(var i = 0, J = scenes.length - 1 ; i < J ; i++){
            var linkVar0 = scenes[i].vars.link;
            
            if(!i && linkVar0.labelTop() < 0){
                overlapping = true;
            }
            
            var linkVar1 = scenes[i + 1].vars.link;
            var labelTopMin1 = linkVar0.labelBottom() + labelSpacingMin;
            if (linkVar1.labelTop() < labelTopMin1) {
                
                var halfLabelHeight1 = linkVar1.labelHeight / 2;
                var targetY1 = labelTopMin1 + halfLabelHeight1;
                var targetYMax = yMax - halfLabelHeight1;
                if(targetY1 > targetYMax){
                    overlapping = true;
                    linkVar1.targetY = targetYMax;
                } else {
                    linkVar1.targetY = targetY1;
                }
            }
        }
        
        return overlapping;
    },
    
    _distributeLabelsUpwards: function(scenes, layoutInfo){
        var linkLayout = layoutInfo.link;
        var labelSpacingMin = linkLayout.labelSpacingMin;
        
        var overlapping = false;
        for(var i = scenes.length - 1 ; i > 0 ; i--){
            var linkVar1 = scenes[i - 1].vars.link;
            var linkVar0 = scenes[i].vars.link;
            if(i === 1 && linkVar1.labelTop() < 0){
                overlapping = true;
            }
            
            var labelBottomMax1 = linkVar0.labelTop() - labelSpacingMin;
            if (linkVar1.labelBottom() > labelBottomMax1) {
                var halfLabelHeight1 = linkVar1.labelHeight / 2;
                var targetY1   = labelBottomMax1 - halfLabelHeight1;
                var targetYMin = halfLabelHeight1;
                if(targetY1 < targetYMin){
                    overlapping = true;
                    linkVar1.targetY = targetYMin;
                } else {
                    linkVar1.targetY = targetY1;                    
                }
            }
        }
        
        return overlapping;
    },
    
    _distributeLabelsEvenly: function(scenes, layoutInfo){
        var linkLayout = layoutInfo.link;
        var labelSpacingMin = linkLayout.labelSpacingMin;
        
        var totalHeight = 0;
        scenes.forEach(function(categScene){
            totalHeight += categScene.vars.link.labelHeight;
        });
        
        var freeSpace = layoutInfo.clientSize.height - totalHeight; // may be < 0
        var labelSpacing = freeSpace;
        if(scenes.length > 1){
            labelSpacing /= (scenes.length - 1);
        }
        
        var y = 0;
        scenes.forEach(function(scene){
            var linkVar = scene.vars.link;
            var halfLabelHeight = linkVar.labelHeight / 2;
            y += halfLabelHeight;
            linkVar.targetY = y;
            y += halfLabelHeight + labelSpacing;
        });
        
        return true;
    }
});

def
.type('pvc.visual.PieLinkLabelVar') // TODO : Var base class
.add({
    labelTop: function(){
        return this.targetY - this.labelHeight / 2;
    },
    
    labelBottom: function(){
        return this.targetY + this.labelHeight / 2;
    }
});

def
.type('pvc.visual.PieCategoryScene', pvc.visual.Scene)
.add({
    // extendable
    sliceLabelMask: function(){
        return this.panel().valuesMask;
    },
    
    // extendable
    sliceLabel: function(){
        return this.format(this.sliceLabelMask());
    },
    
    layoutI: function(layoutInfo, startAngle){
        var valueVar = this.vars.value;
        var endAngle = startAngle + valueVar.angle;
        var midAngle = (startAngle + endAngle) / 2;
        
        // Overwrite existing link var, if any.
        var linkVar = (this.vars.link = new pvc.visual.PieLinkLabelVar());
        
        var linkLayout = layoutInfo.link;
        
        var labelLines = pvc.text.justify(valueVar.sliceLabel, linkLayout.maxTextWidth, layoutInfo.labelFont);
        var lineCount = labelLines.length;
        linkVar.labelLines  = labelLines;
        linkVar.labelHeight = lineCount * linkLayout.lineHeight;
        
        this.lineScenes = def.array.create(lineCount, this);
        
        var cosMid = Math.cos(midAngle);
        var sinMid = Math.sin(midAngle);
        
        var isAtRight = cosMid >= 0;
        var dir = isAtRight ? 1 : -1;
        
        // Label anchor is at the side with opposite name to the side of the pie where it is placed.
        linkVar.labelAnchor = isAtRight ?  'left' : 'right'; 
        
        var center = layoutInfo.center;
        var elbowRadius = linkLayout.elbowRadius;
        var elbowX = center.x + elbowRadius * cosMid;
        var elbowY = center.y + elbowRadius * sinMid; // baseY
        
        var anchorX = center.x + dir * elbowRadius;
        var targetX = anchorX + dir * linkLayout.linkMargin;
        
        new pvc.visual.PieLinkLineScene(this, elbowX,  elbowY);
        new pvc.visual.PieLinkLineScene(this, anchorX, elbowY);
        
        linkVar.elbowY  = elbowY;
        linkVar.targetY = elbowY + 0;
        linkVar.targetX = targetX;
        linkVar.dir = dir;
        
        return endAngle;
    },
    
    layoutII: function(layoutInfo){
        var linkVar = this.vars.link;
        
        var targetY = linkVar.targetY;
        var targetX = linkVar.targetX;
        
        var handleWidth = layoutInfo.link.handleWidth;
        if(handleWidth > 0){
            new pvc.visual.PieLinkLineScene(this, targetX - linkVar.dir * handleWidth, targetY);
        }
        
        new pvc.visual.PieLinkLineScene(this, targetX, targetY);
                
        linkVar.labelX = targetX;
        linkVar.labelY = targetY - linkVar.labelHeight/2;
    }
});

def
.type('pvc.visual.PieLinkLineScene', pvc.visual.Scene)
.init(function(catScene, x, y, index){
    this.base(catScene, { group: catScene.group, index: index });
    
    this.x = x;
    this.y = y;
})
.add(pv.Vector)
;
/**
 * PieChart is the main class for generating... pie charts (surprise!).
 */
def
.type('pvc.PieChart', pvc.BaseChart)
.add({

    pieChartPanel: null,

    _getColorRoleSpec: function(){
        return { isRequired: true, defaultSourceRole: 'category', defaultDimension: 'color*', requireIsDiscrete: true };
    },
    
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
        
        this._addVisualRole('category', { 
                isRequired: true, 
                defaultDimension: 'category*', 
                autoCreateDimension: true 
            });
            
        this._addVisualRole('value', { 
                isMeasure:  true,
                isRequired: true,
                isPercent:  true,
                requireSingleDimension: true, 
                requireIsDiscrete: false,
                valueType: Number, 
                defaultDimension: 'value' 
            });
    },
    
    _initPlotsCore: function(hasMultiRole){
        new pvc.visual.PiePlot(this);
    },
    
    _preRenderContent: function(contentOptions) {

        this.base();
        
        var isV1Compat = this.compatVersion() <= 1;
        if(isV1Compat){
            var innerGap = pvc.castNumber(this.options.innerGap) || 0.95;
            innerGap = def.between(innerGap, 0.1, 1);
            contentOptions.paddings = ((1 - innerGap) * 100 / 2).toFixed(2) + "%";
        } else if(contentOptions.paddings == null) {
            contentOptions.paddings = new pvc.PercentValue(0.025);
        }
        
        var piePlot = this.plots.pie;
        this.pieChartPanel = new pvc.PieChartPanel(this, this.basePanel, piePlot, def.create(contentOptions, {
            scenes: def.getPath(this.options, 'pie.scenes')
        }));
    }
});

/**
 * Bar Abstract Panel.
 * The base panel class for bar charts.
 * 
 * Specific options are:
 * <i>orientation</i> - horizontal or vertical. Default: vertical
 * <i>valuesVisible</i> - Show or hide bar value. Default: false
 * <i>barSizeRatio</i> - In multiple series, percentage of inner
 * band occupied by bars. Default: 0.9 (90%)
 * <i>barSizeMax</i> - Maximum size (width) of a bar in pixels. Default: 2000
 *
 * Has the following protovis extension points:
 * <i>chart_</i> - for the main chart Panel
 * <i>bar_</i> - for the actual bar
 * <i>barPanel_</i> - for the panel where the bars sit
 * <i>barLabel_</i> - for the main bar label
 */
def
.type('pvc.BarAbstractPanel', pvc.CategoricalAbstractPanel)
.add({
    
    pvBar: null,
    pvBarLabel: null,
    pvCategoryPanel: null,
    pvSecondLine: null,
    pvSecondDot: null,
    
    _linePanel: null,
    
    barWidth:     null,
    barStepWidth: null,
    
    _creating: function(){
        // Register BULLET legend prototype marks
        var groupScene = this.defaultVisibleBulletGroupScene();
        if(groupScene && !groupScene.hasRenderer()){
            var colorAxis  = groupScene.colorAxis;
            var drawLine   = colorAxis.option('LegendDrawLine');
            var drawMarker = !drawLine || colorAxis.option('LegendDrawMarker');
            if(drawMarker){
                var keyArgs = {
                    drawMarker:    true,
                    markerShape:   colorAxis.option('LegendShape'),
                    drawRule:      drawLine,
                    markerPvProto: new pv.Mark()
                };
                
                this.extend(keyArgs.markerPvProto, '', {constOnly: true}); // '' => bar itself
                
                groupScene.renderer(
                    new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
            }
        }
    },
    
    /**
     * @override
     */
    _createCore: function(){
        this.base();
         
        var chart = this.chart,
            options = chart.options,
            isStacked = !!this.stacked,
            isVertical = this.isOrientationVertical();
        
        var data = this._getVisibleData(), // shared "categ then series" grouped data
            seriesData = chart._serRole.flatten(data),
            rootScene = this._buildScene(data, seriesData)
            ;

        var orthoScale = this.axes.ortho.scale,
            orthoZero  = orthoScale(0),
            sceneOrthoScale = this.axes.ortho.sceneScale({sceneVarName: 'value', nullToZero: false}),
            barSizeRatio = this.plot.option('BarSizeRatio'),
            barSizeMax   = this.plot.option('BarSizeMax'),
            baseRange = this.axes.base.scale.range(),
            bandWidth = baseRange.band,
            barStepWidth = baseRange.step,
            barWidth,
            reverseSeries = isVertical === isStacked // (V && S) || (!V && !S)
            ;

        if(isStacked){
            barWidth = bandWidth;
        } else {
            var S = seriesData.childCount();
            barWidth = S > 0 ? (bandWidth * barSizeRatio / S) : 0;
        }
        
        if (barWidth > barSizeMax) {
            barWidth = barSizeMax;
        }

        this.barWidth     = barWidth;
        this.barStepWidth = barStepWidth;
        
        var wrapper; // bar and label wrapper
        if(this.compatVersion() <= 1){
            /*
             * V1 Data
             * ----------
             * Stacked:   dataSet = Series x Categ values [[]...]    (type == undef -> 0)
             * 
             * !Stacked:  Categ -> Series
             *            Panel dataSet = VisibleCategoriesIndexes array
             *            Bar, Label -->  padZeros( getVisibleValuesForCategIndex( . ) )
             * 
             * var visibleSerIndex = this.stacked ? mark.parent.index : index,
             *     visibleCatIndex = this.stacked ? index : mark.parent.index;
             */
            wrapper = function(v1f){
                return function(scene){
                    var markParent = Object.create(this.parent);
                    var mark = Object.create(this);
                    mark.parent = markParent;
                    
                    var serIndex = scene.parent.childIndex();
                    var catIndex = scene.childIndex();
                    
                    if(isStacked){
                        markParent.index = serIndex;
                        mark.index = catIndex;
                    } else {
                        markParent.index = catIndex;
                        mark.index = serIndex;
                    }
                    
                    return v1f.call(mark, scene.vars.value.rawValue);
                };
            };
        }
        
        this.pvBarPanel = new pvc.visual.Panel(this, this.pvPanel, {
                panelType:   pv.Layout.Band,
                extensionId: 'panel'
            })
            .lock('layers', rootScene.childNodes) // series -> categories
            .lockMark('values', function(seriesScene){ return seriesScene.childNodes; })
            .lockMark('orient', isVertical ? 'bottom-left' : 'left-bottom')
            .lockMark('layout', isStacked  ? 'stacked' : 'grouped')
            .lockMark('verticalMode', this._barVerticalMode())
            .lockMark('yZero',  orthoZero)
            .pvMark
            .band // categories
                .x(this.axes.base.sceneScale({sceneVarName: 'category'}))
                .w(bandWidth)
                .differentialControl(this._barDifferentialControl())
            .item
                // Stacked Vertical bar charts show series from
                // top to bottom (according to the legend)
                .order(reverseSeries ? "reverse" : null)
                .h(function(scene){
                    /* May be negative */
                    var h = sceneOrthoScale(scene);
                    return h != null ? chart.animate(0, h - orthoZero) : null;
                })
                .w(barWidth)
                .horizontalRatio(barSizeRatio)
                .verticalMargin(options.barStackedMargin || 0)
            .end
            ;
        
        this.pvBar = new pvc.visual.Bar(this, this.pvBarPanel.item, {
                extensionId: '', // with the prefix, it gets 'bar_'
                freePosition: true,
                wrapper:      wrapper
            })
            .lockDimensions()
            .pvMark
            .antialias(false)
            ;

        if(this.plot.option('OverflowMarkersVisible')){
            this._addOverflowMarkers(wrapper);
        }
        
        if(this.valuesVisible){
            this.pvBarLabel = new pvc.visual.Label(
                this, 
                this.pvBar.anchor(this.valuesAnchor || 'center'), 
                {
                    extensionId: 'label',
                    wrapper:     wrapper
                })
                .pvMark
                .visible(function() { //no space for text otherwise
                    // this === pvMark
                    var length = this.scene.target[this.index][isVertical ? 'height' : 'width'];
                    
                    // Too small a bar to show any value?
                    return length >= 4;
                })
                .font(this.valuesFont) // default
                .text(function(scene){
                    var valueVar = options.showValuePercentage ?
                                   scene.vars.value.percent :
                                   scene.vars.value;
                    
                    return valueVar.label;
                })
                ;
        }
    },
    
    /**
     * Called to obtain the bar verticalMode property value.
     * If it returns a function,
     * 
     * that function will be called once.
     * @virtual
     */
    _barVerticalMode: function(){
        return null;
    },
    
    /**
     * Called to obtain the bar differentialControl property value.
     * If it returns a function,
     * that function will be called once per category,
     * on the first series.
     * @virtual
     */
    _barDifferentialControl: function(){
        return null;
    },
    
    _getV1Datum: function(scene){
        // Ensure V1 tooltip function compatibility 
        var datum = scene.datum;
        if(datum){
            var datumEx = Object.create(datum);
            datumEx.percent = scene.vars.value.percent;
            datum = datumEx;
        }
        
        return datum;
    },
    
    _addOverflowMarkers: function(wrapper){
        var orthoAxis = this.axes.ortho;
        if(orthoAxis.option('FixedMax') != null){
            this.pvOverflowMarker = this._addOverflowMarker(false, orthoAxis.scale, wrapper);
        }

        if(orthoAxis.option('FixedMin') != null){
            this.pvUnderflowMarker = this._addOverflowMarker(true, orthoAxis.scale, wrapper);
        }
    },

    _addOverflowMarker: function(isMin, orthoScale, wrapper){
        /* NOTE: pv.Bar is not a panel,
         * and as such markers will be children of bar's parent,
         * yet have bar's anchor as a prototype.
         */
        
        var myself = this,
            isVertical = this.isOrientationVertical(),
            a_bottom = isVertical ? "bottom" : "left",
            a_top    = this.anchorOpposite(a_bottom),
            a_height = this.anchorOrthoLength(a_bottom),
            a_width  = this.anchorLength(a_bottom),
            paddings = this._layoutInfo.paddings,
            rOrthoBound = isMin ? 
                          (orthoScale.min - paddings[a_bottom]) : 
                          (orthoScale.max + paddings[a_top]),
            angle;

        if(!isMin){
            angle = isVertical ? Math.PI: -Math.PI/2;
        } else {
            angle = isVertical ? 0: Math.PI/2;
        }
        
        return new pvc.visual.Dot(
            this,
            this.pvBar.anchor('center'), 
            {
                noSelect:      true,
                noHover:       true,
                noClick:       true,
                noDoubleClick: true,
                noTooltip:    true,
                freePosition:  true,
                extensionId:   isMin ? 'underflowMarker' : 'overflowMarker',
                wrapper:       wrapper
            })
            .intercept('visible', function(scene){
                var visible = this.delegateExtension();
                if(visible !== undefined && !visible){
                    return false;
                }
                
                var value = scene.vars.value.value;
                if(value == null){
                    return false;
                }

                var targetInstance = this.pvMark.scene.target[this.index];
                
                // Where is the position of the max of the bar?
                var orthoMaxPos = targetInstance[a_bottom] +
                                  (value > 0 ? targetInstance[a_height] : 0);
                return isMin ?
                        (orthoMaxPos < rOrthoBound) :
                        (orthoMaxPos > rOrthoBound);
            })
            .lock(a_top, null)
            .lock('shapeSize')
            .pvMark
            .shape("triangle")
            .shapeRadius(function(){
                return Math.min(
                        Math.sqrt(10),
                        this.scene.target[this.index][a_width] / 2);
            })
            .shapeAngle(angle)
            .lineWidth(1.5)
            .strokeStyle("red")
            .fillStyle("white")
            [a_bottom](function(){
                return rOrthoBound + (isMin ? 1 : -1) * (this.shapeRadius() + 2);
            })
            ;
    },

    /**
     * Renders this.pvPanel - the parent of the marks that are affected by selection changes.
     * @override
     */
    renderInteractive: function(){
        this.pvPanel.render();
    },

    /**
     * Returns an array of marks whose instances are associated to a datum, or null.
     * @override
     */
    _getSelectableMarks: function(){
        return [this.pvBar];
    },

    _buildScene: function(data, seriesData){
        var rootScene  = new pvc.visual.Scene(null, {panel: this, group: data});
        var categDatas = data._children;
        var colorVarHelper = new pvc.visual.ColorVarHelper(this.chart, this.chart._colorRole);
        
        /**
         * Create starting scene tree
         */
        seriesData
            .children()
            .each(createSeriesScene, this);

        return rootScene;

        function createSeriesScene(seriesData1){
            /* Create series scene */
            var seriesScene = new pvc.visual.Scene(rootScene, {group: seriesData1}),
                seriesKey   = seriesData1.key;

            this._onNewSeriesScene(seriesScene, seriesData1);
            
            colorVarHelper.onNewScene(seriesScene, /* isLeaf */ false);
            
            categDatas.forEach(function(categData1){
                /* Create leaf scene */
                var categKey = categData1.key,
                    group = data._childrenByKey[categKey]._childrenByKey[seriesKey],

                    /* If there's no group, provide, at least, a null datum */
                    datum = group ? null : createNullDatum(seriesData1, categData1),
                    scene = new pvc.visual.Scene(seriesScene, {group: group, datum: datum});

                this._onNewSeriesCategoryScene(scene, categData1, seriesData1);
                
                colorVarHelper.onNewScene(scene, /* isLeaf */ true);
            }, this);
        }

        function createNullDatum(serData1, catData1) {
            // Create a null datum with col and row coordinate atoms
            var atoms = def.copy(def.copy({}, serData1.atoms), catData1.atoms);

            return new pvc.data.Datum(data, atoms, true);
        }
    },

    _onNewSeriesScene: function(seriesScene, seriesData1){
        seriesScene.vars.series = new pvc.visual.ValueLabelVar(
            seriesData1.value,
            seriesData1.label,
            seriesData1.rawValue);
    },

    _onNewSeriesCategoryScene: function(categScene, categData1, seriesData1){
        var categVar = categScene.vars.category = new pvc.visual.ValueLabelVar(
            categData1.value, categData1.label, categData1.rawValue);
        
        categVar.group = categData1;
        
        var chart = this.chart,
            valueDim = categScene.group ?
                            categScene
                                .group
                                .dimensions(chart._valueDim.name) :
                            null;

        var value = valueDim ? valueDim.sum({visible: true, zeroIfNone: false}) : null;

        var valueVar = 
            categScene.vars.value = new pvc.visual.ValueLabelVar(
                                    value, 
                                    chart._valueDim.format(value),
                                    value);
        
        // TODO: Percent formatting?
        if(chart.options.showValuePercentage) {
            if(value == null){
                valueVar.percent = new pvc.visual.ValueLabelVar(null, valueVar.label);
            } else {
                var valuePct = valueDim.percentOverParent({visible: true});
                
                valueVar.percent = new pvc.visual.ValueLabelVar(
                                        valuePct,
                                        chart.options.percentValueFormat.call(null, valuePct));
            }
        }

        categScene.isNull = !categScene.group; // A virtual scene?
    }
});
/**
 * BarAbstract is the base class for generating charts of the bar family.
 */
def
.type('pvc.BarAbstract', pvc.CategoricalAbstract)
.init(function(options){

    this.base(options);

    var parent = this.parent;
    if(parent) {
        this._valueRole = parent._valueRole;
    }
})
.add({
    // NOTE
    // Timeseries category with bar charts are supported differently in V2 than in V1
    // They worked in v1 if the data set brought all
    // categories, according to chosen timeseries scale date unit
    // Then, bars were drawn with a category scale, 
    // whose positions ended up coinciding with the ticks in a linear axis...
    // To mimic v1 behavior the category dimensions are "coerced" to isDiscrete
    // The axis will be categoric, the parsing will work, 
    // and the formatting will be the desired one

    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
        
        this._addVisualRole('value', {
            isMeasure: true,
            isRequired: true,
            isPercent: this.options.stacked,
            requireSingleDimension: true,
            requireIsDiscrete: false,
            valueType: Number,
            defaultDimension: 'value'
        });

        this._valueRole = this.visualRoles('value');
    },
    
    _getCategoryRoleSpec: function(){
        var catRoleSpec = this.base();
        
        // Force dimension to be discrete!
        catRoleSpec.requireIsDiscrete = true;
        
        return catRoleSpec;
    },
    
    _initData: function(){
        this.base.apply(this, arguments);

        var data = this.data;

        // Cached
        this._valueDim = data.dimensions(this._valueRole.firstDimensionName());
    }
});/**
 * Bar Panel.
 */
def
.type('pvc.BarPanel', pvc.BarAbstractPanel)
.add({
});
/**
 * BarChart is the main class for generating... bar charts (another surprise!).
 */
def
.type('pvc.BarChart', pvc.BarAbstract)
.add({

    _allowV1SecondAxis: true, 
    
    _initPlotsCore: function(hasMultiRole){
        var options = this.options;
        
        var barPlot = new pvc.visual.BarPlot(this);
        var trend   = barPlot.option('Trend');
        
        if(options.plot2){
            // Line Plot
            var plot2Plot = new pvc.visual.PointPlot(this, {
                name: 'plot2',
                fixed: {
                    DataPart: '1'
                },
                defaults: {
                    ColorAxis:    2,
                    LinesVisible: true,
                    DotsVisible:  true
                }});
            
            if(!trend){
                trend = plot2Plot.option('Trend');
            }
        }
        
        if(trend){
            // Trend Plot
            new pvc.visual.PointPlot(this, {
                name: 'trend',
                fixed: {
                    DataPart: 'trend',
                    TrendType: 'none',
                    ColorRole: 'series', // one trend per series
                    NullInterpolatioMode: 'none'
                },
                defaults: {
                    ColorAxis:    2,
                    LinesVisible: true,
                    DotsVisible:  false
                }
            });
        }
    },
    
    _hasDataPartRole: function(){
        return true;
    },
    
    /**
     * @override 
     */
    _createPlotPanels: function(parentPanel, baseOptions){
        var options = this.options;
        var plots = this.plots;
        
        var barPlot = plots.bar;
        var barPanel = new pvc.BarPanel(
                this, 
                parentPanel, 
                barPlot, 
                Object.create(baseOptions));

        // legacy field
        this.barChartPanel = barPanel;
        
        var plot2Plot = plots.plot2;
        if(plot2Plot){
            if(pvc.debug >= 3){
                this._log("Creating Point panel.");
            }
            
            var pointPanel = new pvc.PointPanel(
                    this, 
                    parentPanel, 
                    plot2Plot,
                    Object.create(baseOptions));
            
            // Legacy fields
            barPanel.pvSecondLine = pointPanel.pvLine;
            barPanel.pvSecondDot  = pointPanel.pvDot;
            
            pointPanel._applyV1BarSecondExtensions = true;
        }
        
        var trendPlot = plots.trend;
        if(trendPlot){
            if(pvc.debug >= 3){
                this._log("Creating Trends Point panel.");
            }
            
            new pvc.PointPanel(
                    this, 
                    parentPanel, 
                    trendPlot,
                    Object.create(baseOptions));
        }
    }
});

/**
 * Normalized Bar Panel.
 */
def
.type('pvc.NormalizedBarPanel', pvc.BarAbstractPanel)
.add({
    _barVerticalMode: function(){
        return 'expand';
    }
});
/**
 * A NormalizedBarChart is a 100% stacked bar chart.
 */
def
.type('pvc.NormalizedBarChart', pvc.BarAbstract)
.add({
    
    /**
     * Processes options after user options and default options have been merged.
     * @override
     */
    _processOptionsCore: function(options){
        // Still affects default data cell settings
        options.stacked = true;

        this.base(options);
    },

    /**
     * @override
     */
    _getContinuousVisibleExtentConstrained: function(axis, min, max){
        if(axis.type === 'ortho') {
            /* 
             * Forces showing 0-100 in the axis.
             * Note that the bars are stretched automatically by the band layout,
             * so this scale ends up being ignored by the bars.
             * Note also that each category would have a different scale,
             * so it isn't possible to provide a single correct scale,
             * that would satisfy all the bars...
             */
            return {min: 0, max: 100, minLocked: true, maxLocked: true};
        }

        return this.base(axis, min, max);
    },
    
    _initPlotsCore: function(hasMultiRole){
        
        new pvc.visual.NormalizedBarPlot(this);
    },
    
    /* @override */
    _createPlotPanels: function(parentPanel, baseOptions){
        var barPlot = this.plots.bar;
        
        this.barChartPanel = 
            new pvc.NormalizedBarPanel(
                this, 
                parentPanel, 
                barPlot, 
                Object.create(baseOptions));
    }
});
/**
 * Initializes a waterfall legend bullet group scene.
 * 
 * @name pvc.visual.legend.WaterfallBulletGroupScene

 * @extends pvc.visual.Scene
 * 
 * @constructor
 * @param {pvc.visual.legend.BulletRootScene} parent The parent bullet root scene.
 * @param {object} [keyArgs] Keyword arguments.
 * See {@link pvc.visual.Scene} for additional keyword arguments.
 * @param {pv.visual.legend.renderer} [keyArgs.renderer] Keyword arguments.
 */
def
.type('pvc.visual.legend.WaterfallBulletGroupScene', pvc.visual.Scene)
.init(function(rootScene, keyArgs){
    
    this.base(rootScene, keyArgs);
    
    this.extensionPrefix =  def.get(keyArgs, 'extensionPrefix') || 'legend';
    
    var item = this.createItem({
        value:    null,
        rawValue: null,
        label:    def.get(keyArgs, 'label')
    });
    
    item.color = def.get(keyArgs, 'color');
})
.add(/** @lends pvc.visual.legend.WaterfallBulletGroupScene# */{
    hasRenderer: function(){
        return this._renderer;
    },
    
    renderer: function(renderer){
        if(renderer != null){
            this._renderer = renderer;
        }
        
        return this._renderer;
    },
    
    itemSceneType: function(){
        var ItemType = this._itemSceneType;
        if(!ItemType){
            ItemType = def.type(pvc.visual.legend.BulletItemScene);
            
            // Apply legend item scene extensions
            this.panel()._extendSceneType('item', ItemType, ['isOn', 'isClickable', 'click']);
            
            this._itemSceneType = ItemType;
        }
        
        return ItemType;
    },
    
    createItem: function(keyArgs){
        var ItemType = this.itemSceneType();
        return new ItemType(this, keyArgs);
    }
});
/**
 * Waterfall chart panel.
 * Specific options are:
 * <i>orientation</i> - horizontal or vertical. Default: vertical
 * <i>valuesVisible</i> - Show or hide bar value. Default: false
 * <i>barSizeRatio</i> - In multiple series, percentage of inner
 * band occupied by bars. Default: 0.9 (90%)
 * <i>barSizeMax</i> - Maximum size (width) of a bar in pixels. Default: 2000
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>bar_</i> - for the actual bar
 * <i>barPanel_</i> - for the panel where the bars sit
 * <i>barLabel_</i> - for the main bar label
 */
def
.type('pvc.WaterfallPanel', pvc.BarAbstractPanel)
.add({
    pvWaterfallLine: null,
    ruleData: null,

    /**
     * Called to obtain the bar differentialControl property value.
     * If it returns a function,
     * that function will be called once per category,
     * on the first series.
     * @virtual
     */
    _barDifferentialControl: function(){
        var isFalling = this.chart._isFalling;

        /*
         * From protovis help:
         *
         * Band differential control pseudo-property.
         *  2 - Drawn starting at previous band offset. Multiply values by  1. Don't update offset.
         *  1 - Drawn starting at previous band offset. Multiply values by  1. Update offset.
         *  0 - Reset offset to 0. Drawn starting at 0. Default. Leave offset at 0.
         * -1 - Drawn starting at previous band offset. Multiply values by -1. Update offset.
         * -2 - Drawn starting at previous band offset. Multiply values by -1. Don't update offset.
         */
        return function(scene){
            if(isFalling && !this.index){
                // First falling bar is the main total
                // Must be accounted up and update the total
                return 1;
            }

            var group = scene.vars.category.group;
            if(group._isFlattenGroup && !group._isDegenerateFlattenGroup){
                // Groups don't update the total
                // Groups, always go down, except the first falling...
                return -2;
            }
            
            return isFalling ? -1 : 1;
        };
    },
    
    _creating: function(){
        // Register BULLET legend prototype marks
        var rootScene = this._getLegendBulletRootScene();
        if(rootScene){
            var waterfallGroupScene = rootScene.firstChild;
            
            if(waterfallGroupScene && !waterfallGroupScene.hasRenderer()){
                var keyArgs = {
                        drawRule:      true,
                        drawMarker:    false,
                        noSelect:      true,
                        noHover:       true,
                        rulePvProto:   new pv.Mark()
                    };
                
                this.extend(keyArgs.rulePvProto, 'line', {constOnly: true});
                
                waterfallGroupScene.renderer(
                        new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
            }
        }
    },
    
    _createCore: function(){

        this.base();

        var chart = this.chart,
            options = chart.options,
            isVertical = this.isOrientationVertical(),
            anchor = isVertical ? "bottom" : "left",
            ao = this.anchorOrtho(anchor),
            ruleRootScene = this._buildRuleScene(),
            orthoScale = chart.axes.ortho.scale,
            orthoPanelMargin = 0.04 * (orthoScale.range()[1] - orthoScale.range()[0]),
            orthoZero = orthoScale(0),
            sceneOrthoScale = chart.axes.ortho.sceneScale({sceneVarName: 'value'}),
            sceneBaseScale  = chart.axes.base.sceneScale({sceneVarName: 'category'}),
            baseScale = chart.axes.base.scale,
            barWidth2 = this.barWidth/2,
            barWidth = this.barWidth,
            barStepWidth = this.barStepWidth,
            isFalling = chart._isFalling,
            waterColor = chart._waterColor
            ;

        if(this.plot.option('AreasVisible')){
            var panelColors = pv.Colors.category10();
            var waterGroupRootScene = this._buildWaterGroupScene();
            
            this.pvWaterfallGroupPanel = new pvc.visual.Panel(this, this.pvPanel, {
                    extensionId: 'group'
                })
                .lock('data', waterGroupRootScene.childNodes)
                .pvMark
                .zOrder(-1)
                .fillStyle(function(scene){
                    return panelColors(0)/* panelColors(scene.vars.category.level - 1)*/.alpha(0.15);
                })
                [ao](function(scene){
                    var categVar = scene.vars.category;
                    return baseScale(categVar.leftValue) - barStepWidth / 2;
                })
                [this.anchorLength(anchor)](function(scene){
                    var categVar = scene.vars.category,
                        length = Math.abs(baseScale(categVar.rightValue) -
                                baseScale(categVar.leftValue))
                        ;

                    return length + barStepWidth;
                })
                [anchor](function(scene){
                    return orthoScale(scene.vars.value.bottomValue) - orthoPanelMargin/2;
                })
                [this.anchorOrthoLength(anchor)](function(scene){
                    return orthoScale(scene.vars.value.heightValue) + orthoPanelMargin;
                    //return chart.animate(orthoZero, orthoScale(scene.categ) - orthoZero);
                })
                ;
        }
        
        this.pvBar
            .sign
            .override('baseColor', function(type){
                var color = this.base(type);
                if(type === 'fill'){
                    if(!this.scene.vars.category.group._isFlattenGroup){
                        return pv.color(color).alpha(0.5);
                    } 
//                    else {
//                        return pv.color(color).darker();
//                    }
                }
                
                return color;
            })
            ;
        
        this.pvWaterfallLine = new pvc.visual.Rule(this, this.pvPanel, {
                extensionId:  'line',
                noTooltip:    false,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            })
            .lock('data', ruleRootScene.childNodes)
            .optional('visible', function(){
                return ( isFalling && !!this.scene.previousSibling) ||
                       (!isFalling && !!this.scene.nextSibling);
            })
            .optional(anchor, function(){ 
                return orthoZero + chart.animate(0, sceneOrthoScale(this.scene) - orthoZero);
            })
            .optional(this.anchorLength(anchor), barStepWidth + barWidth)
            .optional(ao,
                isFalling ?
                    function(){ return sceneBaseScale(this.scene) - barStepWidth - barWidth2; } :
                    function(){ return sceneBaseScale(this.scene) - barWidth2; })
            .override('defaultColor', function(){ return waterColor; })
            .pvMark
            .antialias(true)
            .lineCap('butt')
            ;

        if(this.plot.option('TotalValuesVisible')){
            this.pvWaterfallLabel = new pvc.visual.Label(
                this, 
                this.pvWaterfallLine, 
                {
                    extensionId: 'lineLabel'
                })
                .intercept('visible', function(scene){
                    if(scene.vars.category.group._isFlattenGroup){
                        return false;
                    }
    
                    return isFalling || !!scene.nextSibling;
                })
                .pvMark
                [anchor](function(scene){
                    return orthoZero + chart.animate(0, sceneOrthoScale(scene) - orthoZero);
                })
                [this.anchorOrtho(anchor)](sceneBaseScale)
                .textAlign(isVertical ? 'center' : 'left')
                .textBaseline(function(categScene){
                    if(!isVertical){
                        return 'middle';
                    }
                    
                    var direction = categScene.vars.direction;
                    if(direction == null){
                        return 'bottom';
                    }
                    
                    var isRising = !isFalling;
                    return  (isRising === (direction === 'up') ? 'bottom' : 'top');
                })
                .textStyle(pv.Color.names.darkgray.darker(2))
                .textMargin(5)
                .text(function(scene){ return scene.vars.value.label; });
        }
    },

    _buildRuleScene: function(){
        var rootScene  = new pvc.visual.Scene(null, {panel: this, group: this._getVisibleData()});
        var prevValue;
        
        /**
         * Create starting scene tree
         */
        if(this.chart._ruleInfos){
            this.chart._ruleInfos
                .forEach(createCategScene, this);
        }
        
        return rootScene;

        function createCategScene(ruleInfo){
            var categData1 = ruleInfo.group;
            
            var categScene = new pvc.visual.Scene(rootScene, {group: categData1});
            
            var categVar = 
                categScene.vars.category = 
                    new pvc.visual.ValueLabelVar(
                                categData1.value,
                                categData1.label);
            
            categVar.group = categData1;
            
            var value = ruleInfo.offset;
            
            categScene.vars.value = new pvc.visual.ValueLabelVar(
                                value,
                                this.chart._valueDim.format(value));
            
            categScene.vars.direction = 
                (prevValue == null || prevValue === value) ? null : (prevValue < value ? 'up' : 'down');
            
            prevValue = value;
        }
    },

    _buildWaterGroupScene: function(){
        var chart = this.chart,
            ruleInfos = this.chart._ruleInfos,
            ruleInfoByCategKey = ruleInfos && def.query(ruleInfos)
                                  .object({
                                      name:  function(ruleInfo){ return ruleInfo.group.absKey; },
                                      value: function(ruleInfo){ return ruleInfo; }
                                  }),
            isFalling = chart._isFalling,
            rootCatData = chart._catRole.select(
                            chart.partData(this.dataPartValue),
                            {visible: true}),
            rootScene  = new pvc.visual.Scene(null, {panel: this, group: rootCatData});

        if(ruleInfoByCategKey){
            createCategSceneRecursive(rootCatData, 0);
        }
        
        return rootScene;

        function createCategSceneRecursive(catData, level){
            var children = catData.children()
                                  .where(function(child){ return child.key !== ""; })
                                  .array();
            if(children.length){
                // Group node
                if(level){
                    var categScene = new pvc.visual.Scene(rootScene, {group: catData});

                    var categVar = 
                        categScene.vars.category = 
                            new pvc.visual.ValueLabelVar(
                                    catData.value,
                                    catData.label);
                    
                    categVar.group = catData;
                    categVar.level = level;

                    var valueVar = categScene.vars.value = {}; // TODO: Not A Var
                    var ruleInfo = ruleInfoByCategKey[catData.absKey];
                    var offset = ruleInfo.offset,
                        range = ruleInfo.range,
                        height = -range.min + range.max
                        ;

                    if(isFalling){
                        var lastChild = lastLeaf(catData);
                        var lastRuleInfo = ruleInfoByCategKey[lastChild.absKey];
                        categVar.leftValue  = ruleInfo.group.value;
                        categVar.rightValue = lastRuleInfo.group.value;
                        valueVar.bottomValue = offset - range.max;

                    } else {
                        var firstChild = firstLeaf(catData);
                        var firstRuleInfo = ruleInfoByCategKey[firstChild.absKey];
                        categVar.leftValue = firstRuleInfo.group.value;
                        categVar.rightValue = ruleInfo.group.value;
                        valueVar.bottomValue = offset - range.max;
                    }

                    valueVar.heightValue = height;
                }

                children.forEach(function(child){
                    createCategSceneRecursive(child, level + 1);
                });
            }
        }

        function firstLeaf(data){
            var firstChild = data._children && data._children[0];
            return firstChild ? firstLeaf(firstChild) : data;
        }

        function lastLeaf(data){
            var lastChild = data._children && data._children[data._children.length - 1];
            return lastChild ? lastLeaf(lastChild) : data;
        }
    }
});
/**
 * WaterfallChart is the class that generates waterfall charts.
 *
 * The waterfall chart is an alternative to the pie chart for
 * showing distributions. The advantage of the waterfall chart is that
 * it possibilities to visualize sub-totals and offers more convenient
 * possibilities to compare the size of categories (in a pie-chart you
 * have to compare wedges that are at a different angle, which
 * requires some additional processing/brainpower of the end-user).
 *
 * Waterfall charts are basically Bar-charts with some added
 * functionality. Given the complexity of the added features this
 * class has it's own code-base. However, it would be easy to
 * derive a BarChart class from this class by switching off a few
 * features.
 *
 * If you have an issue or suggestions regarding the Waterfall-charts
 * please contact CvK at cde@vinzi.nl
 */
def
.type('pvc.WaterfallChart', pvc.BarAbstract)
.init(function(options){

    this.base(options);
    
    var parent = this.parent;
    if(parent) {
        this._isFalling = parent._isFalling;
    }
})
.add({

    _isFalling: true,
    _ruleInfos: null,
    _waterColor: pv.color("#1f77b4").darker(),// pv.Color.names.darkslateblue,//royalblue,seagreen, //pv.color("#808285").darker(),

    /**
     * Processes options after user options and default options have been merged.
     * @override
     */
    _processOptionsCore: function(options){

        // Might still affect scale calculation
        options.stacked = true;
        
        // Doesn't work (yet?);
        options.baseAxisComposite = false;
        
        this.base(options);
        
        // Not supported
        options.plot2 = false;
    },
  
    _initPlotsCore: function(){
        var options = this.options;
        
        var waterPlot = new pvc.visual.WaterfallPlot(this);
        
        this._isFalling = waterPlot.option('Direction') === 'down';
        
        this._catRole.setFlatteningMode(this._isFalling ? 'tree-pre' : 'tree-post');
        this._catRole.setFlattenRootLabel(this.plots.water.option('AllCategoryLabel'));
    },
    
    _initLegendScenes: function(legendPanel){
        
        var waterPlot = this.plots.water;
        
        var extAbsId = pvc.makeExtensionAbsId('line', waterPlot.extensionPrefixes);
        var strokeStyle = this._getConstantExtension(extAbsId, "strokeStyle");
        if(strokeStyle){
            this._waterColor = pv.color(strokeStyle);
        }
        
        var rootScene = legendPanel._getBulletRootScene();
        
        new pvc.visual.legend.WaterfallBulletGroupScene(rootScene, {
            extensionPrefix: pvc.buildIndexedId('legend', 1), // legend2_ TODO
            label: waterPlot.option('TotalLineLabel'),
            color: this._waterColor
        });
        
        this.base(legendPanel);
    },
    
    /**
     * Reduce operation of category ranges, into a global range.
     *
     * Propagates the total value.
     *
     * Also creates the array of rule information {@link #_ruleInfos}
     * used by the waterfall panel to draw the rules.
     *
     * Supports {@link #_getContinuousVisibleExtent}.
     */
    _reduceStackedCategoryValueExtent: function(result, catRange, catGroup){
        /*
         * That min + max are the variation of this category
         * relies on the concrete base._getStackedCategoryValueExtent() implementation...
         * Max always contains the sum of positives, if any, or 0
         * Min always contains the sum of negatives, if any, or 0
         * max >= 0
         * min <= 0
         */
        /*
         * When falling, the first category is surely *the* global total.
         * When falling, the first category must set the initial offset
         * and, unlike every other category group such that _isFlattenGroup===true,
         * it does contribute to the offset, and positively.
         * The offset property accumulates the values.
         */
        var offset;
        if(!result){
            if(catRange){
                offset = catRange.min + catRange.max;
                
                this._ruleInfos = [{
                    offset: offset,
                    group:  catGroup,
                    range:  catRange
                }];

                // Copy the range object
                return {
                    min:    catRange.min,
                    max:    catRange.max,
                    offset: offset
                };
            }

            return null;
        }

        offset = result.offset;
        if(this._isFalling){
            this._ruleInfos.push({
                offset: offset,
                group:  catGroup,
                range:  catRange
            });
        }

        if(!catGroup._isFlattenGroup || catGroup._isDegenerateFlattenGroup){
            var dir = this._isFalling ? -1 : 1;

            offset = result.offset = offset + dir * (catRange.min + catRange.max);

            if(offset > result.max){
                result.max = offset;
            }
            
            if(offset < result.min){
                result.min = offset;
            }
        }

        if(!this._isFalling){
            this._ruleInfos.push({
                offset: offset,
                group:  catGroup,
                range:  catRange
            });
        }
        
        return result;
    },
    
    /* @override */
    _createPlotPanels: function(parentPanel, baseOptions){
        this.wfChartPanel = 
            new pvc.WaterfallPanel(
                    this, 
                    parentPanel, 
                    this.plots.water, 
                    def.create(baseOptions, {
                        waterfall:  this.options.waterfall
                    }));
    }
});
/*
 * Point panel.
 * Class that draws all line/dot/area combinations.
 * Specific options are:
 * <i>dotsVisible</i> - Show or hide dots. Default: true
 * <i>areasVisible</i> - Show or hide dots. Default: false
 * <i>linesVisible</i> - Show or hide dots. Default: true
 * <i>valuesVisible</i> - Show or hide line value. Default: false
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>line_</i> - for the actual line
 * <i>linePanel_</i> - for the panel where the lines sit
 * <i>lineDot_</i> - the dots on the line
 * <i>lineLabel_</i> - for the main line label
 */
def
.type('pvc.PointPanel', pvc.CategoricalAbstractPanel)
.init(function(chart, parent, plot, options) {
    
    this.base(chart, parent, plot, options);
    
    this.linesVisible  = plot.option('LinesVisible'); // TODO
    this.dotsVisible   = plot.option('DotsVisible' ); // TODO
    this.areasVisible  = plot.option('AreasVisible'); // TODO
    if(!this.linesVisible && !this.dotsVisible && !this.areasVisible){
        this.linesVisible = true;
        plot.option.specify({'LinesVisible': true});
    }
})
.add({
    pvLine: null,
    pvArea: null,
    pvDot: null,
    pvLabel: null,
    pvScatterPanel: null,
    
    _creating: function(){
        // Register BULLET legend prototype marks
        var groupScene = this.defaultVisibleBulletGroupScene();
        if(groupScene && !groupScene.hasRenderer()){
            var colorAxis = groupScene.colorAxis;
            var drawMarker = def.nullyTo(colorAxis.option('LegendDrawMarker', /*no default*/ true), this.dotsVisible || this.areasVisible);
            var drawRule   = !drawMarker || 
                             def.nullyTo(colorAxis.option('LegendDrawLine',   /*no default*/ true), this.linesVisible && !this.areasVisible);
            if(drawMarker || drawRule){
                var keyArgs = {};
                if((keyArgs.drawMarker = drawMarker)){
                    var markerShape = colorAxis.option('LegendShape', true);
                    
                    if(this.dotsVisible){
                        if(!markerShape){ 
                            markerShape = 'circle'; // Dot's default shape
                        }
                        
                        keyArgs.markerPvProto = new pv.Dot()
                                .lineWidth(1.5, pvc.extensionTag) // act as if it were a user extension
                                .shapeSize(12,  pvc.extensionTag); // idem
                    } else {
                        keyArgs.markerPvProto = new pv.Mark();
                    }
                    
                    keyArgs.markerShape = markerShape;
                    
                    if(this._applyV1BarSecondExtensions){
                        this.chart.extend(keyArgs.markerPvProto, 'barSecondDot', {constOnly: true});
                    }       
                    this.extend(keyArgs.markerPvProto, 'dot', {constOnly: true});
                }
                
                if((keyArgs.drawRule = drawRule)){
                    keyArgs.rulePvProto = new pv.Line()
                           .lineWidth(1.5, pvc.extensionTag);
                    
                    if(this._applyV1BarSecondExtensions){
                        this.chart.extend(keyArgs.rulePvProto, 'barSecondLine', {constOnly: true});
                    }
                    this.extend(keyArgs.rulePvProto, 'line', {constOnly: true});
                }
                
                groupScene.renderer(
                    new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
            }
        }
    },
    
    /**
     * @override
     */
    _createCore: function(){
        this.base();
        
        var myself = this;
        var chart = this.chart;
        var options   = chart.options;
        var isStacked = this.stacked;
        var dotsVisible  = this.dotsVisible;
        var areasVisible = this.areasVisible;
        var linesVisible = this.linesVisible;
        var anchor = this.isOrientationVertical() ? "bottom" : "left";

        this.valueRole     = chart.visualRoles(this.plot.option('OrthoRole'));
        this.valueRoleName = this.valueRole.name;
        this.valueDimName  = this.valueRole.firstDimensionName();
        
        // ------------------
        // DATA
        var isBaseDiscrete = this.axes.base.role.grouping.isDiscrete();
        var data = this._getVisibleData(); // shared "categ then series" grouped data
        var rootScene = this._buildScene(data, isBaseDiscrete);
       
        // ---------------
        // BUILD
        if(areasVisible){
            // Areas don't look good above the axes
            this.pvPanel.zOrder(-7);
        } else {
            // // Above axes
            this.pvPanel.zOrder(1);
        }
        
        this.pvScatterPanel = new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: 'panel'
            })
            .lock('data', rootScene.childNodes)
            .pvMark
            ;
        
        // -- AREA --
        var areaFillColorAlpha = areasVisible && linesVisible && !isStacked ? 0.5 : null;
        
        var wrapper;
        if(this.compatVersion() <= 1){
            if(isStacked){
                wrapper = function(v1f){
                    return function(dotScene){
                        return v1f.call(this, dotScene.vars.value.rawValue);
                    };
                };
            } else {
                wrapper = function(v1f){
                    return function(dotScene){
                        var d = {
                                category: dotScene.vars.category.rawValue,
                                value:    dotScene.vars.value.rawValue
                            };
                        
                        // Compensate for the effect of intermediate scenes on mark's index
                        var pseudo = Object.create(this);
                        pseudo.index = dotScene.dataIndex;
                        return v1f.call(pseudo, d);
                    };
                };
            }
        }
        
        var isLineAreaVisible = isBaseDiscrete && isStacked ? 
                function(){ return !this.scene.isNull || this.scene.isIntermediate; } :
                function(){ return !this.scene.isNull; };
                
        this.pvArea = new pvc.visual.Area(this, this.pvScatterPanel, {
                extensionId: 'area',
                noTooltip:   false,
                wrapper:     wrapper
            })
            
            .lock('visible', isLineAreaVisible)
            
            /* Data */
            .lock('data',   function(seriesScene){ return seriesScene.childNodes; }) // TODO
            
            /* Position & size */
            .override('x',  function(){ return this.scene.basePosition;  })
            .override('y',  function(){ return this.scene.orthoPosition; })
            .override('dy', function(){ return chart.animate(0, this.scene.orthoLength); })
            
            /* Color & Line */
            .override('color', function(type){
                return areasVisible ? this.base(type) : null;
            })
            .override('baseColor', function(type){
                var color = this.base(type);
                if(!this._finished && color && areaFillColorAlpha != null){
                    color = color.alpha(areaFillColorAlpha);
                }
                
                return color;
            })
            .override('dimColor', function(color, type){
                return isStacked ? 
                    pvc.toGrayScale(color, 1, null, null).brighter() :
                    this.base(color, type);
            })
            .lock('events', areasVisible ? 'painted' : 'none')
            .pvMark
            ;
        
        // -- LINE --
        var dotsVisibleOnly = dotsVisible && !linesVisible && !areasVisible,
            
            /* When not showing lines, but showing areas,
             * we copy the area fillStyle so that
             * the line can cover the area and not be noticed.
             * We need this to hide the ladder 
             * on the border of the area, 
             * due to not using antialias.
             * 
             * When the scene has the active series,
             * the line is shown "highlighted" anyway.
             */
            lineCopiesAreaColor = !linesVisible && areasVisible,
            
            /* When areas are shown with no alpha (stacked), 
             * make dots darker so they get 
             * distinguished from areas. 
             */
            darkerLineAndDotColor = isStacked && areasVisible;
         
        var extensionIds = ['line'];
        if(this._applyV1BarSecondExtensions){
            extensionIds.push({abs: 'barSecondLine'});
        }
        
        this.pvLine = new pvc.visual.Line(
            this, 
            this.pvArea.anchor(this.anchorOpposite(anchor)), 
            {
                extensionId:  extensionIds,
                freePosition: true,
                wrapper:      wrapper,
                noTooltip:    false
            })
            /* 
             * Line.visible =
             *  a) linesVisible
             *     or
             *  b) (!linesVisible and) areasVisible
             *      and
             *  b.1) discrete base and stacked
             *       and
             *       b.1.1) not null or is an intermediate null
             *  b.2) not null
             */
            .lock('visible', dotsVisibleOnly ? false : isLineAreaVisible)
            
            /* Color & Line */
            .override('defaultColor', function(type){
                var color = this.base(type);
                
                if(!this._finished && darkerLineAndDotColor && color){
                    color = color.darker(0.6);
                }
                return color;
            })
            .override('normalColor', function(color, type){
                return linesVisible ? color : null;
            })
            .override('baseStrokeWidth', function(){
                var strokeWidth;
                if(linesVisible){
                    strokeWidth = this.base();
                }
                
                return strokeWidth == null ? 1.5 : strokeWidth; 
            })
            .intercept('strokeDasharray', function(){
                var dashArray = this.delegateExtension();
                if(dashArray === undefined){
                    var scene = this.scene;
                    var useDash = scene.isInterpolated;
                    if(!useDash){
                        var next = scene.nextSibling;
                        useDash = next && next.isIntermediate && next.isInterpolated;
                        if(!useDash){
                            var previous = scene.previousSibling;
                            useDash = previous  && scene.isIntermediate && previous.isInterpolated;
                        }
                    }
                    
                    dashArray = useDash ? '. ' : null;
                }
                
                return dashArray;
            })
            .pvMark
            ;
        
           
        // -- DOT --
        var showAloneDots = !(areasVisible && isBaseDiscrete && isStacked);
        
        extensionIds = ['dot'];
        if(this._applyV1BarSecondExtensions){
            extensionIds.push({abs: 'barSecondDot'});
        }
        
        this.pvDot = new pvc.visual.Dot(this, this.pvLine, {
                extensionId: extensionIds,
                freePosition: true,
                wrapper:     wrapper
            })
            .intercept('visible', function(){
                var scene = this.scene;
                return (!scene.isNull && !scene.isIntermediate /*&& !scene.isInterpolated*/) && 
                       this.delegateExtension(true);
            })
            .override('color', function(type){
                /* 
                 * Handle dotsVisible
                 * -----------------
                 * Despite !dotsVisible,
                 * show a dot anyway when:
                 * 1) it is active, or
                 * 2) it is single  (the only dot in its series and there's only one category) (and in areas+discreteCateg+stacked case)
                 * 3) it is alone   (surrounded by null dots) (and not in areas+discreteCateg+stacked case)
                 */
                if(!dotsVisible){
                    var visible = this.scene.isActive ||
                                  (!showAloneDots && this.scene.isSingle) ||
                                  (showAloneDots && this.scene.isAlone);
                    if(!visible) {
                        return pvc.invisibleFill;
                    }
                }
                
                // TODO: review interpolated style/visibility
                if(this.scene.isInterpolated && type === 'fill'){
                    var color = this.base(type);
                    return color && pv.color(color).brighter(0.5);
                }
                
                // Follow normal logic
                return this.base(type);
            })
//            .override('interactiveColor', function(color, type){
//              return this.scene.isInterpolated && type === 'stroke' ? 
//                     color :
//                     this.base(color, type);
//            })
            .optionalMark('lineCap', 'round')
//            .intercept('strokeDasharray', function(){
//                var dashArray = this.delegateExtension();
//                if(dashArray === undefined){
//                    // TODO: review interpolated style/visibility
//                    dashArray = this.scene.isInterpolated ? '.' : null; 
//                }
//                
//                return dashArray;
//            })
            .override('defaultColor', function(type){
                var color = this.base(type);
                
                if(!this._finished && darkerLineAndDotColor && color){
                    color = color.darker(0.6);
                }
                return color;
            })
            .override('baseSize', function(){
                /* When not showing dots, 
                 * but a datum is alone and 
                 * wouldn't be visible using lines or areas,  
                 * show the dot anyway, 
                 * with a size = to the line's width^2
                 * (ideally, a line would show as a dot when only one point?)
                 */
                if(!dotsVisible) {
                    var visible = this.scene.isActive ||
                                  (!showAloneDots && this.scene.isSingle) ||
                                  (showAloneDots && this.scene.isAlone);
                    
                    if(visible && !this.scene.isActive) {
                        // Obtain the line Width of the "sibling" line
                        var lineWidth = Math.max(myself.pvLine.lineWidth(), 0.2) / 2;
                        return lineWidth * lineWidth;
                    }
                }
                
                // TODO: review interpolated style/visibility
                if(this.scene.isInterpolated){
                    return 0.8 * this.base();
                }
                
                return this.base();
            })
            .pvMark
            ;
        
        // -- LABEL --
        if(this.valuesVisible){
            this.pvLabel = new pvc.visual.Label(
                this, 
                this.pvDot.anchor(this.valuesAnchor), 
                {
                    extensionId: 'label',
                    wrapper:     wrapper
                })
                .pvMark
                .font(this.valuesFont) // default
                .text(function(scene){ return scene.vars.value.label; })
                ;
        }
    },

    /**
     * Renders this.pvScatterPanel - the parent of the marks that are affected by interaction changes.
     * @override
     */
    renderInteractive: function(){
        this.pvScatterPanel.render();
    },

    /**
     * Returns an array of marks whose instances are associated to a datum or group, or null.
     * @override
     */
    _getSelectableMarks: function(){
        var marks = [];
        
        marks.push(this.pvDot);
        
        if(this.linesVisible || this.areasVisible){
            marks.push(this.pvLine);
        }
        
        return marks;
    },
    
    /* On each series, scenes for existing categories are interleaved with intermediate scenes.
     * 
     * Protovis Dots are only shown for main (non-intermediate) scenes.
     * 
     * The desired effect is that selecting a dot selects half of the
     * line on the left and half of the line on the right.
     *  
     *  * main scene
     *  + intermediate scene
     *  - line that starts from the previous scene
     *  
     *  
     *        * - + - * - + - *
     *            [-------[
     *                ^ line extent of a dot
     *             
     * Each segment of a Protovis segmented line starts from the initial point 
     * till just before the next point.
     * 
     * So, selecting a dot must select the the line that starts on the 
     * main dot, but also the line that starts on the previous intermediate dot.
     * 
     * If a main dot shares its datums (or group) with its preceding
     * intermediate dot, the selection will work like so.
     * 
     * -------
     * 
     * Another influencing concern is interpolation.
     * 
     * The desired effect is that any two dots separated by a number of missing/null
     * categories get connected by linearly interpolating the missing values.
     * Moreover, the left half of the new line should be selected
     * when the left dot is selected and the right half of the new line
     * should be selected when the right dot is selected .
     * 
     * In the discrete-base case, the "half of the line" point always coincides
     *  a) with the point of an existing category (when count of null categs is odd)
     *  or 
     *  b) with an intermediate point added afterwards (when count of null categs is even).
     * 
     *  a) Interpolate missing/null category in S1 (odd case)
     *  mid point ----v
     *  S1    * - + - 0 - + - * - + - * 
     *  S2    * - + - * - + - * - + - *
     *  Data  A   A   B   B   B   B   C
     *  
     *  a) Interpolate missing/null category in S1 (even case)
     *    mid point ------v
     *  S1    * - + - 0 - + - 0 - + - * - + - * 
     *  S2    * - + - * - + - * - + - * - + - *
     *  Data  A   A   A   B   B   B   B
     *  
     * In the continuous-base case, 
     * the middle point between two non-null categories 
     * separated by missing/null categories in between,
     * does not, in general, coincide with the position of an existing category...
     * 
     * As such, interpolation may add new "main" points (to all the series),
     * and interpolation of one series leads to the interpolation
     * on a series that did not initially need interpolation... 
     * 
     * Interpolated dots to the left of the mid point are bound to 
     * the left data and interpolated dots to the right and 
     * including the mid point are bound to the right data. 
     */

    _buildScene: function(data, isBaseDiscrete){
        var rootScene  = new pvc.visual.Scene(null, {panel: this, group: data});
        var categDatas = data._children;
        var chart = this.chart;
        var colorVarHelper = new pvc.visual.ColorVarHelper(chart, chart._colorRole);
        var valueDim = data.owner.dimensions(this.valueDimName);
        var firstCategDim = !isBaseDiscrete ? data.owner.dimensions(this.axes.base.role.firstDimensionName()) : null;
        var isStacked = this.stacked;
        var visibleKeyArgs = {visible: true, zeroIfNone: false};
        var orthoScale = this.axes.ortho.scale;
        var orthoNullValue = def.scope(function(){
                // If the data does not cross the origin, 
                // Choose the value that's closer to 0.
                var domain = orthoScale.domain(),
                    dmin = domain[0],
                    dmax = domain[1];
                if(dmin * dmax >= 0) {
                    // Both positive or both negative or either is zero
                    return dmin >= 0 ? dmin : dmax;
                }
                
                return 0;
            });
        var orthoZero = orthoScale(0);
        var sceneBaseScale = this.axes.base.sceneScale({sceneVarName: 'category'});
        
        // ----------------------------------
        // I   - Create series scenes array.
        // ----------------------------------
        def
        .scope(function(){
            var serRole = chart._serRole;
            return (serRole && serRole.grouping)    ?
                   serRole.flatten(data).children() : // data already only contains visible data
                   def.query([null]) // null series
                   ;
        })
        /* Create series scene */
        .each(function(seriesData1, seriesIndex){
            var seriesScene = new pvc.visual.Scene(rootScene, {group: seriesData1 || data});

            seriesScene.vars.series = new pvc.visual.ValueLabelVar(
                        seriesData1 ? seriesData1.value : null,
                        seriesData1 ? seriesData1.label : "",
                        seriesData1 ? seriesData1.rawValue : null);
            
            colorVarHelper.onNewScene(seriesScene, /* isLeaf */ false);
            
            /* Create series-categ scene */
            categDatas.forEach(function(categData, categIndex){
                var group = categData;
                if(seriesData1){
                    group = group._childrenByKey[seriesData1.key];
                }
                
                var value = group ?
                    group.dimensions(valueDim.name).sum(visibleKeyArgs) : 
                    null;
                
                // TODO: really needed ?
                /* If there's no group, provide, at least, a null datum */
                var datum = group ? 
                    null : 
                    createNullDatum(seriesData1 || data, categData);
                
                // -------------
                
                var serCatScene = new pvc.visual.Scene(seriesScene, {group: group, datum: datum});
                
                // -------------
                serCatScene.dataIndex = categIndex;
                
                serCatScene.vars.category = 
                    new pvc.visual.ValueLabelVar(categData.value, categData.label, categData.rawValue);
                
                // -------------
                
                var valueVar = new pvc.visual.ValueLabelVar(
                                    value,
                                    valueDim.format(value),
                                    value);
                
                /* accumulated value, for stacked */
                // NOTE: the null value can only happen if interpolation is 'none'
                valueVar.accValue = value != null ? value : orthoNullValue;
                
                serCatScene.vars.value = valueVar;
                
                colorVarHelper.onNewScene(serCatScene, /* isLeaf */ true);
                
                // -------------
                
                var isInterpolated = false;
                //var isInterpolatedMiddle = false;
                if(group){
                    var firstDatum = group._datums[0];
                    if(firstDatum && firstDatum.isInterpolated){
                        isInterpolated = true;
                        //isInterpolatedMiddle = firstDatum.isInterpolatedMiddle;
                    }
                }
                
                serCatScene.isInterpolated = isInterpolated;
                //serCatScene.isInterpolatedMiddle = isInterpolatedMiddle;
                
                // TODO: selection, owner Scene ?
                //if(scene.isInterpolated){
                //    scene.ownerScene = toScene;
                //}
                
                // -------------
                
                serCatScene.isNull = value == null;
                serCatScene.isIntermediate = false;
            }, this);
            
        }, this);
        
        // reversed so that "below == before" w.r.t. stacked offset calculation
        // See {@link belowSeriesScenes2} variable.
        var reversedSeriesScenes = rootScene.children().reverse().array();
        var seriesCount = reversedSeriesScenes.length;
        
        /** 
         * Update the scene tree to include intermediate leaf-scenes,
         * to help in the creation of lines and areas. 
         */
        var belowSeriesScenes2; // used below, by completeSeriesScenes
        reversedSeriesScenes.forEach(completeSeriesScenes, this);
        
        /** 
         * Trim leading and trailing null scenes.
         */
        reversedSeriesScenes.forEach(trimNullSeriesScenes, this);
        
        return rootScene;
        
       function completeSeriesScenes(seriesScene) {
            var seriesScenes2 = [],
                seriesScenes = seriesScene.childNodes, 
                fromScene,
                notNullCount = 0,
                firstAloneScene = null;
            
            /* As intermediate nodes are added, 
             * seriesScene.childNodes array is changed.
             * 
             * The var 'toChildIndex' takes inserts into account;
             * its value is always the index of 'toScene' in 
             * seriesScene.childNodes.
             */
            for(var c = 0, /* category index */
                    toChildIndex = 0, 
                    categCount = seriesScenes.length ; 
                c < categCount ;
                c++, 
                toChildIndex++) {
                
                var toScene = seriesScenes[toChildIndex],
                    c2 = c * 2; /* doubled category index, for seriesScenes2  */
                
                seriesScenes2[c2] = toScene;
                
                /* Complete toScene */
                completeMainScene.call(this,
                        fromScene, 
                        toScene,
                        /* belowScene */
                        belowSeriesScenes2 && belowSeriesScenes2[c2]);
                
                if(toScene.isAlone && !firstAloneScene){
                    firstAloneScene = toScene;
                }
                
                if(!toScene.isNull){
                    notNullCount++;
                }
                
                /* Possibly create intermediate scene 
                 * (between fromScene and toScene) 
                 */
                if(fromScene) {
                    var interScene = createIntermediateScene.call(this,
                            seriesScene,
                            fromScene, 
                            toScene,
                            toChildIndex,
                            /* belowScene */
                            belowSeriesScenes2 && belowSeriesScenes2[c2 - 1]);
                    
                    if(interScene){
                        seriesScenes2[c2 - 1] = interScene;
                        toChildIndex++;
                    }
                }
                
                // --------
                
                fromScene = toScene;
            }
            
            if(notNullCount === 1 && firstAloneScene && categCount === 1){
                firstAloneScene.isSingle = true;
            }
            
            if(isStacked){
                belowSeriesScenes2 = seriesScenes2;
            } 
        }
        
        function completeMainScene( 
                      fromScene, 
                      toScene, 
                      belowScene){
            
            var toAccValue = toScene.vars.value.accValue;
            
            if(belowScene) {
                if(toScene.isNull && !isBaseDiscrete) {
                    toAccValue = orthoNullValue;
                } else {
                    toAccValue += belowScene.vars.value.accValue;
                }
                
                toScene.vars.value.accValue = toAccValue;
            }
            
            toScene.basePosition  = sceneBaseScale(toScene);
            toScene.orthoPosition = orthoZero;
            toScene.orthoLength   = orthoScale(toAccValue) - orthoZero;
            
            var isNullFrom = (!fromScene || fromScene.isNull),
                isAlone    = isNullFrom && !toScene.isNull;
            if(isAlone) {
                // Confirm, looking ahead
                var nextScene = toScene.nextSibling;
                isAlone  = !nextScene || nextScene.isNull;
            }
            
            toScene.isAlone  = isAlone;
            toScene.isSingle = false;
        }
        
        function createIntermediateScene(
                     seriesScene, 
                     fromScene, 
                     toScene, 
                     toChildIndex,
                     belowScene){
            
            var interIsNull = fromScene.isNull || toScene.isNull;
            if(interIsNull && !this.areasVisible) {
                return null;
            }
            
            var interValue, interAccValue, interBasePosition;
                
            if(interIsNull) {
                /* Value is 0 or the below value */
                if(belowScene && isBaseDiscrete) {
                    var belowValueVar = belowScene.vars.value;
                    interAccValue = belowValueVar.accValue;
                    interValue = belowValueVar[this.valueRoleName];
                } else {
                    interValue = interAccValue = orthoNullValue;
                }
                
                if(isStacked && isBaseDiscrete) {
                    // The intermediate point is at the start of the "to" band
                    // don't use .band, cause it does not include margins...
                    interBasePosition = toScene.basePosition - (sceneBaseScale.range().step / 2); 
                } else if(fromScene.isNull) { // Come from NULL
                    // Align directly below the (possibly) non-null dot
                    interBasePosition = toScene.basePosition;
                } else /*if(toScene.isNull) */{ // Go to NULL
                    // Align directly below the non-null from dot
                    interBasePosition = fromScene.basePosition;
                } 
//                    else {
//                        interBasePosition = (toScene.basePosition + fromScene.basePosition) / 2;
//                    }
            } else {
                var fromValueVar = fromScene.vars.value,
                    toValueVar   = toScene.vars.value;
                
                interValue = (toValueVar.value + fromValueVar.value) / 2;
                
                // Average of the already offset values
                interAccValue     = (toValueVar.accValue  + fromValueVar.accValue ) / 2;
                interBasePosition = (toScene.basePosition + fromScene.basePosition) / 2;
            }
            
            //----------------
            
            var interScene = new pvc.visual.Scene(seriesScene, {
                    /* insert immediately before toScene */
                    index: toChildIndex,
                    group: /*toScene.isInterpolatedMiddle ? fromScene.group: */toScene.group, 
                    datum: toScene.group ? null : toScene.datum
                });
            
            interScene.dataIndex = toScene.dataIndex;
            interScene.vars.category = toScene.vars.category;
            
            var interValueVar = new pvc.visual.ValueLabelVar(
                                    interValue,
                                    valueDim.format(interValue),
                                    interValue);
            
            interValueVar.accValue = interAccValue;
            
            interScene.vars.value = interValueVar;
            interScene.ownerScene     = toScene;
            interScene.isInterpolated = toScene.isInterpolated;
            interScene.isIntermediate = true;
            interScene.isSingle       = false;
            interScene.isNull         = interIsNull;
            interScene.isAlone        = interIsNull && toScene.isNull && fromScene.isNull;
            interScene.basePosition   = interBasePosition;
            interScene.orthoPosition  = orthoZero;
            interScene.orthoLength    = orthoScale(interAccValue) - orthoZero;
            
            colorVarHelper.onNewScene(interScene, /* isLeaf */ true);
            
            return interScene;
        }
        
        function trimNullSeriesScenes(seriesScene) {
            
            var seriesScenes = seriesScene.childNodes,
                L = seriesScenes.length;
            
            // from beginning
            var scene, siblingScene;
            while(L && (scene = seriesScenes[0]).isNull) {
                
                // Don't remove the intermediate dot before the 1st non-null dot
                siblingScene = scene.nextSibling;
                if(siblingScene && !siblingScene.isNull){
                    break;
                }
                
                seriesScene.removeAt(0);
                L--;
            }
            
            // from end
            while(L && (scene = seriesScenes[L - 1]).isNull) {
                
                // Don't remove the intermediate dot after the last non-null dot
                siblingScene = scene.previousSibling;
                if(siblingScene && !siblingScene.isNull){
                    break;
                }
                
                seriesScene.removeAt(L - 1);
                L--;
            }
        } 
        
        function createNullDatum(serData1, catData1) {
            // Create a null datum with col and row coordinate atoms
            var atoms = serData1 && catData1 ?
                        def.copy(def.copy({}, serData1.atoms), catData1.atoms) :
                        (serData1 ? serData1.atoms :  catData1.atoms)
                        ;
            
            return new pvc.data.Datum(data, atoms, true);
        }
    }
});

/**
 * PointAbstract is the class that will be extended by
 * dot, line, stacked-line and area charts.
 */
def
.type('pvc.PointAbstract', pvc.CategoricalAbstract)
.add({
    
    _processOptionsCore: function(options){
        // Has no meaning in this chart type
        options.panelSizeRatio = 1;
        
        this.base(options);
    },
    
    _hasDataPartRole: function(){
        return true;
    },
    
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
        
        this._addVisualRole('value', { 
                isMeasure: true, 
                isRequired: true, 
                isPercent: this.options.stacked,
                requireSingleDimension: true, 
                requireIsDiscrete: false, 
                valueType: Number, 
                defaultDimension: 'value' 
            });
    },
    
    _initPlotsCore: function(hasMultiRole){
        var options = this.options;
        
        var pointPlot = this._createPointPlot();
        var trend = pointPlot.option('Trend');
        
        if(options.plot2){
            // Line Plot
            var plot2Plot = new pvc.visual.PointPlot(this, {
                name: 'plot2',
                fixed: {
                    DataPart: '1'
                },
                defaults: {
                    ColorAxis:    2,
                    LinesVisible: true,
                    DotsVisible:  true
                }});

            if(!trend){
                trend = plot2Plot.option('Trend');
            }
        }
        
        if(trend){
            // Trend Plot
            new pvc.visual.PointPlot(this, {
                name: 'trend',
                fixed: {
                    DataPart: 'trend',
                    TrendType: 'none',
                    ColorRole: 'series', // one trend per series
                    NullInterpolatioMode: 'none'
                },
                defaults: {
                    ColorAxis:    2,
                    LinesVisible: true,
                    DotsVisible:  false
                }
            });
        }
    },
    
    _bindAxes: function(hasMultiRole){
        
        this.base(hasMultiRole);
        
        // Set defaults of Offset property
        var typeAxes = this.axesByType.base;
        if(typeAxes){
            typeAxes.forEach(function(axis){
                var isDiscrete = axis.scaleType === 'discrete';
                if(!isDiscrete){
                    axis.option.defaults({Offset: 0.01});
                }
            });
        }
        
        typeAxes = this.axesByType.ortho;
        if(typeAxes){
            typeAxes.forEach(function(axis){
                axis.option.defaults({Offset: 0.04});
            });
        }
    },
    
    //_createPointPlot: function(){},
    
    /* @override */
    _createPlotPanels: function(parentPanel, baseOptions){
        var options = this.options;
        var axes    = this.axes;
        var plots   = this.plots;
        
        var pointPlot = plots.point;
            this.scatterChartPanel = 
            new pvc.PointPanel(
                this, 
                parentPanel, 
                pointPlot, 
                Object.create(baseOptions));
        
        var plot2Plot = plots.plot2;
        if(plot2Plot){
            if(pvc.debug >= 3){
                this._log("Creating second Point panel.");
            }
            
            new pvc.PointPanel(
                    this, 
                    parentPanel, 
                    plot2Plot,
                    Object.create(baseOptions));
        }
        
        var trendPlot = plots.trend;
        if(trendPlot){
            if(pvc.debug >= 3){
                this._log("Creating Trends Point panel.");
            }
            
            new pvc.PointPanel(
                    this, 
                    parentPanel, 
                    trendPlot,
                    Object.create(baseOptions));
        }
    },
    
    defaults: {
        tooltipOffset: 10
    }
});

/**
 * Dot Chart
 */
def
.type('pvc.DotChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed: {DotsVisible: true}
        });
    }
});

/**
 * Line Chart
 */
def
.type('pvc.LineChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed: {LinesVisible: true}
        });
    }
});

/**
 * Area Chart
 */
def
.type('pvc.AreaChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed: {AreasVisible: true}
        });
    }
});

/**
 * Stacked Line Chart
 */
pvc.mStackedLineChart = // V1 compatibility    
def
.type('pvc.StackedLineChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed: {LinesVisible: true, Stacked: true}
        });
    }
});

/**
 * Stacked Dot Chart
 */
def
.type('pvc.StackedDotChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed: {DotsVisible: true, Stacked: true}
        });
    }
});

/**
 * Stacked Area Chart
 */
pvc.mStackedAreaChart = // V1 compatibility
def
.type('pvc.StackedAreaChart', pvc.PointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.PointPlot(this, {
            fixed:    {AreasVisible: true, Stacked: true},
            defaults: {LinesVisible: true}
        });
    }
});

/*
 * HeatGrid chart panel. Generates a heatGrid chart. Specific options are:
 * <i>orientation</i> - horizontal or vertical. Default: vertical
 * <i>valuesVisible</i> - Show or hide heatGrid value. Default: false
 * <i>maxHeatGridSize</i> - Maximum size of a heatGrid in pixels. Default: 2000
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>heatGrid_</i> - for the actual heatGrid
 * <i>heatGridPanel_</i> - for the panel where the heatGrids sit
 * <i>heatGridLabel_</i> - for the main heatGrid label
 */
def
.type('pvc.HeatGridPanel', pvc.CategoricalAbstractPanel)
.init(function(chart, parent, plot, options) {
    
    this.base(chart, parent, plot, options);
    
    this.axes.size = chart.getAxis('size', plot.option('SizeAxis') - 1); // may be undefined
    
    this.useShapes = plot.option('UseShapes');
    this.shape     = plot.option('Shape');
    this.nullShape = plot.option('NullShape');
})
.add({

    pvHeatGrid: null,
    pvHeatGridLabel: null,
    
    defaultBorder:  1,
    nullBorder:     2,
    selectedBorder: 2,
    
    /**
     * @override
     */
    _createCore: function(){
        
        this.base();
        
        // TODO: this options treatment is highly "non-standard". Refactor to chart + panel-constructor
        
        var chart = this.chart,
            options = chart.options,
            me = this;

        var colorDimName = this.colorDimName = chart._colorDim && chart._colorDim.name,
            sizeDimName  = this.sizeDimName  = chart._sizeDim  && chart._sizeDim.name;
        
        var a_bottom = this.isOrientationVertical() ? "bottom" : "left";

        /* Use existing scales */
        var xScale = this.axes.x.scale,
            yScale = this.axes.y.scale;

        /* Determine cell dimensions. */
        var w = (xScale.max - xScale.min) / xScale.domain().length;
        var h = (yScale.max - yScale.min) / yScale.domain().length;

        if (a_bottom !== "bottom") {
            var tmp = w;
            w = h;
            h = tmp;
        }
        
        this._cellWidth  = w;
        this._cellHeight = h;
        
        /* Column and Row datas  */
        var keyArgs = {visible: true},
            // Two multi-dimension single-level data groupings
            
            colRootData = chart.data.flattenBy(chart._catRole, keyArgs),
            rowRootData = chart.data.flattenBy(chart._serRole, keyArgs),
            
            // <=> One multi-dimensional, two-levels data grouping
            data = this._getVisibleData(),
            
            rootScene = this._buildScene(data, rowRootData);
        
        /* COLOR */
        
        var getFillColor;
        var colorAxis = this.axes.color;
        var colorNull = colorAxis.option('Missing');
        if(colorDimName){
            var fillColorScaleByColKey = colorAxis.scalesByCateg;
            if(fillColorScaleByColKey){
                getFillColor = function(leafScene){
                    var colorValue = leafScene.vars.color.value;
                    if(colorValue == null) {
                        return colorNull;
                    }
                    
                    var colAbsKey = leafScene.group.parent.absKey;
                    return fillColorScaleByColKey[colAbsKey](colorValue);
                };
            } else {
                var colorScale = colorAxis.scale;
                getFillColor = function(leafScene){
                    return colorScale(leafScene.vars.color.value);
                };
            }
        } else {
            getFillColor = def.fun.constant(colorNull);
        }
        
        /* PV Panels */
        var a_left   = pvc.BasePanel.relativeAnchor[a_bottom];
        var a_width  = pvc.BasePanel.parallelLength[a_bottom];
        var a_height = pvc.BasePanel.orthogonalLength[a_bottom];
        
        var pvRowPanel = new pvc.visual.Panel(this, this.pvPanel)
            .pvMark
            .data(rootScene.childNodes)
            [a_bottom](function(){ return this.index * h; })
            [a_height](h)
            ;
        
        var wrapper;
        if(this.compatVersion() <= 1){
            var colorValuesBySerAndCat = 
                def
                .query(rootScene.childNodes)
                .object({
                    name:  function(serScene){ return '' + serScene.vars.series.value; },
                    value: function(serScene){ 
                        return def
                            .query(serScene.childNodes)
                            .object({
                                name:  function(leafScene){ return '' + leafScene.vars.category.value; },
                                value: function(leafScene){
                                    var colorVar = leafScene.vars.color;
                                    return colorVar ? ('' + colorVar.value) : null;
                                }
                            });
                    }
                });
                
            wrapper = function(v1f){
                return function(leafScene){
                    var colorValuesByCat = colorValuesBySerAndCat[leafScene.vars.series.value];
                    var cat = leafScene.vars.category.rawValue;
                    
                    var wrapperParent = Object.create(this.parent);
                    var wrapper = Object.create(this);
                    wrapper.parent = wrapperParent;
                    
                    // Previously, first panel was by cats and 
                    // the second (child) panel was by series
                    var catIndex = leafScene.childIndex();
                    var serIndex = leafScene.parent.childIndex();
                    
                    wrapperParent.index = catIndex;
                    wrapper.index = serIndex;
                    
                    return v1f.call(wrapper, colorValuesByCat, cat);
                };
            };
        }
        
        /* Cell panel */
        var extensionIds = ['panel'];
        if(this.compatVersion() <= 1){
            extensionIds.push(''); // let access as "heatGrid_"
        }
        
        keyArgs = { // reuse var
            extensionId: extensionIds,
            wrapper:     wrapper
        };
        
        if(!this.useShapes){
            // When no shapes are used,
            // clicks, double-clicks and tooltips are all handled by
            // the cell panel
            keyArgs.noSelect = 
            keyArgs.noHover = 
            keyArgs.noClick = 
            keyArgs.noDoubleClick = 
            keyArgs.freeColor = false;
            
            keyArgs.noTooltip = !!wrapper; // V1 had no tooltips
        }
        
        var pvHeatGrid = this.pvHeatGrid = new pvc.visual.Panel(this, pvRowPanel, keyArgs)
            .lock('data', function(serScene){ return serScene.childNodes; })
            .pvMark
            
            .localProperty('colorValue')
            .lock('colorValue', function(leafScene){
                return colorDimName && leafScene.vars.color.value;
            })
            
            .localProperty('sizeValue')
            .lock('sizeValue', function(leafScene){
                return sizeDimName && leafScene.vars.size.value;
            })
            
            .lock(a_left,  function(){ return this.index * w; })
            .lock(a_width, w)
            
            .antialias(false)
            //.lineWidth(0)
            ;
            // THIS caused HUGE memory consumption and speed reduction (at least in use Shapes mode)
            //.overflow('hidden'); //overflow important if valuesVisible=true
        
        
        if(this.useShapes){
            this.shapes = this.createHeatMap(w, h, getFillColor, wrapper);
        } else {
            this.shapes = pvHeatGrid
                .sign
                .override('defaultColor', function(type){
                    if(type === 'stroke'){
                        return null;
                    }
                    
                    return getFillColor.call(this.pvMark, this.scene);
                })
                .override('interactiveColor', function(color, type){
                    var scene = this.scene;
                    if(scene.isActive) {
                        return color.alpha(0.6);
                    }
                    
                    if(scene.anySelected() && !scene.isSelected()) {
                        return this.dimColor(color, type);
                    }
                    
                    return this.base(color, type);
                })
                .override('dimColor', function(color, type){
                    return pvc.toGrayScale(color, 0.6);
                })
                .pvMark
                .lineWidth(1.5)
                ;
        }
        
        // TODO: valueMask??
        var valueDimName = this.valueDimName = colorDimName || sizeDimName;
        
        if(this.valuesVisible && valueDimName){
            this.pvHeatGridLabel = new pvc.visual.Label(
                this, 
                this.pvHeatGrid.anchor("center"), 
                {
                    extensionId: 'label',
                    wrapper:     wrapper
                })
                .pvMark
                .font(this.valuesFont) // default
                .text(function(leafScene){
                    return leafScene.atoms[valueDimName].label;
                })
                ;
        }
    },

    _calcDotAreaRange: function(w, h){
        
        var maxRadius = Math.min(w, h) / 2;
        
        if(this.shape === 'diamond'){
            // Protovis draws diamonds inscribed on
            // a square with half-side radius*Math.SQRT2
            // (so that diamonds just look like a rotated square)
            // For the height of the dimanod not to exceed the cell size
            // we compensate that factor here.
            maxRadius /= Math.SQRT2;
        }

        // Small margin
        maxRadius -= 2;
        
        var maxArea  = maxRadius * maxRadius, // apparently treats as square area even if circle, triangle is different
            minArea  = 12,
            areaSpan = maxArea - minArea;

        if(areaSpan <= 1){
            // Very little space
            // Rescue Mode - show *something*
            maxArea = Math.max(maxArea, 2);
            minArea = 1;
            areaSpan = maxArea - minArea;
            
            if(pvc.debug >= 2){
                this._log("Using rescue mode dot area calculation due to insufficient space.");
            }
        }
        
        return {
            min:  minArea,
            max:  maxArea,
            span: areaSpan
        };
    },
    
    createHeatMap: function(w, h, getFillColor, wrapper){
        var myself = this,
            chart = this.chart,
            data = chart.data,
            sizeDimName  = this.sizeDimName,
            colorDimName = this.colorDimName,
            nullShapeType = this.nullShape,
            shapeType = this.shape;
        
        /* SIZE */
        var areaRange = this._calcDotAreaRange(w, h);
        var maxArea = areaRange.max;
        
        var sizeScale;
        var sizeAxis = this.axes.size;
        if(sizeAxis && sizeAxis.isBound()){
            sizeScale = sizeAxis
                .setScaleRange(areaRange)
                .scale;
        } else {
            sizeDimName = null;
        }
        
        /* BORDER WIDTH & COLOR */
        var notNullSelectedBorder = (this.selectedBorder == null || (+this.selectedBorder) === 0) ? 
                                     this.defaultBorder : 
                                     this.selectedBorder;
        
        var nullSelectedBorder = (this.selectedBorder == null || (+this.selectedBorder) === 0) ? 
                                  this.nullBorder : 
                                  this.selectedBorder;
        
        var nullDeselectedBorder = this.defaultBorder > 0 ? this.defaultBorder : this.nullBorder;
        
       /* SHAPE TYPE & SIZE */
        var getShapeType;
        if(!sizeDimName) {
            getShapeType = def.fun.constant(shapeType);
        } else {
            getShapeType = function(){
                return this.parent.sizeValue() != null ? shapeType : nullShapeType;
            };
        }
        
        var getShapeSize;
        if(!sizeDimName){
            getShapeSize = function(){
                /* When neither color nor size dimensions */
                return (colorDimName && !nullShapeType && this.parent.colorValue() == null) ? 0 : maxArea;
            };
        } else {
            getShapeSize = function(){
                var sizeValue = this.parent.sizeValue();
                return (sizeValue == null && !nullShapeType) ? 0 : sizeScale(sizeValue);
            };
        }
        
        // Dot
        var keyArgs = {
            extensionId: 'dot',
            freePosition: true,
            activeSeriesAware: false,
            noHover:      false,
            wrapper:      wrapper
        };
        
        var options = chart.options;
        if(wrapper && chart._tooltipEnabled){
            var customTooltip = options.customTooltip;
            if(!customTooltip){
                customTooltip = function(s,c,d){ 
                    if(d != null && d[0] !== undefined){
                        return d.join(', ');
                    }
                    return d;
                };
            }
            
            keyArgs.tooltipArgs = {
                buildTooltip: 
                    options.isMultiValued ?
                    function(context){
                        var group = context.scene.group;
                        var s = pvc.data.Complex.values(group, chart._serRole.grouping.dimensionNames());
                        var c = pvc.data.Complex.values(group, chart._catRole.grouping.dimensionNames());
                        
                        var d = [];
                        if(sizeDimName){
                            d[options.sizeValIdx  || 0] = context.scene.vars.size.value;
                        }
                        if(colorDimName){
                            d[options.colorValIdx || 0] = context.scene.vars.color.value;
                        }
                        
                        return customTooltip.call(options, s, c, d);
                    } : 
                    function(context){
                        var s = context.scene.vars.series.rawValue;
                        var c = context.scene.vars.category.rawValue;
                        var valueVar = context.scene.vars[colorDimName ? 'color' : 'size'];
                        var d = valueVar ? valueVar.value : null;
                        return customTooltip.call(options, s, c, d);
                    }
            };
        }
        
        return new pvc.visual.Dot(this, this.pvHeatGrid, keyArgs)
            .override('defaultSize', function(){
                return getShapeSize.call(this.pvMark, this.scene);
            })
            .override('interactiveSize', function(size){
                if(this.scene.isActive){
                    return Math.max(size, 5) * 1.5;
                }
                
                return size;
            })
            .override('baseColor', function(type){
                return getFillColor.call(this.pvMark.parent, this.scene);
            })
            .override('normalColor', function(color, type){
                if(type === 'stroke'){
                    return color.darker();
                }
                
                return this.base(color, type);
            })
            .override('interactiveColor', function(color, type){
                var scene = this.scene;
                
                if(type === 'stroke'){
                    if(scene.anySelected() && !scene.isSelected()){
                        return color;
                    }
                    
                    return color.darker();
                }
                
                if(scene.isActive){
                    return color.alpha(0.6);
                }
                
                return this.base(color, type);
            })
            .override('dimColor', function(color, type){
                return pvc.toGrayScale(color, 0.6);
            })
            .pvMark
            
            .shape(getShapeType)
            
            .lock('shapeAngle') // rotation of shapes can cause them to not fit the calculated cell. Would have to improve the radius calculation code.
            
            .lineWidth(function(leafScene){
                if(!sizeDimName || !myself._isNullShapeLineOnly() || this.parent.sizeValue() != null){
                    return leafScene.isSelected() ? notNullSelectedBorder : myself.defaultBorder;
                }

                // is null
                return leafScene.isSelected() ? nullSelectedBorder : nullDeselectedBorder;
            })
            ;
    },

    _isNullShapeLineOnly: function(){
        return this.nullShape == 'cross';  
    },

    /**
     * Returns an array of marks whose instances are associated to a datum, or null.
     * @override
     */
    _getSelectableMarks: function(){
        return [this.shapes];
    },
    
    /**
     * Renders the heat grid panel.
     * @override
     */
    renderInteractive: function(){
        this.pvPanel.render();
    },
    
    _buildScene: function(data, seriesRootData){
        var rootScene  = new pvc.visual.Scene(null, {panel: this, group: data});
        var categDatas = data._children;
        
        var chart = this.chart;
        var colorRootDim = chart._colorDim;
        var sizeRootDim  = chart._sizeDim;
        
        /**
         * Create starting scene tree
         */
        seriesRootData
            .children()
            .each(createSeriesScene, this);

        return rootScene;

        function createSeriesScene(serData1){
            /* Create series scene */
            var serScene = new pvc.visual.Scene(rootScene, {group: serData1});

            serScene.vars.series = new pvc.visual.ValueLabelVar(
                serData1.value,
                serData1.label,
                serData1.rawValue);
            
            categDatas.forEach(function(catData1){
                createSeriesCategoryScene.call(this, serScene, catData1, serData1); 
            }, this);
        }

        function createSeriesCategoryScene(serScene, catData1, serData1){
            /* Create leaf scene */
            var group = 
                data
                ._childrenByKey[catData1.key]
                ._childrenByKey[serData1.key];
            
            var singleDatum = group && group.singleDatum();
            
            /* If there's no group, provide, at least, a null datum */
            var datum = group ? null : createNullDatum(serData1, catData1);
            
            var serCatScene = new pvc.visual.Scene(serScene, {group: group, datum: datum});
            var catVars  = serCatScene.vars;
            
            catVars.category = 
                new pvc.visual.ValueLabelVar(
                    catData1.value, 
                    catData1.label, 
                    catData1.rawValue);
            
            var value, label;
            
            var chart = this.chart;
            if(colorRootDim){
                if(singleDatum){
                    catVars.color = Object.create(singleDatum.atoms[colorRootDim.name]);
                } else {
                    value = group ? 
                             group
                             .dimensions(colorRootDim.name)
                             .sum({visible: true, zeroIfNone: false}) :
                            null;
                    
                    label = colorRootDim.format(value);
                    
                    catVars.color = new pvc.visual.ValueLabelVar(value, label, value);
                }
            }
            
            if(sizeRootDim){
                if(singleDatum){
                    catVars.size = Object.create(singleDatum.atoms[sizeRootDim.name]);
                } else {
                    value = group ? 
                             group
                             .dimensions(sizeRootDim.name)
                             .sum({visible: true, zeroIfNone: false}) :
                            null;
                    
                    label = sizeRootDim.format(value);
                    
                    catVars.size = new pvc.visual.ValueLabelVar(value, label, value);
                }
            }

            serCatScene.isNull = !group; // A virtual scene?
        }
        
        function createNullDatum(serData1, catData1) {
            // Create a null datum with col and row coordinate atoms
            var atoms = def.copy(def.copy({}, serData1.atoms), catData1.atoms);
            return new pvc.data.Datum(data, atoms, true);
        }
    }
});

/**
 * HeatGridChart is the main class for generating... heatGrid charts.
 *  A heatGrid visualizes a matrix of values by a grid (matrix) of *
 *  bars, where the color of the bar represents the actual value.
 *  By default the colors are a range of green values, where
 *  light green represents low values and dark green high values.
 *  A heatGrid contains:
 *     - two categorical axis (both on x and y-axis)
 *     - no legend as series become rows on the perpendicular axis 
 *  Please contact CvK if there are issues with HeatGrid at cde@vinzi.nl.
 */
def
.type('pvc.HeatGridChart', pvc.CategoricalAbstract)
.init(function(options){

    this.base(options);

    var parent = this.parent;
    if(parent) {
        this._sizeRole  = parent._sizeRole;
    }
})
.add({
    _allowColorPerCategory: true,
    
    _processOptionsCore: function(options){
        
        this.base(options);
        
        def.set(options, 
            'orthoAxisOrdinal', true,
            'legend', false,
                
            // Has no meaning in the current implementation
            'panelSizeRatio', 1);
        
     // TODO: get a translator for this!!
        
        var colorDimName = 'value',
            sizeDimName  = 'value2';

        if(this.compatVersion() <= 1){
            switch(this.options.colorValIdx){
                case 0:  colorDimName = 'value';  break;
                case 1:  colorDimName = 'value2'; break;
                default: colorDimName = 'value';
            }
    
            switch(this.options.sizeValIdx){
                case 0:  sizeDimName = 'value' ; break;
                case 1:  sizeDimName = 'value2'; break;
                default: sizeDimName = 'value' ;
            }
        }
        
        this._colorDimName = colorDimName;
        this._sizeDimName  = sizeDimName ;
    },
    
    _getCategoryRoleSpec: function(){
        var catRoleSpec = this.base();
        
        // Force dimension to be discrete!
        catRoleSpec.requireIsDiscrete = true;
        
        return catRoleSpec;
    },
    
    _getColorRoleSpec: function(){
        return {
            isMeasure: true,
            requireSingleDimension: true,
            requireIsDiscrete: false,
            valueType: Number,
            defaultDimension: this._colorDimName
        };
    },
    
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
        
        this._sizeRole = this._addVisualRole('size', {
                isMeasure: true,
                requireSingleDimension: true,
                requireIsDiscrete: false,
                valueType: Number,
                defaultDimension: this._sizeDimName
            });
    },

    _initData: function(keyArgs){
        
        this.base(keyArgs);

        // Cached
        var sizeGrouping = this._sizeRole.grouping;
        if(sizeGrouping){
            this._sizeDim = this.data.dimensions(sizeGrouping.firstDimensionName());
        }

        var colorGrouping = this._colorRole.grouping;
        if(colorGrouping) {
            this._colorDim = this.data.dimensions(colorGrouping.firstDimensionName());
        }
    },
    
    _initPlotsCore: function(hasMultiRole){
        new pvc.visual.HeatGridPlot(this);
    },
    
    _collectPlotAxesDataCells: function(plot, dataCellsByAxisTypeThenIndex){
        
        this.base(plot, dataCellsByAxisTypeThenIndex);
        
        /* Configure Base Axis Data Cell */
        if(plot.type === 'heatGrid' && plot.option('UseShapes')){
            
            var sizeRole = this.visualRoles(plot.option('SizeRole'));
            if(sizeRole.isBound()){
                
                var sizeDataCellsByAxisIndex = 
                    def
                    .array
                    .lazy(dataCellsByAxisTypeThenIndex, 'size');
                
                def
                .array
                .lazy(sizeDataCellsByAxisIndex, plot.option('SizeAxis') - 1)
                .push({
                    plot:          plot,
                    role:          this.visualRoles(plot.option('SizeRole')),
                    dataPartValue: plot.option('DataPart')
                });
            }
        }
    },
    
    _setAxesScales: function(hasMultiRole){
        
        this.base(hasMultiRole);
        
        if(!hasMultiRole || this.parent){
            
            var sizeAxis = this.axes.size;
            if(sizeAxis && sizeAxis.isBound()){
                this._createAxisScale(sizeAxis);
            }
        }
    },
    
    /* @override */
    _createPlotPanels: function(parentPanel, baseOptions){
        var heatGridPlot = this.plots.heatGrid;
        
        this.heatGridChartPanel = 
                new pvc.HeatGridPanel(
                        this, 
                        parentPanel, 
                        heatGridPlot, 
                        Object.create(baseOptions));
    },
    
    defaults: {
        colorValIdx: 0,
        sizeValIdx:  1,
        measuresIndexes: [2], // TODO: ???
        animate:    false,
        axisOffset: 0,
        
        plotFrameVisible: false,

        //customTooltip: undefined, // V1 & useShapes only
        
//      nullShape: undefined,
//      shape: undefined,
//      useShapes: false,
      
        /* Size Role */
//      sizeAxisUseAbs: true,
//      sizeAxisFixedMin: undefined,
//      sizeAxisFixedMax: undefined,
//      sizeAxisOriginIsZero: false,
        
        // TODO: continuous color scale...
        
        /* Color Role */
//      colorScaleType: "linear",  // "discrete", "normal" (distribution) or "linear"
        
        colorNormByCategory: true,
        numSD: 2   // width (only for normal distribution)
        //colors: ['red', 'yellow','green']
        
//      colorDomain:  undefined,
//      colorMin: undefined, //"white",
//      colorMax: undefined, //"darkgreen",
//      colorNull:  "#efc5ad"  // white with a shade of orange
    }
});

/**
 * MetricXYAbstract is the base class of metric XY charts.
 * (Metric stands for:
 *   Measure, Continuous or Not-categorical base and ortho axis)
 */
def
.type('pvc.MetricXYAbstract', pvc.CartesianAbstract)
.init(function(options){

    this.base(options);

    var parent = this.parent;
    if(parent) {
        this._xRole = parent._xRole;
        this._yRole = parent._yRole;
    }
})
.add({
    _processOptionsCore: function(options){
        
        this.base(options);
        
        // Has no meaning in this chart type
        // Only used by discrete scales
        options.panelSizeRatio = 1;
    },

    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){

        this.base();

        this._xRole = this._addVisualRole('x', {
                isMeasure: true,
                isRequired: true,
                requireSingleDimension: true,
                requireIsDiscrete: false,
                defaultDimension: 'x',
                dimensionDefaults: {
                    valueType: this.options.timeSeries ? Date : Number
                }
            });
        
        this._yRole = this._addVisualRole('y', {
                isMeasure: true,
                isRequired: true,
                requireSingleDimension: true,
                requireIsDiscrete: false,
                defaultDimension: 'y',
                dimensionDefaults: {
                    valueType: Number
                }
            });
    },

    _initData: function(){
        this.base.apply(this, arguments);

        // Cached
        this._xDim = this.data.dimensions(this._xRole.firstDimensionName());
        this._yDim = this.data.dimensions(this._yRole.firstDimensionName());
    },
    
    _generateTrendsDataCellCore: function(newDatums, dataCell, trendInfo){
        var serRole = this._serRole;
        var xRole   = this._xRole;
        var yRole   = dataCell.role;
        var trendOptions = dataCell.trend;
        
        this._warnSingleContinuousValueRole(yRole);
        
        var dataPartDimName = this._dataPartRole.firstDimensionName();
        var xDimName = xRole.firstDimensionName();
        var yDimName = yRole.firstDimensionName();
        
        // Visible part data, possibly grouped by series (if series is bound)
        var data = this._getVisibleData(dataCell.dataPartValue);
        
        // For each series...
        def
        .scope(function(){
            return serRole.isBound()   ?
                   data.children() : // data already only contains visible data
                   def.query([data]) // null series
                   ;
        })
        .each(genSeriesTrend, this)
        ;
        
        function genSeriesTrend(serData){
            var funX = function(datum){
                    return datum.atoms[xDimName].value;
                };
            
            var funY = function(datum){
                    return datum.atoms[yDimName].value;
                };
            
            var datums = 
                serData
                .datums()
                .sort(null, /* by */funX)
                .array();
            
            var options = def.create(trendOptions, {
                    rows: def.query(datums),
                    x: funX,
                    y: funY
                });

            var trendModel = trendInfo.model(options);
            if(trendModel){
                
                // If a label has already been registered, it is preserved... (See BaseChart#_fixTrendsLabel)
                var dataPartAtom = data.owner
                                .dimensions(dataPartDimName)
                                .intern(this.root._firstTrendAtomProto);
                
                datums.forEach(function(datum, index){
                    var trendX = funX(datum);
                    if(trendX){
                        var trendY = trendModel.sample(trendX, funY(datum), index);
                        if(trendY != null){
                            var atoms = 
                                def.set(
                                    Object.create(serData.atoms), // just common atoms
                                    xDimName, trendX,
                                    yDimName, trendY,
                                    dataPartDimName, dataPartAtom);
                            
                            newDatums.push(
                                def.set(
                                    new pvc.data.Datum(data.owner, atoms),
                                    'isVirtual', true,
                                    'isTrend',   true,
                                    'trendType', trendInfo.type));
                        }
                    }
                });
            }
        }
    }
});

/**
 * @name pvc.data.MetricPointChartTranslationOper
 * 
 * @class The translation mixin of the Metric XY charts.
 * 
 * <p>
 * The default format is:
 * </p>
 * <pre>
 * +----------+----------+----------+----------+----------+
 * | 0        | 1        | 2        | 3        | 4        |
 * +----------+----------+----------+----------+----------+
 * | series   | x        | y        | color    | size     |
 * +----------+----------+----------+----------+----------+
 * | discrete | number   | number   | num/disc | number   |
 * +----------+----------+----------+----------+----------+
 * </pre>
 * 
 * <p>
 * Color dimensions will be continuous by default.
 * If that is not the case, 
 * an explicit dimension valueType definition must be provided.
 * </p>
 * 
 * @extends pvc.data.MatrixTranslationOper
 */
def.type('pvc.data.MetricPointChartTranslationOper')
.add(/** @lends pvc.data.MetricPointChartTranslationOper# */{
    
    _meaLayoutRoles: ['x', 'y', 'color', 'size'],
    
    configureType: function(){
        var itemTypes = this._itemTypes;
        
        var V = itemTypes.length;
        
        // VItem Indexes of continuous columns not yet being read
        var freeMeaIndexes = [];
        
        // Idem, but for discrete columns
        var freeDisIndexes = [];
        
        def
        .range(0, V)
        .each(function(j){
            if(!this._userUsedIndexes[j]){
                if(itemTypes[j] === 1){
                    freeMeaIndexes.push(j);
                } else {
                    freeDisIndexes.push(j);
                }
            }
        }, this);
        
        // Distribute free measure columns by unbound measure roles 
        var N;
        var autoDimNames = [];
        var F = freeMeaIndexes.length;
        if(F > 0){
            // Collect the default dimension names of the 
            // first F unbound roles
            var R = this._meaLayoutRoles.length;
            var i = 0;
            while(i < R && autoDimNames.length < F){
                // If the measure role is unbound and has a default dimension,
                //  the next unused dimension of the default dimension group name
                //  is placed in autoDimNames.
                // If any, this dimension will be fed with the next freeMeaIndexes
                this._getUnboundRoleDefaultDimNames(this._meaLayoutRoles[i], 1, autoDimNames);
                i++;
            }
            
            N = autoDimNames.length;
            if(N > 0){
                freeMeaIndexes.length = N;
                this.defReader({names: autoDimNames, indexes: freeMeaIndexes});
            }
        }
        
        // All discrete columns go to series dimensions
        F = freeDisIndexes.length;
        if(F > 0){
            autoDimNames.length = 0;
            this._getUnboundRoleDefaultDimNames('series', F, autoDimNames);
            
            N = autoDimNames.length;
            if(N > 0){
                freeDisIndexes.length = N;
                this.defReader({names: autoDimNames, indexes: freeDisIndexes});
            }
        }
    }
});
/*
 * Metric Line/Dot panel.
 * Class that draws dot and line plots.
 * Specific options are:
 * <i>dotsVisible</i> - Show or hide dots. Default: true
 * <i>linesVisible</i> - Show or hide dots. Default: true
 * <i>valuesVisible</i> - Show or hide line value. Default: false
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>line_</i> - for the actual line
 * <i>linePanel_</i> - for the panel where the lines sit
 * <i>lineDot_</i> - the dots on the line
 * <i>lineLabel_</i> - for the main line label
 */
def
.type('pvc.MetricPointPanel', pvc.CartesianAbstractPanel)
.init(function(chart, parent, plot, options) {
    
    this.base(chart, parent, plot, options);
    
    var sizeAxisIndex = plot.option('SizeAxis');
    this.axes.size  = sizeAxisIndex != null ? chart.getAxis('size', sizeAxisIndex - 1) : null;
    this.linesVisible  = plot.option('LinesVisible'); // TODO
    this.dotsVisible   = plot.option('DotsVisible' ); // TODO
    if(!this.linesVisible && !this.dotsVisible){
        this.linesVisible = true;
        plot.option.specify({'LinesVisible': true});
    }
    
    this.dotShape = plot.option('Shape');
    
    if(!this.offsetPaddings){
        this.offsetPaddings = new pvc.Sides(0.01);
    }
})
.add({
    
    pvLine: null,
    pvDot: null,
    pvLabel: null,
    pvScatterPanel: null, 
    
    dotShape: "circle",
    
    // Ratio of the biggest bubble diameter to 
    // the length of plot area dimension according to option 'sizeAxisRatioTo'
    sizeAxisRatio: 1/5,
    
    sizeAxisRatioTo: 'minWidthHeight', // 'height', 'width', 
    
    autoPaddingByDotSize: true,
    
    // Override default mappings
    _v1DimRoleName: {
        //'series':   'series',
        'category': 'x',
        'value':    'y'
    },
    
    _creating: function(){
        // Register BULLET legend prototype marks
        var groupScene = this.defaultVisibleBulletGroupScene();
        if(groupScene && !groupScene.hasRenderer()){
            var colorAxis = groupScene.colorAxis;
            var drawMarker = def.nullyTo(colorAxis.option('LegendDrawMarker', true), this.dotsVisible);
            var drawRule   = def.nullyTo(colorAxis.option('LegendDrawLine',   true), this.linesVisible);
            if(drawMarker || drawRule){
                var keyArgs = {};
                if((keyArgs.drawMarker = drawMarker)){
                    keyArgs.markerShape = 
                        colorAxis.option('LegendShape', true) || 
                        'circle'; // Dot's default shape
                    
                    keyArgs.markerPvProto = new pv.Dot()
                            .lineWidth(1.5, pvc.extensionTag) // act as if it were a user extension
                            .shapeSize(12, pvc.extensionTag); // idem
                    
                    this.extend(keyArgs.markerPvProto, 'dot', {constOnly: true});
                }
                
                if((keyArgs.drawRule = drawRule)){
                    keyArgs.rulePvProto = new pv.Line()
                            .lineWidth(1.5, pvc.extensionTag);
                    
                    this.extend(keyArgs.rulePvProto, 'line', {constOnly: true});
                }
                
                groupScene.renderer(
                    new pvc.visual.legend.BulletItemDefaultRenderer(keyArgs));
            }
        }
    },
    
    _getRootScene: function(){
        var rootScene = this._rootScene;
        if(!rootScene){
            var hasColorRole = this.chart._colorRole.isBound();
            
            var sizeAxis = this.axes.size;
            var hasSizeRole = sizeAxis && sizeAxis.isBound() && !sizeAxis.scale.isNull;
            
            // --------------
            
            this._rootScene = 
            rootScene = this._buildScene(hasColorRole, hasSizeRole);
        }
        
        return rootScene;
    },
    
    /*
    * @override
    */
    _calcLayout: function(layoutInfo){
        var rootScene = this._getRootScene();
        
        /* Determine Dot Size Scale */
        if(rootScene.hasSizeRole){
            var areaRange = this._calcDotAreaRange(layoutInfo);
            
            this.sizeScale = this.chart.axes.size
                .setScaleRange(areaRange)
                .scale;
        }
        
        /* Adjust axis offset to avoid dots getting off the content area */
        this._calcAxesPadding(layoutInfo, rootScene);
    },
  
    _getDotDiameterRefLength: function(layoutInfo){
        // Use the border box to always have the same size for != axis offsets (paddings)
       
        var clientSize = layoutInfo.clientSize;
        var paddings   = layoutInfo.paddings;
       
        switch(this.sizeAxisRatioTo){
            case 'minWidthHeight': 
                return Math.min(
                        clientSize.width  + paddings.width, 
                        clientSize.height + paddings.height);
           
            case 'width':  return clientSize.width  + paddings.width ;
            case 'height': return clientSize.height + paddings.height;
        }
       
        if(pvc.debug >= 2){
            this._log(
                def.format(
                    "Invalid option 'sizeAxisRatioTo' value. Assuming 'minWidthHeight'.", 
                    [this.sizeAxisRatioTo]));
        }
       
        this.sizeRatioTo = 'minWidthHeight';
       
        return this._getDotDiameterRefLength(layoutInfo);
    },
   
    _calcDotRadiusRange: function(layoutInfo){
        var refLength = this._getDotDiameterRefLength(layoutInfo);
       
        // Diameter is 1/5 of ref length
        var max = (this.sizeAxisRatio / 2) * refLength;
       
        // Minimum SIZE (not radius) is 12
        var min = Math.sqrt(12); 
       
        return {min: min, max: max};
    },
   
    _calcDotAreaRange: function(layoutInfo){
       
        var radiusRange = this._calcDotRadiusRange(layoutInfo);
       
        // Diamond Adjustment
        if(this.dotShape === 'diamond'){
            // Protovis draws diamonds inscribed on
            // a square with half-side radius*Math.SQRT2
            // (so that diamonds just look like a rotated square)
            // For the height/width of the diamondnot to exceed the cell size
            // we compensate that factor here.
            radiusRange.max /= Math.SQRT2;
            radiusRange.min /= Math.SQRT2;
        }
      
        var maxArea  = radiusRange.max * radiusRange.max,
            minArea  = radiusRange.min * radiusRange.min,
            areaSpan = maxArea - minArea;
      
        if(areaSpan <= 1){
            // Very little space
            // Rescue Mode - show *something*
            maxArea  = Math.max(maxArea, 2);
            minArea  = 1;
            areaSpan = maxArea - minArea;
          
            radiusRange = {
                min: Math.sqrt(minArea),
                max: Math.sqrt(maxArea)
            };
          
            if(pvc.debug >= 3){
                this._log("Using rescue mode dot area calculation due to insufficient space.");
            }
        }
      
        return {
            min:  minArea,
            max:  maxArea,
            span: areaSpan
        };
    },
   
    _calcAxesPadding: function(layoutInfo, rootScene){
        // If we were not to take axes rounding padding effect
        // into account, it could be as simple as:
        // var offsetRadius = radiusRange.max + 6;
        // requestPaddings = new pvc.Sides(offsetRadius);
       
        var requestPaddings;
       
        if(!this.autoPaddingByDotSize){
            requestPaddings = this._calcRequestPaddings(layoutInfo);
        } else {
            var chart = this.chart;
            var axes  = chart.axes;
            var clientSize = layoutInfo.clientSize;
            var paddings   = layoutInfo.paddings;
           
            requestPaddings = {};
           
            /* The Worst case implementation would be like:
             *   Use more padding than is required in many cases,
             *   but ensures that no dot ever leaves the "stage".
             * 
             *   Half a circle must fit in the client area
             *   at any edge of the effective plot area 
             *   (the client area minus axis offsets).
             */
           
            // X and Y axis orientations
            axes.x.setScaleRange(clientSize.width );
            axes.y.setScaleRange(clientSize.height);
           
            // X and Y visual roles
            var sceneXScale = chart.axes.base.sceneScale({sceneVarName:  'x'});
            var sceneYScale = chart.axes.ortho.sceneScale({sceneVarName: 'y'});
           
            var xLength = chart.axes.base.scale.max;
            var yLength = chart.axes.ortho.scale.max;
           
            var hasSizeRole = rootScene.hasSizeRole;
            var sizeScale = this.sizeScale;
            if(!hasSizeRole){
                // Use the dot default size
                var defaultSize = def.number.as(this._getExtension('dot', 'shapeRadius'), 0);
                if(defaultSize <= 0){
                    defaultSize = def.number.as(this._getExtension('dot', 'shapeSize'), 0);
                    if(defaultSize <= 0){
                        defaultSize = 12;
                    }
                } else {
                    // Radius -> Size
                    defaultSize = defaultSize * defaultSize;
                }
               
                sizeScale = def.fun.constant(defaultSize);
            }
           
            // TODO: these padding requests do not take the resulting new scale into account
            // and as such do not work exactly...
            //var xMinPct = xScale(xDomain.min) /  clientSize.width;
            //var overflowLeft = (offsetRadius - xMinPct * (paddings.left + clientSize.width)) / (1 - xMinPct);
           
            requestPaddings = {};
           
            // Resolve (not of PercentValue so cannot use pvc.Sides#resolve)
            var op;
            if(this.offsetPaddings){
                op = {};
                pvc.Sides.names.forEach(function(side){
                    var len_a = pvc.BasePanel.orthogonalLength[side];
                    op[side] = (this.offsetPaddings[side] || 0) * (clientSize[len_a] + paddings[len_a]);
                }, this);
            }
            
            // TODO: this seams to not be working on negative x, y values
            var setSide = function(side, padding){
                if(op){
                    padding += (op[side] || 0);
                }
               
                if(padding < 0){
                    padding = 0;
                }
               
                var value = requestPaddings[side];
                if(value == null || padding > value){
                    requestPaddings[side] = padding;
                }
            };
           
            var processScene = function(scene){
                var x = sceneXScale(scene);
                var y = sceneYScale(scene);
                var r = Math.sqrt(sizeScale(hasSizeRole ? scene.vars.size.value : 0));
               
                // How much overflow on each side?
                setSide('left',   r - x);
                setSide('bottom', r - y);
                setSide('right',  x + r - xLength );
                setSide('top',    y + r - yLength);
            };
           
            rootScene
                .children()
                .selectMany(function(seriesScene){ return seriesScene.childNodes; })
                .each(processScene);
        }
       
        layoutInfo.requestPaddings = requestPaddings;
    },
   
    /**
     * @override
     */
    _createCore: function(layoutInfo){
        this.base();
         
        var myself = this,
            chart = this.chart,
            options = chart.options;

        // ------------------
        // DATA
        var rootScene = this._getRootScene(),
            data      = rootScene.group,
            // data._leafs.length is currently an approximation of datum count due to datum filtering in the scenes only...
            isDense   = (this.width <= 0) || (data._leafs.length / this.width > 0.5); //  > 100 pts / 200 pxs 
        
        this._finalizeScene(rootScene);

        // Disable selection?
        if(isDense && (options.selectable || options.hoverable)) {
            options.selectable = false;
            options.hoverable  = false;
            if(pvc.debug >= 3) {
                this._log("Warning: Disabling selection and hovering because the chart is to \"dense\".");
            }
        }
       
        // ---------------
        // BUILD
        
        // this.pvPanel.strokeStyle('red');
        
        this.pvPanel.zOrder(1); // Above axes
        
        this.pvScatterPanel = new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: 'panel'
            })
            .lock('data', rootScene.childNodes)
            .pvMark
            ;
        
        var wrapper;
        if(this.compatVersion() <= 1){
            wrapper = function(v1f){
                return function(dotScene){
                    var d = {
                            category: dotScene.vars.x.rawValue,
                            value:    dotScene.vars.y.rawValue
                        };
                    
                    // Compensate for the effect of intermediate scenes on mark's index
                    var pseudo = Object.create(this);
                    pseudo.index = dotScene.dataIndex;
                    return v1f.call(pseudo, d);
                };
            };
        }
        
        // -- LINE --
        var line = new pvc.visual.Line(this, this.pvScatterPanel, {
                extensionId: 'line',
                wrapper:     wrapper,
                noTooltip:   false,
                noHover:     true // TODO: SIGN check if not broken
            })
            /* Data */
            .lock('data', function(seriesScene){ return seriesScene.childNodes; }) // TODO    
            
            .lock('visible', this.linesVisible)
            
            /* Position & size */
            .override('x', function(){ return this.scene.basePosition;  })
            .override('y', function(){ return this.scene.orthoPosition; })
            ;
        
        this.pvLine = line.pvMark;
            
        // -- DOT --
        var dot = new pvc.visual.Dot(this, this.pvLine, {
                extensionId: 'dot',
                wrapper:     wrapper,
                activeSeriesAware: this.linesVisible
            })
            .intercept('visible', function(){
                return !this.scene.isIntermediate && this.delegateExtension(true);
            })
            .lock('shape', this.dotShape)
            .override('x',  function(){ return this.scene.basePosition;  })
            .override('y',  function(){ return this.scene.orthoPosition; })
            .override('color', function(type){
                /* 
                 * Handle dotsVisible
                 * -----------------
                 * Despite !dotsVisible,
                 * show a dot anyway when:
                 * 1) it is active, or
                 * 2) it is single  (the only dot in the dataset)
                 */
                if(!myself.dotsVisible){
                    var visible = this.scene.isActive ||
                                  this.scene.isSingle;
                    if(!visible) {
                        return pvc.invisibleFill;
                    }
                }
                
                // Follow normal logic
                return this.base(type);
            })
            ;
            
        this.pvDot = dot.pvMark;
        
        this.pvDot.rubberBandSelectionMode = 'center';
        
        // -- COLOR --
        dot.override('defaultColor', function(type){
            var color = this.base(type);
            
            if(color && type === 'stroke'){
                color = color.darker();
            }
            
            // When no lines are shown, dots are shown with transparency,
            // which helps in distinguishing overlapped dots.
            // With lines shown, it would look strange.
            // ANALYZER requirements, so until there's no way to configure it...
            // TODO: this probably can now be done with ColorTransform
//          if(!myself.linesVisible){
//              color = color.alpha(color.opacity * 0.85);
//          }
            
            return color;
        });
        
        dot.override('interactiveColor', function(color, type){
            if(type === 'stroke' && this.scene.isActive) {
                // Don't make border brighter on active
                return color;
            }
            
            return this.base(color, type);
        });
        
        // -- DOT SIZE --
        if(!rootScene.hasSizeRole){
            dot.override('baseSize', function(){
                /* When not showing dots, 
                 * but a datum is alone and 
                 * wouldn't be visible using lines,  
                 * show the dot anyway, 
                 * with a size = to the line's width^2
                 */
                if(!myself.dotsVisible) {
                    if(this.scene.isSingle) {
                        // Obtain the line Width of the "sibling" line
                        var lineWidth = Math.max(myself.pvLine.scene[this.pvMark.index].lineWidth, 0.2) / 2;
                        return lineWidth * lineWidth;
                    }
                }
                
                return this.base();
            });
        } else {
            var sizeAxis = chart.axes.size;
            if (sizeAxis.scaleUsesAbs()) {
                dot
                .override('strokeColor', function () {
                    return this.scene.vars.size.value < 0 ? "#000000" : this.base();
                })
                .optional('lineCap', 'round') // only used by strokeDashArray
                .optionalMark('strokeDasharray', function (scene){
                    return scene.vars.size.value < 0 ? 'dot' : null; // .  .  .
                })
                .optionalMark('lineWidth', function (scene){
                    return scene.vars.size.value < 0 ? 1.8 : 1.5;
                })
                ;
            }
            
            var sizeScale  = this.sizeScale;
            
            /* Ignore any extension */
            dot .override('baseSize', function(){
                    return sizeScale(this.scene.vars.size.value);
                })
                .override('interactiveSize', function(size){
                    if(this.scene.isActive){
                        var radius = Math.sqrt(size) * 1.1;
                        return radius * radius;
                    }
                    
                    return size;
                })
                ;
            
            // Default is to hide overflow dots, 
            // for a case where the provided offset, or calculated one is not enough 
            // (sizeAxisRatioTo='width' or 'height' don't guarantee no overflow)
            // Padding area is used by the bubbles.
            this.pvPanel.borderPanel.overflow("hidden");
        }
        
        // -- LABEL --
        if(this.valuesVisible){
            var extensionIds = ['label'];
            if(this.compatVersion() <= 1){
                extensionIds.push('lineLabel');
            }
            
            this.pvLabel = new pvc.visual.Label(
                this, 
                this.pvDot.anchor(this.valuesAnchor), 
                {
                    extensionId: extensionIds,
                    wrapper:     wrapper
                })
                .pvMark
                .font(this.valuesFont) // default
                .text(function(scene){ 
                    return def.string.join(",", scene.vars.x.label, scene.vars.y.label);
                })
                ;
        }
    },
    
    /**
     * Renders this.pvScatterPanel - the parent of the marks that are affected by interaction changes.
     * @override
     */
    renderInteractive: function(){
        this.pvScatterPanel.render();
    },

    /**
     * Returns an array of marks whose instances are associated to a datum or group, or null.
     * @override
     */
    _getSelectableMarks: function(){
        var marks = [];
        
        marks.push(this.pvDot);
        
        if(this.linesVisible){
            marks.push(this.pvLine);
        }
        
        return marks;
    },
    
    _finalizeScene: function(rootScene){
        var chart = this.chart,
            sceneBaseScale  = chart.axes.base.sceneScale({sceneVarName: 'x'}),
            sceneOrthoScale = chart.axes.ortho.sceneScale({sceneVarName: 'y'});
        
        rootScene
            .children()
            .selectMany(function(seriesScene){ return seriesScene.childNodes; })
            .each(function(leafScene){
                leafScene.basePosition  = sceneBaseScale(leafScene);
                leafScene.orthoPosition = sceneOrthoScale(leafScene);
            }, this);
    
        return rootScene;
    },
    
    _buildScene: function(hasColorRole, hasSizeRole){
        var data = this._getVisibleData();
        var rootScene = new pvc.visual.Scene(null, {panel: this, group: data});
        rootScene.hasColorRole = hasColorRole;
        rootScene.hasSizeRole  = hasSizeRole;
        
        var chart = this.chart;
        var colorVarHelper = new pvc.visual.ColorVarHelper(chart, chart._colorRole);
        var xDimType = chart._xRole.firstDimensionType();
        var yDimType = chart._yRole.firstDimensionType();
        
        var getSizeRoleValue;
        if(chart._sizeDim){
            var sizeDimName = chart._sizeDim.name;
            
            getSizeRoleValue = function(scene){
                return scene.atoms[sizeDimName].value;
            };
        }
         
        // --------------
        
        /** 
         * Create starting scene tree 
         */
        data.children()
            .each(createSeriesScene, this);
        
        /** 
         * Update the scene tree to include intermediate leaf-scenes,
         * to add in the creation of lines and areas. 
         */
        rootScene
            .children()
            .each(completeSeriesScenes, this);
        
        return rootScene;
        
        function createSeriesScene(seriesGroup){
            /* Create series scene */
            var seriesScene = new pvc.visual.Scene(rootScene, {group: seriesGroup});
            
            seriesScene.vars.series = new pvc.visual.ValueLabelVar(
                                seriesGroup.value,
                                seriesGroup.label,
                                seriesGroup.rawValue);
            
            colorVarHelper.onNewScene(seriesScene, /* isLeaf */ false);
            
            seriesGroup.datums().each(function(datum, dataIndex){
                var xAtom = datum.atoms[chart._xDim.name];
                if(xAtom.value == null){
                    return;
                }
                
                var yAtom = datum.atoms[chart._yDim.name];
                if(yAtom.value == null){
                    return;
                }
                
                /* Create leaf scene */
                var scene = new pvc.visual.Scene(seriesScene, {datum: datum});
                scene.dataIndex = dataIndex;
                scene.vars.x = Object.create(xAtom);
                scene.vars.y = Object.create(yAtom);
                
                if(getSizeRoleValue){
                    var sizeValue = getSizeRoleValue(scene);
                    scene.vars.size = new pvc.visual.ValueLabelVar(
                                            sizeValue,
                                            chart._sizeDim.format(sizeValue),
                                            sizeValue);
                }
                
                colorVarHelper.onNewScene(scene, /* isLeaf */ true);
                
                scene.isIntermediate = false;
            });
        }
        
        function completeSeriesScenes(seriesScene) {
            var seriesScenes = seriesScene.childNodes, 
                fromScene;
            
            /* As intermediate nodes are added, 
             * seriesScene.childNodes array is changed.
             * 
             * The var 'toChildIndex' takes inserts into account;
             * its value is always the index of 'toScene' in 
             * seriesScene.childNodes.
             */
            for(var c = 0, /* category index */
                    toChildIndex = 0,
                    pointCount = seriesScenes.length ; c < pointCount ; c++, toChildIndex++) {
                
                /* Complete toScene */
                var toScene = seriesScenes[toChildIndex];
                toScene.isSingle = !fromScene && !toScene.nextSibling;  // Look ahead
                
                /* Possibly create intermediate scene 
                 * (between fromScene and toScene)
                 */
                if(fromScene) {
                    var interScene = createIntermediateScene(
                            seriesScene,
                            fromScene, 
                            toScene,
                            toChildIndex);
                    
                    if(interScene){
                        toChildIndex++;
                    }
                }
                
                // --------
                
                fromScene = toScene;
            }
        }
        
        function createIntermediateScene(
                     seriesScene, 
                     fromScene, 
                     toScene, 
                     toChildIndex){
            
            /* Code for single, continuous and date/numeric dimensions
             * Calls corresponding dimension's cast to ensure we have a date object,
             * when that's the dimension value type.
             */
            var interYValue = yDimType.cast.call(null, ((+toScene.vars.y.value) + (+fromScene.vars.y.value)) / 2);
            var interXValue = xDimType.cast.call(null, ((+toScene.vars.x.value) + (+fromScene.vars.x.value)) / 2);
            
            //----------------
            
            var interScene = new pvc.visual.Scene(seriesScene, {
                    /* insert immediately before toScene */
                    index: toChildIndex,
                    datum: toScene.datum
                });
            
            interScene.dataIndex = toScene.dataIndex;
            
            interScene.vars.x = new pvc.visual.ValueLabelVar(
                                    interXValue,
                                    chart._xDim.format(interXValue),
                                    interXValue);
            
            interScene.vars.y = new pvc.visual.ValueLabelVar(
                                    interYValue,
                                    chart._yDim.format(interYValue),
                                    interYValue);
            
            if(getSizeRoleValue){
                interScene.vars.size = toScene.vars.size;
            }
            
            colorVarHelper.onNewScene(interScene, /* isLeaf */ true);
            
            interScene.ownerScene = toScene;
            interScene.isIntermediate = true;
            interScene.isSingle = false;
            
            return interScene;
        }
    }
});

/**
 * MetricPointAbstract is the base class of metric dot and line.
 */
def
.type('pvc.MetricPointAbstract', pvc.MetricXYAbstract)
.init(function(options){

    this.base(options);

    var parent = this.parent;
    if(parent) {
        this._colorRole = parent._colorRole;
        this._sizeRole  = parent._sizeRole;
    }
})
.add({
    
    _initPlotsCore: function(){
        var options = this.options;
        
        var pointPlot = this._createPointPlot();
        
        var trend = pointPlot.option('Trend');
        if(trend){
            // Trend Plot
            new pvc.visual.MetricPointPlot(this, {
                name: 'trend',
                fixed: {
                    DataPart: 'trend',
                    TrendType: 'none',
                    NullInterpolatioMode: 'none',
                    ColorRole: 'series', // one trend per series
                    SizeRole:  null,
                    SizeAxis:  null,
                    OrthoAxis:    1
                },
                defaults: {
                    ColorAxis:    2,
                    LinesVisible: true,
                    DotsVisible:  false
                }
            });
        }
    },
    
    //_createPointPlot: function(){},
    
    /* Required because of trends */
    _hasDataPartRole: function(){
        return true;
    },
    
    _getColorRoleSpec: function(){
        return {
            //isMeasure: true, // TODO: not being set as measure when continuous...
            defaultSourceRole: 'series',
            defaultDimension:  'color*',
            dimensionDefaults: {
                valueType: Number
            }
        };
    },
    
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){
        
        this.base();
        
        this._sizeRole = this._addVisualRole('size', {
                isMeasure: true,
                requireSingleDimension: true,
                requireIsDiscrete: false,
                defaultDimension: 'size',
                dimensionDefaults: {
                    valueType: Number
                }
            });
    },
    
    _getTranslationClass: function(translOptions){
        return def
            .type(this.base(translOptions))
            .add(pvc.data.MetricPointChartTranslationOper);
    },
    
    _initData: function(keyArgs){
        
        this.base(keyArgs);

        // Cached
        var sizeGrouping = this._sizeRole.grouping;
        if(sizeGrouping){
            this._sizeDim = this.data.dimensions(sizeGrouping.firstDimensionName());
        }
    },
    
    _collectPlotAxesDataCells: function(plot, dataCellsByAxisTypeThenIndex){
        
        this.base(plot, dataCellsByAxisTypeThenIndex);
        
        /* NOTE: Cartesian axes are created even when hasMultiRole && !parent
         * because it is needed to read axis options in the root chart.
         * Also binding occurs to be able to know its scale type. 
         * Yet, their scales are not setup at the root level.
         */
        
        /* Configure Base Axis Data Cell */
        if(plot.type === 'scatter' && plot.option('DotsVisible')){
            
            var sizeRoleName = plot.option('SizeRole');
            if(sizeRoleName){
                var sizeRole = this.visualRoles(sizeRoleName);
                if(sizeRole.isBound()){
                    var sizeDataCellsByAxisIndex = 
                        def
                        .array
                        .lazy(dataCellsByAxisTypeThenIndex, 'size');
                    
                    def
                    .array
                    .lazy(sizeDataCellsByAxisIndex, plot.option('SizeAxis') - 1)
                    .push({
                        plot:          plot,
                        role:          this.visualRoles(plot.option('SizeRole')),
                        dataPartValue: plot.option('DataPart')
                    });
                }
            }
        }
    },
    
    _setAxesScales: function(hasMultiRole){
        
        this.base(hasMultiRole);
        
        if(!hasMultiRole || this.parent){
            
            var sizeAxis = this.axes.size;
            if(sizeAxis && sizeAxis.isBound()){
                this._createAxisScale(sizeAxis);
            }
        }
    },
    
     /**
      * @override 
      */
    _createPlotPanels: function(parentPanel, baseOptions){
        // TODO: integrate these options in the MetricPointPlot or in the SizeAxis?
        var options = this.options;
        var panelOptions = def.set(
            Object.create(baseOptions),
            'sizeAxisRatio',        options.sizeAxisRatio,
            'sizeAxisRatioTo',      options.sizeAxisRatioTo,
            'autoPaddingByDotSize', options.autoPaddingByDotSize);
        
        var scatterPlot = this.plots.scatter;
            this.scatterChartPanel = // V1 property 
            new pvc.MetricPointPanel(this, parentPanel, scatterPlot, panelOptions);

        var trendPlot = this.plots.trend;
        if(trendPlot){
            new pvc.MetricPointPanel(
                this, 
                parentPanel, 
                trendPlot, 
                Object.create(panelOptions));
        }
    },
    
    defaults: {
        axisOriginIsZero: false,
        
        tooltipOffset: 10
        
        /* Continuous Color Role */
        // TODO:
        //colorScaleType: "linear", // "discrete", "normal" (distribution) or "linear"
        //colors: ['red', 'yellow','green'],
        //colorDomain:  undefined,
        //colorMin:  undefined, //"white",
        //colorMax:  undefined, //"darkgreen",
        //colorNull: "#efc5ad"   // white with a shade of orange
         
        /* Size Role */
//      sizeAxisUseAbs:   true,
//      sizeAxisFixedMin: undefined,
//      sizeAxisFixedMax: undefined,
//      sizeAxisOriginIsZero: false,

//      sizeAxisRatio:    undefined,
//      sizeAxisRatioTo:  undefined,
//      autoPaddingByDotSize: undefined
    }
});

/**
 * Metric Dot Chart
 */
def
.type('pvc.MetricDotChart', pvc.MetricPointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.MetricPointPlot(this, {
            fixed: {DotsVisible: true}
        });
    }
});


/**
 * Metric Line Chart
 */
def
.type('pvc.MetricLineChart', pvc.MetricPointAbstract)
.add({
    _createPointPlot: function(){
        return new pvc.visual.MetricPointPlot(this, {
            fixed: {LinesVisible: true}
        });
    }
});
/**
 * Bullet chart generation
 */
def
.type('pvc.BulletChart', pvc.BaseChart)
.init(function(options){
    
    options = options || {};

    // Add range and marker dimension group defaults
    // This only helps in default bindings...
    var dimGroups = options.dimensionGroups || (options.dimensionGroups = {});
    var rangeDimGroup = dimGroups.range  || (dimGroups.range  = {});
    if(rangeDimGroup.valueType === undefined){
        rangeDimGroup.valueType = Number;
    }

    var markerDimGroup = dimGroups.marker || (dimGroups.marker = {});
    if(markerDimGroup.valueType === undefined){
        markerDimGroup.valueType = Number;
    }

    this.base(options);
})
.add({

    bulletChartPanel : null,
    allowNoData: true,

    /**
     * @override 
     */
    _processOptionsCore: function(options){
        
        this.base(options);
        
        options.legend     = false;
        options.selectable = false; // not supported yet
    },
    
    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){

        this.base();

        this._addVisualRole('title',    { defaultDimension: 'title*'    });
        this._addVisualRole('subTitle', { defaultDimension: 'subTitle*' });
        this._addVisualRole('value', {
                //isRequired: true, // due to the no data mode
                isMeasure:  true,
                requireIsDiscrete: false,
                valueType: Number,
                defaultDimension: 'value*'
            });
        this._addVisualRole('marker', {
                isMeasure:  true,
                requireIsDiscrete: false,
                valueType: Number,
                defaultDimension: 'marker*'
            });
        this._addVisualRole('range', {
                isMeasure:  true,
                requireIsDiscrete: false,
                valueType: Number,
                defaultDimension: 'range*'
            });
    },

    _createTranslation: function(translOptions){
        
        var translation = this.base(translOptions),
            /*
             * By now the translation has already been initialized
             * and its virtualItemSize is determined.
             */
            size = translation.virtualItemSize()
            ;

        /* Configure the translation with default dimensions.
         *  1       Value
         *  2       Title | Value
         *  3       Title | Value | Marker
         *  >= 4    Title | Subtitle | Value | Marker | Ranges
         */
        // TODO: respect user reader definitions (names and indexes)
        // TODO: create a translator class for this, like with the boxplot?
        if(size){
            switch(size){
                case 1:
                    translation.defReader({names: 'value'});
                    break;

                case 2:
                    translation.defReader({names: ['title', 'value']});
                    break;

                case 3:
                    translation.defReader({names: ['title', 'value', 'marker']});
                    break;

                default:
                    translation.defReader({names: ['title', 'subTitle', 'value', 'marker']});
                    if(size > 4){
                        // 4, 5, 6, ...
                        translation.defReader({names: 'range', indexes: pv.range(4, size)});
                    }
                    break;
            }
        }

        return translation;
    },
    
    _initPlotsCore: function(hasMultiRole){
        new pvc.visual.BulletPlot(this);
    },
    
    _preRenderContent: function(contentOptions){
        var bulletPlot = this.plots.bullet;
        this.bulletChartPanel = new pvc.BulletChartPanel(
            this, 
            this.basePanel, 
            bulletPlot, 
            def.create(contentOptions, {
                tooltipEnabled:  this._tooltipEnabled
            }));
    },
  
    defaults: {
        compatVersion: 1,
      
        orientation: 'horizontal',
        
        bulletSize:     30,  // Bullet size
        bulletSpacing:  50,  // Spacing between bullets
        bulletMargin:  100,  // Left margin

        // Defaults
//      bulletMarkers:  null,     // Array of markers to appear
//      bulletMeasures: null,     // Array of measures
//      bulletRanges:   null,     // Ranges
        bulletTitle:    "Title",  // Title
        bulletSubtitle: "",       // Subtitle
        bulletTitlePosition: "left", // Position of bullet title relative to bullet

//      axisDoubleClickAction: null,
        tooltipFormat: function(s, c, v) {
            return this.chart.options.valueFormat(v);
        },
        
        crosstabMode: false,
        seriesInRows: false
    }
});

/*
 * Bullet chart panel. Generates a bar chart. Specific options are:
 * <i>orientation</i> - horizontal or vertical. Default: vertical
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>bulletsPanel_</i> - for the bullets panel
 * <i>bulletPanel_</i> - for the bullets pv.Layout.Bullet
 * <i>bulletRange_</i> - for the bullet range
 * <i>bulletMeasure_</i> - for the bullet measure
 * <i>bulletMarker_</i> - for the marker
 * <i>bulletRule_</i> - for the axis rule
 * <i>bulletRuleLabel_</i> - for the axis rule label
 * <i>bulletTitle_</i> - for the bullet title
 * <i>bulletSubtitle_</i> - for the main bar label
 */


def
.type('pvc.BulletChartPanel', pvc.PlotPanel)
.add({
    pvBullets: null,
    pvBullet: null,
    data: null,
    onSelectionChange: null,
    
    /**
     * @override
     */
    _createCore: function(layoutInfo) {
        var chart  = this.chart,
            options = chart.options,
            data = this.buildData();
    
        var anchor = options.orientation=="horizontal"?"left":"bottom";
        var size, angle, align, titleLeftOffset, titleTopOffset, ruleAnchor, leftPos, topPos, titleSpace;
    
        if(options.orientation=="horizontal"){
            size = layoutInfo.clientSize.width - this.chart.options.bulletMargin - 20;
            angle=0;
            switch (options.bulletTitlePosition) {
            case 'top':
                leftPos = this.chart.options.bulletMargin;
                titleLeftOffset = 0;
                align = 'left';
                titleTopOffset = -12;
                titleSpace = parseInt(options.titleSize/2, 10);
                break;
            case 'bottom':
                leftPos = this.chart.options.bulletMargin;
                titleLeftOffset = 0;
                align = 'left';
                titleTopOffset = options.bulletSize + 32;
                titleSpace = 0;
                break;
            case 'right':
                leftPos = 5;
                titleLeftOffset = size + 5;
                align = 'left';
                titleTopOffset = parseInt(options.bulletSize/2, 10);
                titleSpace = 0;
                break;
            case 'left':
                // The next comment is for JSHint
                /* falls through */
            default:
                leftPos = this.chart.options.bulletMargin;
                titleLeftOffset = 0;
                titleTopOffset = parseInt(options.bulletSize/2, 10);
                align = 'right';
                titleSpace = 0;
            }
            ruleAnchor = "bottom";
            topPos = function(){
                // TODO: 10
                return (this.index * (options.bulletSize + options.bulletSpacing)) + titleSpace;
            };
        } else {
            size = layoutInfo.clientSize.height - this.chart.options.bulletMargin - 20;
            switch (options.bulletTitlePosition) {
                case 'top':
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = 'left';
                    titleTopOffset = -20;
                    angle = 0;
                    topPos = undefined;
                    break;
                case 'bottom':
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = 0;
                    align = 'left';
                    titleTopOffset = size + 20;
                    angle = 0;
                    topPos = 20;
                    break;
                case 'right':
                    leftPos = 5;
                    titleLeftOffset = this.chart.options.bulletSize + 40;
                    align = 'left';
                    titleTopOffset = size;
                    angle = -Math.PI/2;
                    topPos = undefined;
                    break;
                case 'left':
                    // The next comment is for JSHint
                    /* falls through */
                default:
                    leftPos = this.chart.options.bulletMargin;
                    titleLeftOffset = -12;
                    titleTopOffset = this.height - this.chart.options.bulletMargin - 20;
                    align = 'left';
                    angle = -Math.PI/2;
                    topPos = undefined;
            }
            ruleAnchor = "right";
            leftPos = function(){
                return options.bulletMargin + this.index * (options.bulletSize + options.bulletSpacing);
            };

        }

        this.pvBullets = this.pvPanel.add(pv.Panel)
            .data(data)
            [pvc.BasePanel.orthogonalLength[anchor]](size)
            [pvc.BasePanel.parallelLength[anchor]](this.chart.options.bulletSize)
            .margin(20)
            .left(leftPos)
            .top(topPos);
        

        this.pvBullet = this.pvBullets.add(pv.Layout.Bullet)
            .orient  (anchor)
            .ranges  (function(d){ return d.ranges;   })
            .measures(function(d){ return d.measures; })
            .markers (function(d){ return d.markers;  });
    
        if (options.clickable && this.clickAction){
            var me = this;
      
            this.pvBullet
                .cursor("pointer")
                .event("click",function(d){
                    var s = d.title;
                    var c = d.subtitle;
                    var ev = pv.event;
                    return me.clickAction(s,c, d.measures, ev);
                });
        }
    
        this.pvBulletRange = this.pvBullet.range.add(pv.Bar);
        
        this.pvBulletMeasure = this.pvBullet.measure.add(pv.Bar)
            .text(function(v, d){
                return d.formattedMeasures[this.index];
            });

        this.pvBulletMarker = this.pvBullet.marker.add(pv.Dot)
            .shape("square")
            .fillStyle("white")
            .text(function(v, d){
                return d.formattedMarkers[this.index];
            });

        if(this.tooltipEnabled){
            // Extend default
            // TODO: how to deal with different measures in tooltips depending on mark
      
            //      this._addPropTooltip(this.pvBulletMeasure);
            //      this._addPropTooltip(this.pvBulletMarker);
            var myself = this;
            this.pvBulletMeasure
                .localProperty('tooltip')
                .tooltip(function(v, d){
                    var s = d.title;
                    var c = d.subtitle;
                    return chart.options.tooltipFormat.call(myself,s,c,v);
                })
                ;

            this.pvBulletMarker
                .localProperty('tooltip')
                .tooltip(function(v, d){
                    var s = d.title;
                    var c = d.subtitle;
                    return chart.options.tooltipFormat.call(myself,s,c,v);
                })
                ;
      
            this.pvBulletMeasure.event("mouseover", pv.Behavior.tipsy(this.chart._tooltipOptions));
            this.pvBulletMarker .event("mouseover", pv.Behavior.tipsy(this.chart._tooltipOptions));
        }

        this.pvBulletRule = this.pvBullet.tick.add(pv.Rule);

        this.pvBulletRuleLabel = this.pvBulletRule.anchor(ruleAnchor).add(pv.Label)
            .text(this.pvBullet.x.tickFormat);

        this.pvBulletTitle = this.pvBullet.anchor(anchor).add(pv.Label)
            .font("bold 12px sans-serif")
            .textAngle(angle)
            .left(-10)
            .textAlign(align)
            .textBaseline("bottom")
            .left(titleLeftOffset)
            .top(titleTopOffset)
            .text(function(d){
                return d.formattedTitle;
            });

        this.pvBulletSubtitle = this.pvBullet.anchor(anchor).add(pv.Label)
            .textStyle("#666")
            .textAngle(angle)
            .textAlign(align)
            .textBaseline("top")
            .left(titleLeftOffset)
            .top(titleTopOffset)
            .text(function(d){
                return d.formattedSubtitle;
            });

        var doubleClickAction = (typeof(options.axisDoubleClickAction) == 'function') ?
                    function(d, e) {
                        //ignoreClicks = 2;
                        options.axisDoubleClickAction(d, e);
    
                    } : null;
    
        if (options.clickable && doubleClickAction) {
            this.pvBulletTitle
                .cursor("pointer")
                .events('all')  //labels don't have events by default
                .event("dblclick", function(d){
                    doubleClickAction(d, arguments[arguments.length-1]);
                });

            this.pvBulletSubtitle
                .cursor("pointer")
                .events('all')  //labels don't have events by default
                .event("dblclick", function(d){
                    doubleClickAction(d, arguments[arguments.length-1]);
                });

        }
    },
   
    applyExtensions: function(){
      
        this.base();
      
        this.extend(this.pvBullets,"bulletsPanel");
        this.extend(this.pvBullet,"bulletPanel");
        this.extend(this.pvBulletRange,"bulletRange");
        this.extend(this.pvBulletMeasure,"bulletMeasure");
        this.extend(this.pvBulletMarker,"bulletMarker");
        this.extend(this.pvBulletRule,"bulletRule");
        this.extend(this.pvBulletRuleLabel,"bulletRuleLabel");
        this.extend(this.pvBulletTitle,"bulletTitle");
        this.extend(this.pvBulletSubtitle,"bulletSubtitle");
    },
    
    _getExtensionId: function(){
        // content coincides, visually in this chart type
        return [{abs: 'content'}].concat(this.base());
    },
    
    /*
     * Data array to back up bullet charts.
     */
    buildData: function(){
        var data,
            chart = this.chart,
            options = chart.options,
            
            titleRole = chart.visualRoles('title'),
            titleGrouping = titleRole.grouping,
            
            subTitleRole = chart.visualRoles('subTitle'),
            subTitleGrouping = subTitleRole.grouping,
            
            valueRole = chart.visualRoles('value'),
            valueGrouping = valueRole.grouping,
            
            markerRole = chart.visualRoles('marker'),
            markerGrouping = markerRole.grouping,
            
            rangeRole = chart.visualRoles('range'),
            rangeGrouping = rangeRole.grouping;
        
        var defaultData = {
            title:             options.bulletTitle,
            formattedTitle:    options.bulletTitle,
            
            subtitle:          options.bulletSubtitle,
            formattedSubtitle: options.bulletSubtitle,
            
            ranges:            def.array.to(options.bulletRanges)   || [],
            measures:          def.array.to(options.bulletMeasures) || [],
            markers:           def.array.to(options.bulletMarkers)  || []
        };
        
        def.set(defaultData,
            'formattedRanges',   defaultData.ranges  .map(String),
            'formattedMeasures', defaultData.measures.map(String),
            'formattedMarkers',  defaultData.markers .map(String)
            );
        
        if(!valueGrouping    &&
           !titleGrouping    &&
           !markerGrouping   &&
           !subTitleGrouping &&
           !rangeGrouping){

            data = [defaultData];
       } else {
            data = chart.data.datums().select(function(datum){
                var d = Object.create(defaultData),
                    view;

                if(valueGrouping){
                    view = valueGrouping.view(datum);
                    d.measures = view.values();
                    d.formattedMeasures = view.labels();
                }

                if(titleGrouping){
                    view = titleGrouping.view(datum);
                    d.title = view.value;
                    d.formattedTitle = view.label;
                }

                if(subTitleGrouping){
                    view = subTitleGrouping.view(datum);
                    d.subtitle = view.value;
                    d.formattedSubtitle = view.label;
                }

                if(markerGrouping){
                    view = markerGrouping.view(datum);
                    d.markers = view.values();
                    d.formattedMarkers = view.labels();
                }

                if(rangeGrouping){
                    view = rangeGrouping.view(datum);
                    d.ranges = view.values();
                    d.formattedRanges = view.labels();
                }

                return d;
            }, this)
            .array();
        }
        
        return data;
    }
});

/**
 * Parallel coordinates offer a way to visualize data and make (sub-)selections
 * on this dataset.
 * This code has been based on a protovis example:
 *    http://vis.stanford.edu/protovis/ex/cars.html
 */
def
.type('pvc.ParallelCoordinates', pvc.BaseChart)
.init(function(options){

    // Force the value dimension not to be a number
    options = options || {};
    options.dimensions = options.dimensions || {};
    if(!options.dimensions.value) {
        options.dimensions.value = {valueType: null};
    }
  
    this.base(options);
})
.add({

    parCoordPanel : null,
    
    _preRenderContent: function(contentOptions){
        this.parCoordPanel = new pvc.ParCoordPanel(this, this.basePanel, def.create(contentOptions, {
            topRuleOffset : this.options.topRuleOffset,
            botRuleOffset : this.options.botRuleOffset,
            leftRuleOffset : this.options.leftRuleOffset,
            rightRuleOffset : this.options.rightRuleOffset,
            sortCategorical : this.options.sortCategorical,
            mapAllDimensions : this.options.mapAllDimensions,
            numDigits : this.options.numDigits
        }));
    },
  
    defaults: def.create(pvc.BaseChart.prototype.defaults, {
        compatVersion: 1,
      
        topRuleOffset: 30,
        botRuleOffset: 30,
        leftRuleOffset: 60,
        rightRuleOffset: 60,
        // sort the categorical (non-numerical dimensions)
        sortCategorical: true,
        // map numerical dimension too (uniform (possible non-linear)
        // distribution of the observed values)
        mapAllDimensions: true,
        // number of digits after decimal point.
        numDigits: 0
    })
});

/*
 * ParCoord chart panel. Generates a serie of Parallel Coordinate axis 
 * and allows you too make selections on these parallel coordinates.
 * The selection will be stored in java-script variables and can be
 * used as part of a where-clause in a parameterized SQL statement.
 * Specific options are:
 *   << to be filled in >>

 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 * <i>parCoord_</i> - for the parallel coordinates
 *    << to be completed >>
 */
def
.type('pvc.ParCoordPanel', pvc.BasePanel)
.add({
    anchor: 'fill',
    pvParCoord: null,

    dimensions: null, 
    dimensionDescr: null,

    data: null,

    /*****
     * retrieve the data from database and transform it to maps.
     *    - this.dimensions: all dimensions
     *    - this.dimensionDescr: description of dimensions
     *    - this.data: array with hashmap per data-point
     *****/
    retrieveData: function () {
        var data = this.chart.data;
        var numDigit = this.chart.options.numDigits;

        this.dimensions = data.getVisibleCategories();
        var values = data.getValues();

        var dataRowIndex = data.getVisibleSeriesIndexes();
        var pCoordIndex = data.getVisibleCategoriesIndexes();

        var pCoordKeys = data.getCategories();

        /******
         *  Generate a Coordinate mapping. 
         *  This mapping is required for categorical dimensions and
         *  optional for the numerical dimensions (in 4 steps)
         ********/
        // 1: generate an array of coorMapping-functions
        // BEWARE: Only the first row (index 0) is used to test whether 
        // a dimension is categorical or numerical!
        var pCoordMapping = this.chart.options.mapAllDimensions ?
            pCoordIndex.map(function(d) {
                return isNaN(values[d][0]) ? 
                    {categorical: true,  len: 0, map: [] } : 
                    {categorical: false, len: 0, map: [], displayValue: [] }; 
            }) : 
            pCoordIndex.map(function(d) {
                return isNaN(values[d][0]) ? 
                    {categorical: true, len: 0, map: [] } : 
                    null; 
            })
            ;
  
        // 2: and generate a helper-function to update the mapping
        // For non-categorical value the original-value is store in displayValue
        var coordMapUpdate = function(i, val) {
            var cMap = pCoordMapping[i];
            var k = null; // define in outer scope.
            if (!cMap.categorical) {
                var keyVal = val.toFixed(numDigit);   // force the number to be a string
                k = cMap.map[keyVal];
                if (k == null) {
                    k = cMap.len;
                    cMap.len++;
                    cMap.map[keyVal] = k;
                    cMap.displayValue[keyVal] = val;
                }
            } else {
                k = cMap.map[val];
                if (k == null) {
                    k = cMap.len;
                    cMap.len++;
                    cMap.map[val] = k;
                }
            }
            return k;
        };

        // 3. determine the value to be displayed
        //   for the categorical dimensions map == displayValue
        for(var d in pCoordMapping){
            if (pCoordMapping.hasOwnProperty(d) && 
                pCoordMapping[d] && 
                pCoordMapping[d].categorical) {
                pCoordMapping[d].displayValue = pCoordMapping[d].map;
            }
        }
    
        var i, item, k;
    
        // 4. apply the sorting of the dimension
        if (this.chart.options.sortCategorical || 
            this.chart.options.mapAllDimensions) {
            // prefill the coordMapping in order to get it in sorted order.
            // sorting is required if all dimensions are mapped!!
            for (i=0; i<pCoordMapping.length; i++) {
                if (pCoordMapping[i]) {
                    // add all data
                    for (var col=0; col<values[i].length; col++) {
                        coordMapUpdate(i, values[i][col]);
                    }
           
                    // create a sorted array
                    var cMap = pCoordMapping[i].map;
                    var sorted = [];
                    for(item in cMap){
                        if(cMap.hasOwnProperty(item)){
                            sorted.push(item);
                        }
                    }
                    sorted.sort();
                    // and assign a new index to all items
                    if (pCoordMapping[i].categorical){
                        for(k=0; k<sorted.length; k++){
                            cMap[sorted[k]] = k;
                        }
                    } else {
                        for(k=0; k<sorted.length; k++) {
                            cMap[sorted[k]].index = k;
                        }
                    }
                }      
            }
        }

        /*************
         *  Generate the full dataset (using the coordinate mapping).
         *  (in 2 steps)
         ******/
        //   1. generate helper-function to transform a data-row to a hashMap
        //   (key-value pairs). 
        //   closure uses pCoordKeys and values
        var generateHashMap = function(col) {
            var record = {};
            for(var j in pCoordIndex) {
                if(pCoordIndex.hasOwnProperty(j)){
                    record[pCoordKeys[j]] = (pCoordMapping[j]) ?
                            coordMapUpdate(j, values[j][col]) :
                                values[j][col];
                }
            }
            return record;
        };
    
        // 2. generate array with a hashmap per data-point
        this.data = dataRowIndex.map(function(col) { return generateHashMap (col); });
    
        /*************
         *  Generate an array of descriptors for the dimensions (in 3 steps).
         ******/
        // 1. find the dimensions
        var descrVals = this.dimensions.map(function(cat){
            var item2 = {};
            // the part after "__" is assumed to be the units
            var elements = cat.split("__");
            item2.id = cat;
            item2.name = elements[0];
            item2.unit = (elements.length >1)? elements[1] : "";
            return item2;
        });

        // 2. compute the min, max and step(-size) per dimension)
        for(i=0; i<descrVals.length; i++) {
            item = descrVals[i];
            var index = pCoordIndex[i];
            // orgRowIndex is the index in the original dataset
            // some indices might be (non-existent/invisible)
            item.orgRowIndex = index;

            // determine min, max and estimate step-size
            var len = values[index].length;
            var theMin, theMax, theMin2, theMax2;
            var v;
      
            // two version of the same code (one with mapping and one without)
            if (pCoordMapping[index]) {
                theMin = theMax = theMin2 = theMax2 =
                pCoordMapping[index].displayValue[ values[index][0] ];

                for(k=1; k<len; k++) {
                    v = pCoordMapping[index].displayValue[ values[index][k] ] ;
                    if (v < theMin){
                        theMin2 = theMin;
                        theMin = v;
                    }
                    
                    if (v > theMax) {
                        theMax2 = theMax;
                        theMax = v;
                    }
                }
            } else {  // no coordinate mapping applied
                theMin = theMax = theMin2 = theMax2 = values[index][0];

                for(k=1; k<len; k++) {
                    v = values[index][k];
                    if (v < theMin) {
                        theMin2 = theMin;
                        theMin = v;
                    }
                    
                    if (v > theMax) {
                        theMax2 = theMax;
                        theMax = v;
                    }
                }
            }   // end else:  coordinate mapping applied

            var theStep = ((theMax - theMax2) + (theMin2-theMin))/2;
            item.min = theMin;
            item.max = theMax;
            item.step = theStep;

            // 3. and include the mapping (and reverse mapping) 
            item.categorical = false; 
            if (pCoordMapping[index]) {
                item.map = pCoordMapping[index].map;
                item.mapLength = pCoordMapping[index].len;
                item.categorical = pCoordMapping[index].categorical; 

                // create the reverse-mapping from key to original value
                if (!item.categorical) {
                    item.orgValue = [];
                    var theMap =  pCoordMapping[index].map;
                    for (var key in theMap){
                        if(theMap.hasOwnProperty(key)){
                            item.orgValue[ theMap[key] ] = 0.0+key;
                        }
                    }
                }
            }
        }

        // generate a object using the given set of keys and values
        //  (map from keys[i] to vals[i])
        var genKeyVal = function (keys, vals) {
            var record = {};
            for (var i = 0; i<keys.length; i++){
                record[keys[i]] = vals[i];
            }
            return record;
        };
        this.dimensionDescr = genKeyVal(this.dimensions, descrVals);
    },

    _createCore: function(){

        var myself = this;

        this.retrieveData();

        // used in the different closures
        var height = this.height,
            numDigits = this.chart.options.numDigits,
            topRuleOffs = this.chart.options.topRuleOffset,
            botRuleOffs = this.chart.options.botRuleOffset,
            leftRuleOffs = this.chart.options.leftRuleOffset,
            rightRulePos = this.width - this.chart.options.rightRuleOffset,
            topRulePos = this.height- topRuleOffs,
            ruleHeight = topRulePos - botRuleOffs,
            labelTopOffs = topRuleOffs - 12,
            // use dims to get the elements of dimDescr in the appropriate order!!
            dims = this.dimensions,
            dimDescr = this.dimensionDescr;

        /*****
         *   Generate the scales x, y and color
         *******/
        // getDimSc is the basis for getDimensionScale and getDimColorScale
        var getDimSc = function(t, addMargin) {
            var theMin = dimDescr[t].min;
            var theMax = dimDescr[t].max;
            var theStep = dimDescr[t].step;
            // add some margin at top and bottom (based on step)
            if (addMargin) {
                theMin -= theStep;
                theMax += theStep;
            }
            
            return pv.Scale.linear(theMin, theMax)
                .range(botRuleOffs, topRulePos);
        };
        
        var getDimensionScale = function(t) {
            var scale = getDimSc(t, true)
                .range(botRuleOffs, topRulePos);
            var dd = dimDescr[t];
            if (dd.orgValue && !dd.categorical) {
                // map the value to the original value
                var func = function(x) { 
                    var res = scale( dd.orgValue[x]);
                    return res; 
                };
        
                // wire domain() and invert() to the original scale
                func.domain  = function() { return scale.domain();  };
                func.invert = function(d) { return scale.invert(d); };
                return func;
            }
      
            return scale;
        };
        
        var getDimColorScale = function(t) {
            var scale = getDimSc(t, false)
                .range("steelblue", "brown");
            return scale;
        }; 

        var x = pv.Scale.ordinal(dims).splitFlush(leftRuleOffs, rightRulePos);
        var y = pv.dict(dims, getDimensionScale);
        var colors = pv.dict(dims, getDimColorScale);

        /*****
         *   Generate tools for computing selections.
         *******/
        // Interaction state. 
        var filter = pv.dict(dims, function(t) {
            return {min: y[t].domain()[0], max: y[t].domain()[1]};  });
        
        var active = dims[0];   // choose the active dimension 

        var selectVisible = this.chart.options.mapAllDimensions ?
            function(d) { 
                return dims.every(  
                   // all dimension are handled via a mapping.
                    function(t) {
                        var dd = dimDescr[t];
                        var val = (dd.orgValue && !dd.categorical) ?
                                  dd.orgValue[d[t]] : 
                                  d[t];
                        return (val >= filter[t].min) && (val <= filter[t].max); 
                    });
             } : 
             function(d) { 
                 return dims.every(function(t) {
                     // TO DO: check whether this operates correctly for
                     // categorical dimensions  (when mapAllDimensions == false
                     return (d[t] >= filter[t].min) && (d[t] <= filter[t].max); 
                 });
             }
             ;
 
        /*****
         *   generateLinePattern produces a line pattern based on
         *          1. the current dataset.
         *          2. the current filter settings.
         *          3. the provided colorMethod.
         *  The result is an array where each element contains at least
         *            {x1, y1, x2, y2, color}
         *  Two auxiliary fields are 
         *  Furthermore auxiliary functions are provided
         *     - colorFuncFreq
         *     - colorFuncActive
         *******/
         var auxData = null;
      
         /*****
          *   Draw the chart and its annotations (except dynamic content)
          *  ******/
         // Draw the data to the parallel dimensions 
         // (the light grey dataset is a fixed background)
         this.pvParCoord = this.pvPanel.add(pv.Panel)
             .data(myself.data)
             .visible(selectVisible)
             .add(pv.Line)
             .data(dims)
             .left(function(t, d) { return x(t); } )
             .bottom(function(t, d) { 
                 var res = y[t] (d[t]);
                 return res; 
             })
             .strokeStyle("#ddd")
             .lineWidth(1)
             .antialias(false)
             ;

         // Rule per dimension.
         var rule = this.pvPanel.add(pv.Rule)
             .data(dims)
             .left(x)
             .top(topRuleOffs)
             .bottom(botRuleOffs)
             ;

         // Dimension label
         rule.anchor("top").add(pv.Label)
             .top(labelTopOffs)
             .font("bold 10px sans-serif")
             .text(function(d) { return dimDescr[d].name; })
             ;

         // add labels on the categorical dimension
         //  compute the array of labels
         var labels = [];
         var labelXoffs = 6,
         labelYoffs = 3;
         for(var d in dimDescr) {
             if(dimDescr.hasOwnProperty(d)){
                 var dim = dimDescr[d];
                 if (dim.categorical) {
                     var  xVal = x(dim.id) + labelXoffs;
                     for (var l in dim.map){
                         if(dim.map.hasOwnProperty(l)){
                             labels[labels.length] = {
                                     x:  xVal,
                                     y:  y[dim.id](dim.map[l]) + labelYoffs,
                                     label: l
                             };
                         }
                     }
                 }
             }
         }
         
         var dimLabels = this.pvPanel.add(pv.Panel)
             .data(labels)
             .add(pv.Label)
             .left(function(d) {return d.x;})
             .bottom(function(d) { return d.y;})
             .text(function(d) { return d.label;})
             .textAlign("left")
             ;
    
      
         /*****
          *   Add an additional panel over the top for the dynamic content
          *    (and draw the (full) dataset)
          *******/
         // Draw the selected (changeable) data on a new panel on top
         var change = this.pvPanel.add(pv.Panel);
         var line = change.add(pv.Panel)
             .data(myself.data)
             .visible(selectVisible)
             .add(pv.Line)
             .data(dims)
             .left(function(t, d) { return x(t);})
             .bottom(function(t, d) { return y[t](d[t]); })
             .strokeStyle(function(t, d) { 
                 var dd = dimDescr[active];
                 var val = (dd.orgValue && !dd.categorical) ?
                           dd.orgValue[ d[active] ] :
                           d[active]
                           ;
                 return colors[active](val);
             })
             .lineWidth(1)
             ;

         /*****
          *   Add the user-interaction (mouse-interface)
          *   and the (dynamic) labels of the selection.
          *******/

         // Updater for slider and resizer.
         function update(d) {
             var t = d.dim;
             filter[t].min = Math.max(y[t].domain()[0], y[t].invert(height - d.y - d.dy));
             filter[t].max = Math.min(y[t].domain()[1], y[t].invert(height - d.y));
             active = t;
             change.render();
             return false;
         }

         // Updater for slider and resizer.
         function selectAll(d) {
             if (d.dy < 3) {  // 
                 var t = d.dim;
                 filter[t].min = Math.max(y[t].domain()[0], y[t].invert(0));
                 filter[t].max = Math.min(y[t].domain()[1], y[t].invert(height));
                 d.y = botRuleOffs; d.dy = ruleHeight;
                 active = t;
                 change.render();
             }
             return false;
         }
       
         // Handle select and drag 
         var handle = change.add(pv.Panel)
             .data(dims.map(function(dim) { return {y:botRuleOffs, dy:ruleHeight, dim:dim}; }))
             .left(function(t) { return x(t.dim) - 30; })
             .width(60)
             .fillStyle("rgba(0,0,0,.001)")
             .cursor("crosshair")
             .event("mousedown", pv.Behavior.select())
             .event("select", update)
             .event("selectend", selectAll)
             .add(pv.Bar)
             .left(25)
             .top(function(d) {return d.y;})
             .width(10)
             .height(function(d) { return d.dy;})
             .fillStyle(function(t) { 
                 return (t.dim == active) ? 
                        colors[t.dim]((filter[t.dim].max + filter[t.dim].min) / 2) : 
                        "hsla(0,0,50%,.5)";
             })
             .strokeStyle("white")
             .cursor("move")
             .event("mousedown", pv.Behavior.drag())
             .event("dragstart", update)
             .event("drag", update)
             ;

         handle.anchor("bottom").add(pv.Label)
             .textBaseline("top")
             .text(function(d) { 
                 return (dimDescr[d.dim].categorical) ?
                        "" :
                        filter[d.dim].min.toFixed(numDigits) + dimDescr[d.dim].unit
                        ;
             })
             ;

         handle.anchor("top").add(pv.Label)
             .textBaseline("bottom")
             .text(function(d) {
                 return (dimDescr[d.dim].categorical) ?
                        "" :
                        filter[d.dim].max.toFixed(numDigits) + dimDescr[d.dim].unit;
             })
             ;


         /*****
          *  add the extension points
          *******/

         // Extend ParallelCoordinates
         this.extend(this.pvParCoord,"parCoord");
         // the parCoord panel is the base-panel (not the colored dynamic overlay)

         // Extend body
         this.extend(this.pvPanel,"chart");
    }
});
/**
 * DataTree visualises a data-tree (also called driver tree).
 * It uses a data-sources to obtain the definition of data tree.
 * Each node of the tree can have it's own datasource to visualize the
 * node. 
 */
def
.type('pvc.DataTree', pvc.BaseChart)
.init(function(options){
    // Force the value dimension not to be a number
    options = options || {};
    options.dimensionGroups = options.dimensionGroups || {};
    if(!options.dimensionGroups.value) {
        options.dimensionGroups.value = {valueType: null};
    }
    
    this.base(options);
})
.add({

    // the structure of the dataTree is provided by a separate datasource
    structEngine:   null,
    structMetadata: null,
    structDataset:  null,

    DataTreePanel : null,
    
    _getColorRoleSpec: function(){
        return { isRequired: true, defaultSourceRole: 'category', requireIsDiscrete: true };
    },
    
    setStructData: function(data){
        this.structDataset = data.resultset;
        if (!this.structDataset.length){
            this._log("Warning: Structure-dataset is empty");
        }

        this.structMetadata = data.metadata;
        if (!this.structMetadata.length){
            this._log("Warning: Structure-Metadata is empty");
        }
    },
  
    _preRenderContent: function(contentOptions){
        // Create DataEngine
        var structEngine  = this.structEngine;
        var structType    = structEngine ? structEngine.type : new pvc.data.ComplexType();
        // Force the value dimension not to be a number
        structType.addDimension('value', {});
        
        var translOptions = {
            seriesInRows: true,
            crosstabMode: true
        };
        
        var translation = new pvc.data.CrosstabTranslationOper(structType, this.structDataset, this.structMetadata, translOptions);
        translation.configureType();
        if(!structEngine) {
            structEngine = this.structEngine = new pvc.data.Data({type: structType});
        }
        
        structEngine.load(translation.execute(structEngine));

        if(pvc.debug >= 3){
            this._log(this.structEngine.getInfo());
        }

        // ------------------
        
        this.dataTreePanel = new pvc.DataTreePanel(this, this.basePanel, def.create(contentOptions, {
            topRuleOffset : this.options.topRuleOffset,
            botRuleOffset : this.options.botRuleOffset,
            leftRuleOffset : this.options.leftRuleOffset,
            rightRuleOffset : this.options.rightRuleOffset,
            boxplotColor:  this.options.boxplotColor,
            valueFontsize: this.options.valueFontsize,
            headerFontsize: this.options.headerFontsize,
            border: this.options.border,
            perpConnector: this.options.perpConnector,
            numDigits: this.options.numDigits,
            minVerticalSpace: this.options.minVerticalSpace,
            connectorSpace: this.options.connectorSpace,
            minAspectRatio: this.options.minAspectRatio
        }));
    },
    
    defaults: {
        compatVersion: 1,
        
     // margins around the full tree
        topRuleOffset: 30,
        botRuleOffset: 30,
        leftRuleOffset: 60,
        rightRuleOffset: 60,
        // box related parameters
        boxplotColor: "grey",
        headerFontsize: 16,
        valueFontsize: 20,
        border:  2,     // bordersize in pixels
        // use perpendicular connector lines  between boxes.
        perpConnector: false,
        // number of digits (after dot for labels)
        numDigits: 0,
        // the space for the connectors is 15% of the width of a grid cell
        connectorSpace: 0.15,
        // the vertical space between gridcells is at least 5%
        minVerticalSpace: 0.05,
        // aspect ratio = width/height  (used to limit AR of the boxes)
        minAspectRatio: 2.0

        //selectParam: undefined
    }
});

/*
 * DataTree chart panel. 
 *   << to be filled out >>
 *
 * Has the following protovis extension points:
 *
 * <i>chart_</i> - for the main chart Panel
 *    << to be filled out >>
 */
def
.type('pvc.DataTreePanel', pvc.PlotPanel)
.add({
  
  pvDataTree: null,

  treeElements: null, 

  structMap: null,
  structArr: null,

  hRules: null,
  vRules: null,
  rules: null,

  // generating Perpendicular connectors 
  // (only using horizontal and vertical rules)
  // leftLength gives the distance from the left box to the
  // splitting point of the connector
  generatePerpConnectors: function(leftLength) {

    this.hRules = [];
    this.vRules = [];
    this.rules  = [];  // also initialize this rule-set

    for(var e in this.structMap) {
      var elem = this.structMap[e];
      if (elem.children != null) {
        var min = +10000, max = -10000;
        var theLeft = elem.left + elem.width;
        this.hRules.push({"left": theLeft,
                    "width": leftLength,
                    "bottom": elem.bottom + elem.height/2});
        theLeft += leftLength;
        for(var i in elem.children) {
          var child = this.structMap[ elem.children[i] ];
          var theBottom = child.bottom + child.height/2;
          if (theBottom > max) { max = theBottom; }
          if (theBottom < min) { min = theBottom; }
          this.hRules.push({"left": theLeft,
                      "width": child.left - theLeft,
                      "bottom": theBottom});
        }

        // a vertical rule is only added when needed
        if (max > min) {
          this.vRules.push({"left": theLeft,
                      "bottom": min,
                      "height": max - min});
        }
      }
    }
  },

  // generate a line segment and add it to rules
  generateLineSegment: function(x1, y1, x2, y2) {
    var line = [];
    line.push({"x":  x1,
               "y":  y1});
    line.push({"x":  x2,
               "y":  y2});
    this.rules.push(line);
  },

  // leftLength gives the distance from the left box to the
  // splitting point of the connector
  generateConnectors: function(leftLength) {

    this.hRules = [];
    this.vRules = [];

    if (this.chart.options.perpConnector) {
      this.generatePerpConnectors(leftLength);
      return;
    }

    // this time were using diagonal rules
    this.rules = [];

    for(var e in this.structMap) {
      var elem = this.structMap[e];
      if (elem.children != null) {
        var theCenter, child, i;
        
        // compute the mid-point
        var min = +10000, max = -10000;
        for(i in elem.children) {
          child = this.structMap[ elem.children[i] ];
          theCenter = child.bottom + child.height/2;
          if (theCenter > max) { max = theCenter; }
          if (theCenter < min) { min = theCenter; }
        }
        var mid = (max + min)/2;

        var theLeft1 = elem.left + elem.width;
        var theLeft2 = theLeft1 + leftLength;

        // outbound line of the left-hand box
        this.generateLineSegment(theLeft1, elem.bottom + elem.height/2,
                                theLeft2, mid);

        // incoming lines of the right-hand boxes
        for(i in elem.children) {
          child = this.structMap[ elem.children[i] ];
          theCenter = child.bottom + child.height/2;

          this.generateLineSegment(theLeft2, mid,
                                   child.left, theCenter);
        }
      }
    }
  },

  retrieveStructure: function () {
    var data = this.chart.structEngine;
    var options = this.chart.options;

    var colLabels = data.getVisibleCategories();
    this.treeElements = data.getVisibleSeries();
    var values = data.getValues();

    // if a fifth column is added, then
    //  bottom and height are provided in the dataset.
    var bottomHeightSpecified = (colLabels.length > 4);
    
    var e;
    
    // trim al element labels (to allow for matching without spaces)
    for(e in this.treeElements) { 
      this.treeElements[e] = $.trim(this.treeElements[e]);
    }

    // get the bounds (minimal and maximum column and row indices)
    // first a bounds object with two helper-functions is introduced
    var bounds = [];
    bounds.getElement = function(label) {
      // create the element if it does not exist
      if (bounds[label] == null){
        bounds[label] = {"min": +10000, "max": -10000};
      }
      return bounds[label];
    };
    
    bounds.addValue = function(label, value) {
      var bnd = bounds.getElement(label);
      if (value < bnd.min){
        bnd.min = value;
      }
      if (value > bnd.max){
        bnd.max = value;
      }
      return bnd;
    };
    
    var col, colnr, elem, row;
    for(e in this.treeElements) {
      elem = this.treeElements[e];
      col = elem[0];
      colnr = col.charCodeAt(0);
      row = parseInt(elem.slice(1), 10);
      bounds.addValue("__cols", colnr);
      bounds.addValue(col,row);
    }

    // determine parameters to find column-bounds    
    var bnds = bounds.getElement("__cols");
    var gridWidth  = this.innerWidth/(bnds.max - bnds.min + 1); // integer
    var connectorWidth = options.connectorSpace * gridWidth;
    var cellWidth = gridWidth - connectorWidth;
    var maxCellHeight = cellWidth/options.minAspectRatio;
    var colBase = bnds.min;
    delete bounds.__cols;

    // compute additional values for each column
    for (e in bounds) {
      bnds = bounds[e];
      
      if (typeof bnds == "function"){
        continue;
      }
      var numRows = bnds.max - bnds.min + 1;

      bnds.gridHeight = this.innerHeight/numRows;
      bnds.cellHeight = bnds.gridHeight*(1.0 - options.minVerticalSpace);
      if (bnds.cellHeight > maxCellHeight){
        bnds.cellHeight = maxCellHeight;
      }
      bnds.relBottom = (bnds.gridHeight - bnds.cellHeight)/2;
      bnds.numRows = numRows;
    }

    // generate the elements
    var whitespaceQuote = new RegExp ('[\\s\"\']+',"g"); 
    this.structMap = {};
    for(e in this.treeElements) {
      var box = {};
      elem = this.treeElements[e];
      box.box_id = elem;
      this.structMap[elem] = box;

      col = elem[0];
      colnr = col.charCodeAt(0);
      row = parseInt(elem.slice(1), 10);
      bnds = bounds.getElement(col);

      box.colIndex = colnr - colBase;
      box.rowIndex = bnds.numRows - (row - bnds.min) - 1;

      box.left = this.leftOffs + box.colIndex * gridWidth;
      box.width = cellWidth;
      if (bottomHeightSpecified) {
          box.bottom = values[4][e];
          box.height = values[5][e];
      } else {
          box.bottom = this.botOffs + box.rowIndex * bnds.gridHeight + bnds.relBottom;
          box.height = bnds.cellHeight;
      }
      
      box.label = values[0][e];
      box.selector = values[1][e];
      box.aggregation = values[2][e];
      
      var children = (values[3][e] || '').replace(whitespaceQuote, " ");
      
      box.children = (children === " " || children ===  "") ?
         null : children.split(" ");
    }

    this.generateConnectors((gridWidth - cellWidth)/2);

    // translate the map to an array (needed by protovis)
    this.structArr = [];
    for(e in this.structMap) {
      elem = this.structMap[e];
      this.structArr.push(elem);
    }
  },

  findDataValue: function(key, data) {
    for(var i=0; i < data[0].length; i++) {
      if (data[0][ i ] == key) {
        return data[1][ i ];
      }
    }
    
    this._log("Error: value with key : "+key+" not found.");
  },

  generateBoxPlots: function() {
    var options = this.chart.options;

    for(var e in this.structArr) {
      var elem = this.structArr[e];
      if (!elem.values.length) {
        continue;
      }
      
      elem.subplot = {};
      var sp = elem.subplot;

      // order the data elements from 5% bound to 95% bound
      // and determine the horizontal scale
      var dat = [];
      var margin = 15;
      var rlMargin = elem.width/6;

      // generate empty rule sets (existing sets are overwritten !)
      sp.hRules = [];
      sp.vRules = [];
      sp.marks = [];
      sp.labels = [];

      dat.push(this.findDataValue("_p5", elem.values));
      dat.push(this.findDataValue("_p25", elem.values));
      dat.push(this.findDataValue("_p50", elem.values));
      dat.push(this.findDataValue("_p75", elem.values));
      dat.push(this.findDataValue("_p95", elem.values));

      var noBox = false;

	if (typeof(dat[2]) != "undefined") {
        // switch order (assume computational artifact)
        if (dat[4] < dat[0]) {
          dat = dat.reverse();
          this._log(" dataset "+ elem.box_id +
                  " repaired (_p95 was smaller than _p5)");
          }
        if (dat[4] > dat[0]) {
          sp.hScale = pv.Scale.linear( dat[0], dat[4]);
        } else {
          noBox = true;
          // generate a fake scale centered around dat[0] (== dat[4])
          sp.hScale = pv.Scale.linear( dat[0] - 1e-10, dat[0] + 1e-10);
        }
        sp.hScale.range(elem.left + rlMargin, elem.left + elem.width - rlMargin);
        var avLabel = "" + dat[2];   // prepare the label
        
        var i;
        
        for(i=0; i< dat.length; i++) {
            dat[i] = sp.hScale( dat[i]);
        }

        sp.bot = elem.bottom + elem.height / 3;
        sp.top = elem.bottom + 2 * elem.height / 3;
        sp.mid = (sp.top + sp.bot) / 2;   // 2/3 of height
        sp.textBottom = elem.bottom + margin;
        sp.textBottom = sp.bot - options.valueFontsize - 1;

        // and add the new set of rules for a box-plot.
        var lwa = 3;   // constant for "lineWidth Average"
        if (noBox) {
            sp.vRules.push({"left": dat[0],
                          "bottom": sp.bot,
                          "lWidth": lwa,
                          "height": sp.top - sp.bot});
        } else {
          sp.hRules.push({"left": dat[0],
                        "width":  dat[1] - dat[0],
                        "lWidth": 1,
                        "bottom": sp.mid});
          sp.hRules.push({"left": dat[1],
                        "width":  dat[3] - dat[1],
                        "lWidth": 1,
                        "bottom": sp.bot});
          sp.hRules.push({"left": dat[1],
                        "width":  dat[3] - dat[1],
                        "lWidth": 1,
                        "bottom": sp.top});
          sp.hRules.push({"left": dat[3],
                        "width":  dat[4] - dat[3],
                        "lWidth": 1,
                        "bottom": sp.mid});
          for(i=0; i<dat.length; i++) {
            sp.vRules.push({"left": dat[i],
                          "bottom": sp.bot,
                          "lWidth": (i == 2) ? lwa : 1,
                          "height": sp.top - sp.bot});
          }
        }

        sp.labels.push({left: dat[2],
                      bottom: sp.textBottom,
                      text: this.labelFixedDigits(avLabel),
                      size: options.smValueFont,
                      color: options.boxplotColor});
    }
    }
  } ,

  labelFixedDigits: function(value) {
    if (typeof value == "string") {
        value = parseFloat(value);
    }

    if (typeof value == "number") {
      var nd = this.chart.options.numDigits;

      value = value.toFixed(nd);
    }

    // translate to a string again
    return "" + value;
  } ,

  addDataPoint: function(key) {
    var options = this.chart.options;

    for(var e in this.structArr) {
      var elem = this.structArr[e];

      if (!elem.values.length) {
        continue;
      }
      
      var value = this.findDataValue(key, elem.values);
      if (typeof value == "undefined") {
        continue;
      }
      
      var sp = elem.subplot;
      var theLeft = sp.hScale(value); 

      var theColor = "green";
      sp.marks.push( {
        left: theLeft,
        bottom: sp.mid,
        color: theColor });
      
      sp.labels.push({left: theLeft,
                      bottom: sp.textBottom,
                      text: this.labelFixedDigits(value),
                      size: options.valueFont,
                      color: theColor});
    }
  }, 

  retrieveData: function () {
    var data = this.chart.data;
    var options = this.chart.options;

    var colLabels = data.getVisibleCategories();
    var selectors = data.getVisibleSeries();
    var values = data.getValues();
    var selMap = {};
    var i;
    
    // create empty datasets and selMap
    var numCols = values.length;
    for(var e in this.structArr) {
      var elem = this.structArr[e];
      elem.values = [];
      for(i=0; i<numCols; i++) {
          elem.values.push([]);
      }
      selMap[ elem.selector ] = elem; 
    }

    // distribute the dataset over the elements based on the selector
    var boxNotFound = {};
    for(i in selectors) {
      var box = selMap[ selectors[ i ] ];
      if (typeof(box) != "undefined") {
        for(var j in values) {
            box.values[j].push(values[ j ][ i ]);
        }
      } else {
        boxNotFound[ selectors[i] ] = true;
      }
    }

    for (var sel in boxNotFound) {
        this._log("Could'nt find box for selector: "+ sel);
    }
    
    this.generateBoxPlots();

    var whitespaceQuote = new RegExp ('[\\s\"\']+',"g");
    if(options.selectParam){
        var selPar = options.selectParam.replace(whitespaceQuote, '');
        /*global window:true*/
        if ((selPar != "undefined") && 
            (selPar.length > 0) &&
            (typeof window[selPar] != "undefined")) {
            selPar = window[selPar];
            this.addDataPoint(selPar);
        }
    }
  } ,

  /**
   * @override
   */
  _createCore: function() {
      
    var myself  = this;

    var options = this.chart.options;
    options.smValueFontsize = Math.round(0.6 * options.valueFontsize);
    options.smValueFont = "" + options.smValueFontsize + "px sans-serif";
    options.valueFont = "" + options.valueFontsize + "px sans-serif";

    // used in the different closures
    var topRuleOffs = options.topRuleOffset,
        botRuleOffs = options.botRuleOffset,
        leftRuleOffs = options.leftRuleOffset;

    // set a few parameters which will be used during data-retrieval
    this.innerWidth = this.width - leftRuleOffs - options.rightRuleOffset;
    this.innerHeight = this.height - topRuleOffs - botRuleOffs;
    this.botOffs = botRuleOffs;
    this.leftOffs = leftRuleOffs;

    // retrieve the data and transform it to the internal representation.
    this.retrieveStructure();

    this.retrieveData();

    /*****
     *   Generate the scales x, y and color
     *******/

/*
pv.Mark.prototype.property("testAdd");
    pv.Mark.prototype.testAdd = function(x) { 
return pv.Label(x);
                      }
*/
    var topMargin = options.headerFontsize + 3;

    // draw the connectors first (rest has to drawn over the top)
    var rules = this.rules;
    var i;
    
    for (i = 0; i < rules.length; i++) {
      /*jshint loopfunc:true */
      this.pvPanel.add(pv.Line)
        .data(rules[ i ])
        .left(function(d) { return d.x;})
        .bottom(function(d) { return d.y;})
        .lineWidth(1)
        .strokeStyle("black");
    }
    
    // draw the data containers with decorations
    this.pvDataTree = this.pvPanel.add(pv.Bar)
      .data(myself.structArr)
      .left(function(d) { return d.left;})
      .bottom(function(d) { return d.bottom;})
      .height(function(d) { return d.height;})
      .width(function(d) { return d.width;})
      .fillStyle("green")
//;  this.pvDataTree
    .add(pv.Bar)
//      .data(function(d) {return d; })
      .left(function(d) { return d.left + options.border;})
      .bottom(function(d) { return d.bottom + options.border;})
      .height(function(d) { return d.height - options.border - topMargin;})
      .width(function(d) { return d.width - 2 * options.border;})
      .fillStyle("white")
    .add(pv.Label)
      .text(function(d) { return d.label;})
      .textAlign("center")
      .left(function (d) {return  d.left + d.width/2;})
      .bottom(function(d) {
          return d.bottom + d.height - options.headerFontsize - 5 + options.headerFontsize/5;
})
      .font("" + options.headerFontsize + "px sans-serif")
      .textStyle("white")
      .fillStyle("blue");

    // add the box-plots
    for(i=0; i<this.structArr.length; i++) {
      var box = this.structArr[i];
      this.pvPanel.add(pv.Rule)
        .data(box.subplot.hRules)
        .left(function(d) { return d.left;})
        .width( function(d) { return d.width;})
        .bottom( function(d) { return d.bottom;})
        .lineWidth( function(d) { return d.lWidth; })
        .strokeStyle(myself.chart.options.boxplotColor);

      this.pvPanel.add(pv.Rule)
        .data(box.subplot.vRules)
        .left(function(d) { return d.left;})
        .height( function(d) { return d.height;})
        .bottom( function(d) { return d.bottom;})
        .lineWidth( function(d) { return d.lWidth; })
        .strokeStyle(myself.chart.options.boxplotColor);

      this.pvPanel.add(pv.Dot)
        .data(box.subplot.marks)
        .left(function(d) { return d.left; })
        .bottom(function(d){ return d.bottom;})
        .fillStyle(function(d) {return d.color;});


      this.pvPanel.add(pv.Label)
        .data(box.subplot.labels)
        .left(function(d) { return d.left; })
        .bottom(function(d){ return d.bottom;})
        .font(function(d) { return d.size;})
        .text(function(d) { return d.text;})
        .textAlign("center")
        .textStyle(function(d) {return d.color;});

    }

    // add the connecting rules (perpendicular rules)
    if (options.perpConnector) {
      this.pvPanel.add(pv.Rule)
        .data(myself.vRules)
        .left(function(d) { return d.left;})
        .bottom(function(d) { return d.bottom;})
        .height(function(d) { return d.height;})
        .strokeStyle("black");
      this.pvPanel.add(pv.Rule)
        .data(myself.hRules)
        .left(function(d) { return d.left;})
        .bottom(function(d) { return d.bottom;})
        .width(function(d) { return d.width;})
        .strokeStyle("black");
    }

    /*****
     *   draw the data-tree
     *******/
   },
  
   applyExtensions: function(){
      // Extend the dataTree
      this.extend(this.pvDataTree,"dataTree");
   }
});
/**
 * @name pvc.data.BoxplotChartTranslationOper
 * 
 * @class The translation mixin operation of the box plot chart.
 * 
 * <p>
 * The default box plot format is:
 * </p>
 * <pre>
 * +----------+----------+--------------+--------------+------------+-------------+
 * | 0        | 1        | 2            | 3            | 4          | 5           |
 * +----------+----------+--------------+--------------+------------+-------------+
 * | category | median   | lowerQuartil | upperQuartil | minimum    | maximum     |
 * +----------+----------+--------------+--------------+------------+-------------+
 * | any      | number   | number       | number       | number     | number      |
 * +----------+----------+--------------+--------------+------------+-------------+
 * </pre>
 * 
 * @extends pvc.data.MatrixTranslationOper
 */
def.type('pvc.data.BoxplotChartTranslationOper')
.add(/** @lends pvc.data.BoxplotChartTranslationOper# */{
    /**
     * @override
     */
    _configureTypeCore: function(){
        var autoDimNames = [];
        
        var V = this.virtualItemSize();
        var C = V - this.M;
        
        this._getUnboundRoleDefaultDimNames('category', C, autoDimNames);
        
        pvc.BoxplotChart.measureRolesNames.forEach(function(roleName){
            this._getUnboundRoleDefaultDimNames(roleName, 1, autoDimNames);
        }, this);

        autoDimNames.slice(0, this.freeVirtualItemSize());
        if(autoDimNames.length){
            this.defReader({names: autoDimNames});
        }
    }
});
def
.type('pvc.BoxplotPanel', pvc.CategoricalAbstractPanel)
.init(function(chart, parent, plot, options) {
    
    this.base(chart, parent, plot, options);
    
    this.boxSizeRatio = plot.option('BoxSizeRatio');
    this.maxBoxSize   = plot.option('BoxSizeMax');
})
.add({
    plotType: 'box',
    
    anchor: 'fill',
    
    // Override default mappings
    _v1DimRoleName: {
        //'series':   'series',
        //'category': 'category',
        'value':    'median'
    },
    
    /**
     * @override
     */
    _createCore: function(){

        this.base();
        
        var rootScene = this._buildScene();

        var a_bottom = this.isOrientationVertical() ? "bottom" : "left",
            a_left   = this.anchorOrtho(a_bottom),
            a_width  = this.anchorLength(a_bottom),
            a_height = this.anchorOrthoLength(a_bottom)
            ;

        function defaultColor(type){
            var color = this.base(type);
            return type === 'stroke' ? color.darker(1) : color;
        }
        
        /* Category Panel */
        var extensionIds = ['panel'];
        if(this.compatVersion() <= 1){
            extensionIds.push(''); // let access as "box_"
        }
        
        this.pvBoxPanel = new pvc.visual.Panel(this, this.pvPanel, {
                extensionId: extensionIds
            })
            .lock('data', rootScene.childNodes)
            .lockMark(a_left, function(scene){
                var catVar = scene.vars.category;
                return catVar.x - catVar.width / 2;
            })
            .pvMark
            [a_width](function(scene){ return scene.vars.category.width; })
            ;
        
        /* V Rules */
        function setupRuleWhisker(rule){
            rule.lock(a_left, function(){ 
                    return this.pvMark.parent[a_width]() / 2;
                })
                .override('defaultColor', defaultColor)
                ;

            return rule;
        }

        this.pvRuleWhiskerUpper = setupRuleWhisker(new pvc.visual.Rule(this, this.pvBoxPanel, {
                extensionId:   'boxRuleWhisker',
                freePosition:  true,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            }))
            .intercept('visible', function(scene){
                return scene.vars.category.showRuleWhiskerUpper && this.delegateExtension(true);
            })
            .lock(a_bottom, function(scene){ return scene.vars.category.ruleWhiskerUpperBottom; })
            .lock(a_height, function(scene){ return scene.vars.category.ruleWhiskerUpperHeight; })
            .pvMark
            ;

        this.pvRuleWhiskerLower = setupRuleWhisker(new pvc.visual.Rule(this, this.pvBoxPanel, {
                extensionId:   'boxRuleWhisker',
                freePosition:  true,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            }))
            .intercept('visible', function(scene){
                return scene.vars.category.showRuleWhiskerBelow && this.delegateExtension(true);
            })
            .lock(a_bottom, function(scene){ return scene.vars.category.ruleWhiskerLowerBottom; })
            .lock(a_height, function(scene){ return scene.vars.category.ruleWhiskerLowerHeight; })
            .pvMark
            ;

        /* Box Bar */
        function setupHCateg(sign){
            sign.lock(a_left,  function(scene){ return scene.vars.category.boxLeft;  })
                .lock(a_width, function(scene){ return scene.vars.category.boxWidth; })
                ;
            
            return sign;
        }

        this.pvBar = setupHCateg(new pvc.visual.Bar(this, this.pvBoxPanel, {
                extensionId:   'boxBar',
                freePosition:  true,
                normalStroke:  true
            }))
            .intercept('visible', function(scene){
                return scene.vars.category.showBox && this.delegateExtension(true);
            })
            .lock(a_bottom, function(scene){ return scene.vars.category.boxBottom; })
            .lock(a_height, function(scene){ return scene.vars.category.boxHeight; })
            .override('defaultColor', defaultColor)
            .override('defaultStrokeWidth', def.fun.constant(1))
            .pvMark
            ;

        /* H Rules */
        function setupHRule(rule){
            setupHCateg(rule);
            
            rule.override('defaultColor', defaultColor);
            
            return rule;
        }
        
        this.pvRuleMin = setupHRule(new pvc.visual.Rule(this, this.pvBoxPanel, {
                extensionId:   'boxRuleMin',
                freePosition:  true,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            }))
            .intercept('visible', function(){
                return this.scene.vars.minimum.value != null && this.delegateExtension(true);
            })
            .lock(a_bottom,  function(){ return this.scene.vars.minimum.position; }) // bottom
            .pvMark
            ;

        this.pvRuleMax = setupHRule(new pvc.visual.Rule(this, this.pvBoxPanel, {
                extensionId:   'boxRuleMax',
                freePosition:  true,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            }))
            .intercept('visible', function(){
                return this.scene.vars.maximum.value != null && this.delegateExtension(true);
            })
            .lock(a_bottom,  function(){ return this.scene.vars.maximum.position; }) // bottom
            .pvMark
            ;

        this.pvRuleMedian = setupHRule(new pvc.visual.Rule(this, this.pvBoxPanel, {
                extensionId:   'boxRuleMedian',
                freePosition:  true,
                noHover:       false,
                noSelect:      false,
                noClick:       false,
                noDoubleClick: false
            }))
            .intercept('visible', function(){
                return this.scene.vars.median.value != null && this.delegateExtension(true);
            })
            .lock(a_bottom,  function(){ return this.scene.vars.median.position; }) // bottom
            .override('defaultStrokeWidth', def.fun.constant(2))
            .pvMark
            ;
    },

    /**
     * Renders this.pvScatterPanel - the parent of the marks that are affected by interaction changes.
     * @override
     */
    renderInteractive: function(){
        this.pvBoxPanel.render();
    },

    /**
     * Returns an array of marks whose instances are associated to a datum or group, or null.
     * @override
     */
    _getSelectableMarks: function(){
        return [this.pvBar];
    },

    _buildScene: function(){
        var chart = this.chart,
            measureRolesDimNames = def.query(chart.measureVisualRoles()).object({
                name:  function(role){ return role.name; },
                value: function(role){ return role.firstDimensionName(); }
            }),
            visibleKeyArgs = {visible: true, zeroIfNone: false},
            data = this._getVisibleData(),
            rootScene  = new pvc.visual.Scene(null, {panel: this, group: data}),
            baseScale  = this.axes.base.scale,
            bandWidth  = baseScale.range().band,
            boxWidth   = Math.min(bandWidth * this.boxSizeRatio, this.maxBoxSize),
            orthoScale = this.axes.ortho.scale
            ;

        /**
         * Create starting scene tree
         */
        data.children() // categories
            .each(createCategScene, this);

        return rootScene;
        
        function createCategScene(categData){
            var categScene = new pvc.visual.Scene(rootScene, {group: categData});
            var vars = categScene.vars;
            var colorVarHelper = new pvc.visual.ColorVarHelper(this.chart, this.chart._colorRole);
            
            // Series distinction is ignored
            // If the role is bound by the user, its data will not be visible 
            var serVar = vars.series   = new pvc.visual.ValueLabelVar(null, "");
            var catVar = vars.category = new pvc.visual.ValueLabelVar(categData.value, categData.label);
            
            def.set(catVar,
                'group',    categData,
                'x',        baseScale(categData.value),
                'width',    bandWidth,
                'boxWidth', boxWidth,
                'boxLeft',  bandWidth / 2 - boxWidth / 2);
            
            chart.measureVisualRoles().forEach(function(role){
                var dimName = measureRolesDimNames[role.name],
                    svar;

                if(dimName){
                    var dim = categData.dimensions(dimName),
                        value = dim.sum(visibleKeyArgs);
                    
                    svar = new pvc.visual.ValueLabelVar(value, dim.format(value));
                    svar.position = orthoScale(value);
                } else {
                    svar = new pvc.visual.ValueLabelVar(null, "");
                    svar.position = null;
                }

                vars[role.name] = svar;
            });
            
            colorVarHelper.onNewScene(categScene, /* isLeaf */ true);
            
            // ------------

            var hasMin    = vars.minimum.value  != null,
                hasLower  = vars.lowerQuartil.value != null,
                hasMedian = vars.median.value != null,
                hasUpper  = vars.upperQuartil.value != null,
                bottom,
                top;

            var show = hasLower || hasUpper;
            if(show){
                bottom = hasLower  ? vars.lowerQuartil.position :
                         hasMedian ? vars.median.position :
                         vars.upperQuartil.position
                         ;

                top    = hasUpper  ? vars.upperQuartil.position :
                         hasMedian ? vars.median.position :
                         vars.lowerQuartil.position
                         ;

                show = (top !== bottom);
                if(show){
                    catVar.boxBottom = bottom;
                    catVar.boxHeight = top - bottom;
                }
            }
            
            catVar.showBox  = show;
            
            // vRules
            show = vars.maximum.value != null;
            if(show){
                bottom = hasUpper  ? vars.upperQuartil.position :
                         hasMedian ? vars.median.position :
                         hasLower  ? vars.lowerQuartil.position :
                         hasMin    ? vars.minimum.position  :
                         null
                         ;
                
                show = bottom != null;
                if(show){
                    catVar.ruleWhiskerUpperBottom = bottom;
                    catVar.ruleWhiskerUpperHeight = vars.maximum.position - bottom;
                }
            }

            catVar.showRuleWhiskerUpper = show;

            // ----

            show = hasMin;
            if(show){
                top = hasLower  ? vars.lowerQuartil.position :
                      hasMedian ? vars.median.position :
                      hasUpper  ? vars.upperQuartil.position :
                      null
                      ;

                show = top != null;
                if(show){
                    bottom = vars.minimum.position;
                    catVar.ruleWhiskerLowerHeight = top - bottom;
                    catVar.ruleWhiskerLowerBottom = bottom;
                }
            }
            
            catVar.showRuleWhiskerBelow = show;
            
            // hasMin = vars.minimum.value  != null,
        }
    }
});

/**
 * BoxplotChart is the main class for generating... categorical boxplotcharts.
 * 
 * The boxplot is used to represent the distribution of data using:
 *  - a box to represent the region that contains 50% of the datapoints,
 *  - the whiskers to represent the regions that contains 95% of the datapoints, and
 *  - a center line (in the box) that represents the median of the dataset.
 * For more information on boxplots you can visit  http://en.wikipedia.org/wiki/Box_plot
 *
 * If you have an issue or suggestions regarding the ccc BoxPlot-charts
 * please contact CvK at cde@vinzi.nl
 */
def
.type('pvc.BoxplotChart', pvc.CategoricalAbstract)
.add({

    _processOptionsCore: function(options){
        this.base.apply(this, arguments);

        // Not supported
        options.stacked = false;
    },

    /**
     * Initializes each chart's specific roles.
     * @override
     */
    _initVisualRoles: function(){

        this.base();

        var roleSpecBase = {
                isMeasure: true,
                requireSingleDimension: true,
                requireIsDiscrete: false,
                valueType: Number
            };

        [
            {name: 'median',       label: 'Median',        defaultDimension: 'median', isRequired: true},
            {name: 'lowerQuartil', label: 'Lower Quartil', defaultDimension: 'lowerQuartil'},
            {name: 'upperQuartil', label: 'Upper Quartil', defaultDimension: 'upperQuartil'},
            {name: 'minimum',      label: 'Minimum',       defaultDimension: 'minimum' },
            {name: 'maximum',      label: 'Maximum',       defaultDimension: 'maximum'}
        ].forEach(function(info){
            this._addVisualRole(info.name, def.create(roleSpecBase, info));
        }, this);
    },
    
    _getTranslationClass: function(translOptions){
        return def
            .type(this.base(translOptions))
            .add(pvc.data.BoxplotChartTranslationOper);
    },
    
    _initPlotsCore: function(hasMultiRole){
        new pvc.visual.BoxPlot(this);
        
        if(this.options.plot2){
            // Line Plot
            new pvc.visual.PointPlot(this, {
                name: 'plot2',
                defaults: {
                    LinesVisible: true,
                    DotsVisible:  true,
                    OrthoRole:    'median',
                    ColorAxis:    2
                },
                fixed: {
                    OrthoAxis: 1
                }});
        }
    },
    
    _bindAxes: function(hasMultiRole){
        
        this.base(hasMultiRole);
        
        // Set defaults of Offset property
        var typeAxes = this.axesByType.ortho;
        if(typeAxes){
            typeAxes.forEach(function(axis){
                axis.option.defaults({Offset: 0.02});
            });
        }
    },
    
    /* @override */
    _createPlotPanels: function(parentPanel, baseOptions){
        var options = this.options;
        var plots   = this.plots;
            
        var boxPlot  = plots.box; 
        
        var boxPanel = new pvc.BoxplotPanel(
            this, 
            parentPanel, 
            boxPlot, 
            Object.create(baseOptions));

        // v1 field
        this.bpChartPanel = boxPanel;
        
        var plot2Plot = plots.plot2;
        if(plot2Plot){
            if(pvc.debug >= 3){
                this._log("Creating Point panel.");
            }
            
            var pointPanel = new pvc.PointPanel(
                    this, 
                    parentPanel, 
                    plot2Plot,
                    Object.create(baseOptions));
            
            // HACK:
            pointPanel._v1DimRoleName.value = plot2Plot.option('OrthoRole');
            
            // Legacy fields
            boxPanel.pvSecondLine = pointPanel.pvLine;
            boxPanel.pvSecondDot  = pointPanel.pvDot;
        }
    },
    
    defaults: {
        // plot2: false
        // legend: false,
        crosstabMode: false
        // panelSizeRatio
    }
})
.addStatic({
    measureRolesNames: ['median', 'lowerQuartil', 'upperQuartil', 'minimum', 'maximum']
});